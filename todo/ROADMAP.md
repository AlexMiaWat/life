# План задач для этапов 07-18

## Этап 07: Environment
- [x] Создать простую систему \"Окружающей среды\" (Environment), которая имитирует внешний мир для \"Жизни\". Шаг за шагом: 1. Напишите программу-генератор событий (EventGenerator), которая будет создавать разные происшествия автоматически или по расписанию. 2. Создайте очередь событий (EventQueue) - это как очередь в магазине, где события ждут своей очереди на обработку. 3. Определите класс события (Event) - простую запись, содержащую тип происшествия (например, \"шум\") и его силу (число от -1 до 1). Соедините всё вместе так, чтобы генератор клал события в очередь, а основной цикл программы их брал оттуда.
- [x] Определить пять основных видов происшествий (событий), которые может генерировать окружающая среда. Для каждого вида объясните, что это значит и как оно обычно влияет на \"Жизнь\": 1. \"noise\" (шум) - мелкие случайные колебания, не сильно вредные или полезные. 2. \"decay\" (ухудшение) - постепенное снижение энергии или стабильности, как естественный износ. 3. \"recovery\" (восстановление) - положительное изменение, помогающее прийти в норму. 4. \"shock\" (удар) - внезапное сильное событие, которое может резко изменить состояние. 5. \"idle\" (покой) - ничего не происходит, сила 0. Запишите эти типы в коде как константы или список возможных значений.
- [x] Встроить обработку событий в главный повторяющийся цикл программы (runtime loop). Шаги: 1. В цикле проверяйте, есть ли события в очереди. 2. Если есть, возьмите одно из начала очереди. 3. \"Интерпретируйте\" его - решите, как оно влияет на внутреннее состояние \"Жизни\" (self_state): например, шум слегка меняет стабильность, удар снижает энергию и целостность. 4. Обновите значения энергии, целостности и стабильности на основе силы события. 5. Выведите в консоль информацию о том, что произошло и как изменилось состояние.
- [x] В веб-сервере добавить специальный адрес (endpoint /event), чтобы любой мог вручную добавить событие в очередь окружения. Шаги: 1. В файле API сервера создайте маршрут для POST-запроса на /event. 2. Принимайте данные в формате JSON с полями \"type\" (тип события, например \"shock\") и \"intensity\" (сила от -1 до 1). 3. Создайте объект события на основе этих данных и добавьте его в общую очередь событий. 4. Верните ответ с подтверждением успеха или ошибкой. Теперь можно тестировать систему, отправляя события из браузера или другой программы.
- [x] Написать отдельный файл generator_cli.py - программу для командной строки, которая автоматически генерирует события и отправляет их в API сервера окружения. Шаги: 1. Используйте аргументы командной строки для настройки: интервал между событиями, вероятности типов, диапазон силы. 2. В бесконечном цикле создавайте случайное событие по этим правилам. 3. Отправляйте его на сервер POST-запросом к /event используя библиотеку requests. 4. Добавьте логирование того, что отправлено. Запускайте эту программу параллельно с основным сервером для симуляции реального мира.
- [x] Проверить, что вся система Окружающей среды работает правильно вместе с главным циклом программы. Шаги: 1. Запустите основной сервер с программой \"Жизни\". 2. В другом терминале запустите generator_cli.py для автоматической генерации событий. 3. Наблюдайте вывод в консоли сервера: убедитесь, что события появляются в очереди, берутся в цикл, интерпретируются и меняют состояние логично. 4. Отправьте вручную событие через curl или Postman на /event и проверьте эффект. 5. Остановите генератор, убедитесь, что цикл продолжает работать без ошибок.

## Этап 08: Events and Meaning
- [x] Создать \"Двигатель смысла\" (MeaningEngine) - специальную программу, которая присваивает событию \"смысл\" для \"Жизни\", чтобы оно не было просто числом, а имело контекст. Нужно реализовать три основных метода: 1. appraisal() - оценить текущую важность события (число от 0 до 1, где 1 - критично). 2. impact_model() - спрогнозировать, как именно оно повлияет на состояние (изменения энергии и т.д.). 3. response_pattern() - определить типичную реакцию \"Жизни\" на подобное (например, \"уклоняться\" или \"восстанавливаться\"). Напишите класс с этими методами, используя простые формулы на основе типа события и состояния.
- [x] Создать простую структуру данных под названием Meaning (используя dataclass), которая будет контейнером для хранения всех результатов анализа одного события. В неё войдут поля: важность (из appraisal), модель влияния (из impact_model), паттерн реакции (из response_pattern), тип события, сила и заметки. Это позволит легко передавать и сохранять смысл события между частями программы.
- [x] Написать подробные правила для метода appraisal в MeaningEngine: важность зависит от типа события и текущего состояния \"Жизни\". Например, \"shock\" всегда высоко важно (0.8+), \"noise\" - только если энергия низкая (<0.5, тогда 0.4). Используйте if-else или формулы: важность = базовая_по_типу * множитель_по_состоянию. Протестируйте на примерах разных событий.
- [x] Реализовать метод impact_model: рассчитайте ожидаемые изменения состояния (дельта энергии, стабильности, целостности) на основе смысла события и прошлых паттернов. Например, если паттерн реакции \"уклонение\", то влияние на стабильность меньше. Используйте простые коэффициенты, сохраните как словарь или список.
- [ ] Вставить слой анализа смысла (Meaning Layer) в главный цикл программы сразу после получения события из очереди, но перед непосредственным применением изменений к состоянию. Шаги: 1. Создайте экземпляр MeaningEngine один раз при запуске. 2. Для каждого события вызовите engine.process(event), получите объект Meaning. 3. Используйте значения из Meaning для корректировки реальных изменений состояния (например, умножьте силу на важность). 4. Сохраните Meaning для мониторинга или памяти. 5. Запустите тесты с генератором событий, проверьте логи.
- [ ] Полностью заменить старую прямую интерпретацию событий в методе _interpret_event на вызов MeaningEngine. Шаги: 1. Удалите старые if-else по типам событий. 2. Вместо этого: meaning = engine.process(event), затем примените impact из meaning к self_state. 3. Обработайте edge-кейсы (если engine вернул None). 4. Сохраните обратную совместимость с существующими тестами. 5. Обновите логи на вывод смысла.
- [ ] Обновить модуль мониторинга (Monitor), чтобы вместо показа сырых событий (тип + сила) отображалась информация из анализа смысла: важность, ожидаемое влияние, рекомендуемая реакция. Шаги: 1. В console.py добавьте вывод полей из Meaning. 2. Форматируйте красиво, например: \"Событие: shock (сила -0.5), важность 0.9, влияние: энергия -0.1, реакция: уклоняться\". 3. Протестируйте с запущенным циклом.

## Этап 09: Memory and Experience
- [ ] Создать новую папку src/memory/ и в ней основные классы: MemoryStorage для хранения всех воспоминаний (как база данных в памяти), MemoryManager для операций добавления, поиска, удаления и запросов. Начните с простого: Storage как словарь или список объектов Experience.
- [ ] Реализовать три типа памяти внутри Memory: 1. Эпизодическая память - записи конкретных событий и состояний в определённый момент (\"в тике 123 был shock, состояние было X\"). 2. Поведенческая память - что \"Жизнь\" делала в ответ (\"на shock выбрали адаптацию\"). 3. Контекстная память - связи между эпизодами (\"shock часто следует за decay\"). Добавьте поле type в каждый объект памяти.
- [ ] Определить структуру хранения опыта как простую графовую модель: каждый опыт - узел с данными (тип события, состояние до/после, действие). Связи между узлами - с весом (число, показывающее силу ассоциации, от 0 до 1). Используйте два словаря: nodes = {id: data}, edges = {(id1, id2): weight}.
- [ ] Добавить механизм создания нового опыта из события и его последствий: после интерпретации события и любого действия создайте узел с деталями (время, событие, изменения состояния, решение если было). Найдите похожие узлы в памяти и добавьте/обновите связи с весом на основе сходства.
- [ ] Реализовать забывание воспоминаний двумя способами: 1. Затухание - каждый тик или сессию умножайте вес узлов и связей на 0.999. 2. Вытеснение - если общее количество узлов > лимита (например 1000), удалите узлы с наименьшим весом. Запускайте проверку раз в 100 тиков.
- [ ] Интегрировать сохранение всей памяти между запусками программы: добавьте методы save_to_file() и load_from_file() в MemoryManager, используя JSON для сериализации узлов и связей. Вызывайте save при завершении, load при старте.
- [ ] Добавить мягкое влияние памяти на поведение \"Жизни\": в процессах вроде Decision или Adaptation предлагайте похожие прошлые опыты как подсказки (топ-3 по весу), но с вероятностью игнорирования (например 30% случайности), чтобы память не доминировала.

## Этап 10: Activation and Recall
- [ ] Создать механизм разделения памяти на долгосрочное хранилище (всё накопленное) и активную память (только то, что сейчас в фокусе внимания, 10-20 элементов). Активная - быстрая подмножество для быстрых запросов.
- [ ] Реализовать четыре триггера для активации воспоминаний из долгосрочной памяти: 1. Сходство текущего события с прошлым. 2. Повтор паттерна (последние 3 события совпадают с прошлыми). 3. Ошибка (ухудшение после действия). 4. Необычное состояние (энергия <0.3). При срабатывании триггера ищите подходящие опыты.
- [ ] Добавить процесс активации: для каждого кандидата из памяти вычислите \"резонанс\" (похожесть по типу события, состоянию - простая формула расстояния). Отберите топ-5 по резонансу и переместите в активную память.
- [ ] Реализовать ограничения для активной памяти: максимальный объём (20 элементов), время жизни TTL (удалять через 50 тиков если не обновлялось). Проверяйте и чистите каждые 10 тиков.
- [ ] Создать механизм вспоминания (recall) с имитацией неточностей: при извлечении из активной памяти добавьте случайный шум к числам (например +/-5% к весам или силам), чтобы память была неидеальной.
- [ ] Интегрировать активную память в принятие решений: передавайте её как дополнительный вход в DecisionMaker, где она используется для оценки вариантов на основе прошлых похожих случаев.

## Этап 11: Decision
- [ ] Создать папку src/decision/ и класс DecisionMaker - центральный компонент для выбора, что делать в текущей ситуации.
- [ ] Реализовать простейшую форму выбора: генерируйте 2-4 допустимых варианта действий (например \"ничего не делать\", \"адаптировать\", \"вспомнить\"), оцените каждый по простому правилу и выберите лучший или случайный.
- [ ] Определить входные данные для DecisionMaker: 1. Текущее состояние self_state. 2. Список элементов активной памяти. 3. Предопределённый список возможных вариантов действий (безопасные, в рамках системы).
- [ ] Добавить влияние активной памяти: для каждого варианта найдите похожие опыты в памяти, усредните их исходы как оценку, но добавьте случайность (не 100% следовать).
- [ ] Интегрировать DecisionMaker в главный цикл после обработки событий и обновления памяти: вызовите его, получите выбранный вариант, передайте дальше.
- [ ] Обеспечить устойчивость: отслеживайте, привело ли решение к улучшению/ухудшению (через feedback позже), снижайте вес плохих вариантов в поведенческой памяти.

## Этап 12: Action and Execution
- [ ] Создать папку src/action/ и класс ActionExecutor - отвечает за выполнение выбранного решения.
- [ ] Реализовать базовое выполнение: в зависимости от выбранного варианта слегка измените состояние или параметры (например, \"адаптация\" повышает множитель восстановления на 0.01).
- [ ] Определить 4-5 допустимых действий, безопасных для системы: \"подождать\", \"адаптировать параметры\", \"активировать память\", \"зафиксировать опыт\" - без риска краха.
- [ ] Записать факт выполнения действия в память (как поведенческий опыт), но не ждать немедленного результата - эффект проявится через события среды.
- [ ] Вставить ActionExecutor в цикл сразу после Decision: возьмите вариант, выполните, залогируйте.
- [ ] В минимальной форме не добавлять обратную связь от действий - пусть среда реагирует естественно через события.

## Этап 13: Feedback
- [ ] Создать папку src/feedback/ и класс для обработки последствий: FeedbackCollector собирает данные о том, что произошло после действия.
- [ ] Зафиксировать простые последствия: через 3-10 тиков после действия сравните состояние до и после, запишите разницу как \"успех\" или \"провал\".
- [ ] Определить источники данных для feedback: 1. Изменения в self_state за период после действия. 2. Новые события из очереди, связанные по времени.
- [ ] Накопить опыт из feedback: создайте узел \"действие X привело к Y\" и свяжите с памятью, но не применяйте обучение сразу.
- [ ] Интегрировать в цикл: после каждого Action запланируйте проверку feedback через несколько тиков.
- [ ] Сделать feedback независимым: он работает на основе логов состояний, не зависит от других модулей.

## Этап 14: Learning
- [ ] Создать папку src/learning/ и класс LearningEngine для поиска закономерностей в накопленном опыте.
- [ ] Простое обучение: сканируйте память на повторяющиеся пары \"событие-действие-исход\" (минимум 3 раза), повысьте вес такой связи на 0.1.
- [ ] Источники: вся память, записи feedback, история последних 100 состояний из лога.
- [ ] Обновляйте веса связей в графе памяти, но поведение (Decision) использует их только как слабый сигнал (+/-10% к оценке).
- [ ] Запускать Learning как фон: раз в 50-100 тиков на всей памяти.
- [ ] Защитить от переобучения: добавьте шум к весам, максимум вес 0.8, случайное снижение старых паттернов.

## Этап 15: Adaptation
- [ ] Создать папку src/adaptation/ и класс AdaptationManager для медленных изменений поведения.
- [ ] Базовая адаптация: на основе feedback постепенно меняйте параметры интерпретации событий (например, чувствительность к shock +0.001).
- [ ] Триггеры: 1. Низкая эффективность (стабильность падает 20 тиков). 2. Новые сильные паттерны в памяти.
- [ ] Ограничения: изменение не больше 0.01 за раз, не чаще 1/50 тиков, только если стабильность >0.4.
- [ ] В цикл после Feedback: если триггер, примените маленькое изменение.
- [ ] Обеспечить обратимость: храните историю адаптаций в отдельном логе, откатывайте если ухудшение.

## Этап 16: Goals
- [ ] Создать папку src/goals/ и класс GoalsManager для отслеживания желаемых состояний.
- [ ] Минимальные цели: поддерживать энергию >0.5, стабильность >0.6, целостность >0.3 - проверять каждые 10 тиков.
- [ ] Иерархия: 1. Выживание (энергия >0.2). 2. Стабильность. 3. Развитие (размер памяти >50).
- [ ] В Decision добавьте бонус (+0.2 к оценке) вариантам, которые приближают к ближайшей цели.
- [ ] Передавать список приоритетных целей в DecisionMaker каждый раз.
- [ ] Если цель не прогрессирует 100 тиков, снижайте её приоритет или замените.

## Этап 17: Planning
- [ ] Создать папку src/planning/ и класс PlanningRecorder для записи возможных будущих цепочек.
- [ ] Простое планирование: на основе последних событий и памяти запишите гипотезы вроде \"после shock вероятно recovery с вероятностью 0.6\".
- [ ] Источники: текущие 5 событий, топ опыты из памяти, текущее состояние.
- [ ] Использовать планы в Intelligence только как статистику, без попыток их выполнить.
- [ ] В цикл раз в 20 тиков: обновите 3-5 гипотетических цепочек.
- [ ] Планы пассивны: только фиксировать статистику, не влиять на реальные действия.

## Этап 18: Intelligence
- [ ] Создать папку src/intelligence/ и класс IntelligenceMonitor для нейтрального сбора информации о системе.
- [ ] Минимальный интеллект: измеряйте и фиксируйте размеры - количество узлов в памяти, число feedback, паттернов обучения, планов.
- [ ] Прокси-источники: запросы метрик от Memory.size, Adaptation.changes_count, Learning.patterns_count, Planning.chains_count.
- [ ] Агрегируйте в простые числа: \"общий опыт\" = память + планы, без каких-либо выводов или предсказаний.
- [ ] В конец цикла: обновите intelligence метрики и выведите в отдельный лог.
- [ ] Строго ограничить: никаких интерпретаций, предсказаний или контроля - только сырые счётчики, чтобы не эволюционировало в ИИ.

## Финальные шаги реорганизации документации
- [x] Актуализировать TODO каталоги (ROADMAP, DEBT, CURRENT) согласно новым реалиям
- [x] Создать MANIFEST.md с описанием проекта и принципами
- [x] Проверить ссылки в документации на корректность
- [x] Создать README.md для документации
- [x] Проверить заголовки и структуру файлов
- [x] Проверить на дублирование между файлами
- [x] Создать итоговый отчет о реорганизации
