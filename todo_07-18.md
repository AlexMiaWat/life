# План задач для этапов 07-18

## Этап 07: Environment
- [x] Реализовать базовую архитектуру Environment с EventGenerator, EventQueue, Event
- [x] Определить типы событий: noise, decay, recovery, shock, idle
- [x] Интегрировать интерпретацию событий в runtime loop с изменением self_state
- [x] Добавить API /event для ручного добавления событий
- [x] Создать внешний генератор событий generator_cli.py
- [x] Протестировать работу Environment в runtime loop

## Этап 08: Events and Meaning
- [x] Реализовать MeaningEngine с методами appraisal, impact_model, response_pattern
- [x] Создать dataclass Meaning для хранения интерпретированного значения события
- [x] Определить логику оценки значимости на основе типа события и состояния Life
- [x] Реализовать расчет влияния на состояние с учетом паттернов реакции
- [ ] Интегрировать Meaning Layer в runtime loop после получения событий
- [ ] Заменить прямую интерпретацию событий в _interpret_event на использование MeaningEngine
- [ ] Обновить Monitor для отображения значений событий вместо сырых событий

## Этап 09: Memory and Experience
- [ ] Создать модуль src/memory/ с классами для хранения и управления памятью
- [ ] Реализовать типы памяти: эпизодическая, поведенческая, контекстная
- [ ] Определить структуру хранения опыта с графовой моделью (узлы-опыты, связи-контексты)
- [ ] Добавить механизм формирования опыта из событий и их последствий
- [ ] Реализовать механизм забывания с затуханием веса и вытеснением
- [ ] Интегрировать сохранение памяти между сессиями
- [ ] Добавить влияние памяти на поведение Life без доминирования

## Этап 10: Activation and Recall
- [ ] Создать механизм разделения хранилища памяти и активной памяти
- [ ] Реализовать триггеры активации: сходство контекста, повтор паттерна, ошибка, необычное состояние
- [ ] Добавить процесс активации с вычислением резонанса и отбором воспоминаний
- [ ] Реализовать ограничения активной памяти (TTL, объем)
- [ ] Создать механизм recall с возможностью неточностей и искажений
- [ ] Интегрировать активную память в процесс принятия решений

## Этап 11: Decision
- [ ] Создать модуль src/decision/ с классом DecisionMaker
- [ ] Реализовать минимальную форму выбора из допустимых вариантов
- [ ] Определить входы: текущее состояние, активная память, список вариантов
- [ ] Добавить влияние активной памяти на выбор без доминирования
- [ ] Интегрировать Decision в runtime loop после обработки событий
- [ ] Обеспечить устойчивость к ошибочным решениям

## Этап 12: Action and Execution
- [ ] Создать модуль src/action/ с классом ActionExecutor
- [ ] Реализовать минимальную форму выполнения: попытка применения выбранного варианта
- [ ] Определить допустимые действия в рамках архитектуры Life
- [ ] Добавить фиксацию факта попытки без ожидания результата
- [ ] Интегрировать Action в runtime loop после Decision
- [ ] Обеспечить отсутствие обратной связи в минимальной форме

## Этап 13: Feedback
- [ ] Создать модуль src/feedback/ для обработки обратной связи от среды
- [ ] Реализовать минимальную форму фиксации последствий действий
- [ ] Определить источники обратной связи: изменения состояния, новые события
- [ ] Добавить накопление опыта из feedback без немедленного обучения
- [ ] Интегрировать Feedback в runtime loop после Action
- [ ] Обеспечить независимость от других слоев

## Этап 14: Learning
- [ ] Создать модуль src/learning/ для извлечения паттернов из опыта
- [ ] Реализовать минимальную форму обучения: фиксация повторяющихся связей
- [ ] Определить источники данных: память, feedback, история состояний
- [ ] Добавить обновление весов в памяти без изменения поведения
- [ ] Интегрировать Learning в runtime loop как фоновый процесс
- [ ] Предотвратить переобучение и фиксацию на прошлых паттернах

## Этап 15: Adaptation
- [ ] Создать модуль src/adaptation/ для корректировки поведения
- [ ] Реализовать минимальную форму адаптации: постепенное изменение параметров
- [ ] Определить триггеры адаптации: низкая эффективность, новые паттерны
- [ ] Добавить ограничения на скорость и масштаб изменений
- [ ] Интегрировать Adaptation в runtime loop с проверками стабильности
- [ ] Обеспечить обратимость адаптаций

## Этап 16: Goals
- [ ] Создать модуль src/goals/ для формирования целей
- [ ] Реализовать минимальную форму целей: поддержание базовых параметров
- [ ] Определить иерархию целей: выживание, стабильность, развитие
- [ ] Добавить влияние целей на Decision без жесткого контроля
- [ ] Интегрировать Goals в процесс принятия решений
- [ ] Предотвратить фиксацию на недостижимых целях

## Этап 17: Planning
- [ ] Разработать модуль src/planning/ для фиксации потенциальных последовательностей
- [ ] Реализовать минимальную форму планирования: запись возможных цепочек событий
- [ ] Определить источники данных: текущие события, память, состояние
- [ ] Добавить использование planning в Intelligence без исполнения планов
- [ ] Интегрировать Planning в runtime loop как пассивную фиксацию
- [ ] Обеспечить отсутствие активного планирования действий

## Этап 18: Intelligence
- [ ] Разработать модуль src/intelligence/ для нейтральной обработки информации
- [ ] Реализовать минимальную форму интеллекта: фиксация размеров источников данных
- [ ] Определить прокси-источники: память, адаптация, обучение, планирование
- [ ] Добавить агрегацию данных без интерпретации или предсказаний
- [ ] Интегрировать Intelligence в runtime loop как финальный слой обработки
- [ ] Предотвратить развитие в полноценный ИИ или агентность