# Скептический разбор: текущие доработки и документация (task_1768894781)
 
**Дата:** 2026-01-20  
**ID задачи (запрошенный):** `1768894781`  
**Роль:** Skeptic (критический аудит кода/доков/плана)
 
---
 
## 0) Контекст и ограничение аудита (важно)
 
### 0.1. Нет прямых артефактов по ID `1768894781`
Поиск по репозиторию не дал **ни одного** упоминания `1768894781`. Это уже риск:
- невозможно однозначно связать «текущую задачу» с конкретным планом/результатом/коммитом;
- повышается шанс, что ревью будет сделано «по соседней задаче», а не по нужной.
 
### 0.2. Что реально нашлось рядом (кластер релевантности)
Вместо `1768894781` найдены и проанализированы:
- `docs/results/current_plan_task_1768893889.md` — план по `search_mode` (AND/OR/PHRASE) для `search_docs/search_todo`.
- `docs/results/plan_result_task_1768894189.md` — промежуточный отчет о правках `_tokenize_query` и тесте.
- `mcp_index.py` — фактическая реализация `search_docs/search_todo` и `_tokenize_query`.
- `src/test/test_mcp_server.py` — “тестовый скрипт” с добавленным кейсом про quoted query + OR.
- `cursor_commands/instruction_test_complex_1768894273_NEW_CHAT.txt` — инструкция, косвенно относящаяся к тестам/процессу.
- `docs/results/test_task_1768894575.md` — отчет о тестировании «новой функциональности» (другой домен, но показатель качества документов).
 
Вывод: ревью ниже фактически покрывает **реальную текущую активность в репо**, но **не может** гарантировать 1:1 соответствие «task_1768894781», потому что ее ID не отслеживается.
 
---
 
## 1) Отклонения от плана / противоречия в документации
 
### 1.1. Ключевое расхождение: “PHRASE определяется автоматически по кавычкам” — в коде это не так
**План утверждает** (см. `docs/results/current_plan_task_1768893889.md`):
- PHRASE mode определяется по кавычкам;
- пример: `"test query"` → `("PHRASE", "test query")`.
 
**Фактический код** (`mcp_index.py`, `_tokenize_query`):
- если запрос в кавычках и `mode` == AND/OR, кавычки **не включают PHRASE**, запрос токенизируется;
- по умолчанию `search_mode="AND"`, значит вызов `search_docs('"test query"')` пойдет как **AND**, а не PHRASE.
 
**Дополнительная проблема в докстрингах:** в `search_docs/search_todo` написано:  
> `search_mode: ... PHRASE определяется автоматически по кавычкам`  
Это утверждение **противоречит текущей логике**: по кавычкам PHRASE включается только если `search_mode="PHRASE"`.
 
Риск:
- пользователи инструмента будут ожидать PHRASE-поиск «как в плане/доке», но получать AND-поиск;
- это классический UX- и API-брейк на уровне семантики.
 
### 1.2. “Промежуточный отчет” фиксирует новую семантику, но план/критерии приемки не обновлены
`docs/results/plan_result_task_1768894189.md` описывает:
- “приоритет явного `search_mode` над кавычками”;
- “явный `search_mode="PHRASE"` работает и без кавычек”.
 
Это **меняет контракт** по сравнению с планом, но в плане (`current_plan_task_1768893889.md`) критерии приемки помечены ✅ заранее, без отражения изменения требований/семантики.
 
Скептический вывод: документ «план» выглядит как артефакт “постфактум”, а не контроль исполнения.
 
### 1.3. Неконсистентность даты в отчете о тестировании
`docs/results/test_task_1768894575.md` содержит:
- **Дата:** `2025-01-20`
 
При том, что текущая дата сессии и большинство артефактов — **2026-01-20**.  
Риск: доверие к отчету падает (ошибка шаблона/копипаст/несостыковка источника).
 
### 1.4. Инструкция `instruction_test_complex_1768894273...` содержит Windows-путь в Linux/WSL контексте
Файл ожидаемого результата указан как:
- `D:\Space\life\cursor_results\result_test_complex_1768894273.txt`
 
В текущем окружении проекта путь — `/workspace/...`.  
Риск: инструкции непереносимы/вводят в заблуждение, задачи “выполнены”, но результаты ищут «не там».
 
---
 
## 2) Проблемы и сомнительные места в коде (`mcp_index.py`)
 
### 2.1. Пустой/почти пустой запрос может матчить “всё”
`_search_and` использует `all(token in content_lower for token in tokens)`.  
Если `tokens == []`, то `all([]) == True` ⇒ **совпадение для любого документа**.
 
`_search_phrase` при `phrase == ""` вернет `"" in content.lower()` ⇒ тоже **True**.
 
Как это достигается:
- `query="   "` после `.strip()` станет `""`;
- или `query="!!!"` => regex `\b\w+\b` даст `[]`.
 
Риск:
- “пустой поиск” станет “показать первые N документов”, что выглядит как баг и может быть дорогим по IO.
 
### 2.2. `_find_context_lines` выбирает “первый токен”, а не “первый реально найденный”
Для AND/OR берется `tokens_or_phrase[0]` без проверки, что он встречается в контенте.  
Если первый токен не встречается, но документ матчится (например, OR-режим и второй токен присутствует), контекст может:
- быть пустым/неинформативным;
- показывать не тот фрагмент (потому что матч был по другому слову).
 
Риск: результаты выглядят неверными (“нашло”, но контекст не подтверждает).
 
### 2.3. Валидация `search_mode` молча “чинит” неизвестные значения
Если передать `search_mode="X"`, режим станет `AND` без сообщения.  
Риск: скрытые ошибки интеграций/клиентов — вместо явной диагностики пользователь получает “странные” результаты.
 
### 2.4. Слишком широкие `except Exception: continue`
В `search_docs/search_todo/search_code` исключения чтения файла просто проглатываются.  
Риск:
- можно потерять результаты из-за одной ошибки кодировки/IO, но пользователь не узнает;
- дебаг проблем в проде усложняется.
 
---
 
## 3) Проблемы и сомнительные места в тестах (`src/test/test_mcp_server.py`)
 
### 3.1. Тесты почти не проверяют корректность режимов поиска (only “smoke”)
Большинство assert-ов вида:
- `"режим: OR" in result or "Найдено" in result or "ничего не найдено" ...`
 
Это позволяет пройти тесту при очень широком спектре поломок:
- режим не тот (например AND вместо PHRASE);
- совпадения неверные;
- контекст пустой;
- строка просто содержит “Найдено ...” по формату вывода.
 
### 3.2. Самый показательный провал: тест “PHRASE mode” фактически не гарантирует PHRASE
`test_search_docs_phrase_mode()` вызывает:
- `await search_docs('"test query"', limit=3)` **без** `search_mode="PHRASE"`.
 
При текущей логике `_tokenize_query` это будет **AND**, а не PHRASE.  
Но тест пройдет, потому что допускает `"Найдено"` / `"ничего не найдено"`.
 
Риск: тесты создают ложное ощущение корректности, особенно для критерия приемки FC3.
 
### 3.3. Тест добавлен в `main()` вручную — это не pytest и легко забыть
Скрипт запускается как самостоятельный файл, а не через pytest-раннер:
- можно забыть добавить новый тест в `main()` и “случайно зеленить”;
- CI, скорее всего, живет на pytest и может вообще не исполнять этот сценарий.
 
---
 
## 4) Сомнительные документы/процесс
 
### 4.1. “Все тесты прошли, проблем не обнаружено” — конфликтует с качеством формулировок тестов/отчетов
`docs/results/test_task_1768894575.md` заявляет “Проблем не обнаружено”, но:
- дата в шапке неверна;
- отчет выглядит как шаблонная сводка, не как протокол запуска (нет команд запуска/окружения/логов);
- вообще относится к другой функциональности, но демонстрирует общий паттерн “слишком уверенно”.
 
Скептический вывод: репорты часто декларативные и могут быть **не проверяемыми**.
 
### 4.2. Несовместимость “плана” и “промежуточного отчета”
Промежуточный отчет утверждает, что поведение исправлено “по плану/примеру”, но:
- ключевой пункт плана (кавычки ⇒ PHRASE) не выполняется в текущем коде;
- тест на PHRASE не подтверждает PHRASE.
 
---
 
## 5) Итог: что меня смущает больше всего (коротко)
 
- **Сломан/изменен контракт PHRASE по кавычкам**, при этом докстринги и план утверждают обратное.
- **Тесты не ловят регрессии**, они слишком “мягкие” и допускают неверную семантику.
- **Пустой запрос может матчить всё**, что потенциально неприятно и по UX, и по IO.
- **Артефакт “task_1768894781” отсутствует**, сложно доказуемо привязать изменения к заданию.
- **Документы/инструкции** содержат явные несостыковки (дата 2025, Windows-путь).
 
---
 
## 6) Рекомендации (как минимум)
 
### Критично (блокирует доверие)
1. Определиться с контрактом: кавычки **должны** включать PHRASE по умолчанию или **нет**.  
   - Если “да” — исправить `_tokenize_query` (и добавить тест, который реально это проверяет).  
   - Если “нет” — обновить план/критерии приемки/докстринги, чтобы не вводить в заблуждение.
2. Усилить тесты: проверять **факт фильтрации** (на контролируемых фикстурах), а не только наличие слов “Найдено/режим”.
3. Ввести явное поведение для пустого запроса (например: возвращать “пустой запрос”, или требовать хотя бы 1 токен).
 
### Желательно
4. Улучшить `_find_context_lines`: выбирать **первый реально найденный** токен/строку совпадения.
5. Перестать проглатывать исключения “втихую” (хотя бы добавить счетчик пропусков/диагностику).
6. Привести отчеты/инструкции к текущей среде (даты, пути).
 
---
 
Отчет готов!
