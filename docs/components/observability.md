# Компонент Observability

**Последнее обновление:** 2026-01-22
**Статус:** Активная система структурированного логирования (после признания архитектурного обмана)
**Архитектурное решение:** Активное логирование ключевых этапов для понимания поведения системы

---

## Обзор

Компонент Observability реализует **активную систему структурированного логирования** для системы Life. Несмотря на изначальные планы пассивного наблюдения (ADR 001), анализ показал, что система Life требует активного логирования каждого тика для понимания своего поведения и корректной работы.

**Ключевые принципы:**
- **Активное логирование**: структурированное логирование ключевых этапов на каждом тике
- **Runtime интеграция**: StructuredLogger интегрирован в runtime loop
- **Прозрачность операций**: логирование всех стадий: event → meaning → decision → action → feedback
- **Внешний анализ**: данные для инструментов разработчика и отладки

## Архитектурные принципы

### 1. Активное структурированное логирование
- **Runtime интеграция**: StructuredLogger является частью runtime loop
- **Полное покрытие**: логирование всех ключевых этапов обработки
- **Минимальное влияние**: оптимизированные вызовы для сохранения производительности

### 2. Структурированные данные
- **JSONL формат**: структурированное логирование в JSON Lines
- **Корреляция**: correlation_id для связывания событий в цепочки
- **Временные метки**: точное время каждого этапа обработки

### 3. Прозрачность системы
- **Полная видимость**: логирование позволяет понять поведение системы
- **Отладка**: данные для анализа проблем и улучшения системы
- **Без обратной связи**: логирование не влияет на принятие решений

## Компоненты системы

### StructuredLogger
**Файл:** `src/observability/structured_logger.py`

Основной компонент активного структурированного логирования. Логирует ключевые этапы обработки в runtime loop.

**Логируемые этапы:**
- `tick_start`: начало тика с размером очереди событий
- `event`: входящие события с correlation_id
- `meaning`: интерпретация событий
- `decision`: принятые решения
- `action`: выполненные действия
- `feedback`: обратная связь от действий

**Принципы работы:**
- Активное логирование на каждом тике runtime loop
- JSONL формат для эффективного хранения и анализа
- Корреляция событий через correlation_id
- Оптимизированные вызовы для минимального влияния на производительность

### UnifiedObservationAPI
**Файл:** `src/observability/unified_observation_api.py`

Унифицированный интерфейс для операций наблюдения (требует переосмысления после признания активной архитектуры).

**Текущее состояние:**
- Создан для пассивной архитектуры, но не интегрирован в runtime
- Содержит мертвый код (PassiveDataSink, AsyncDataSink)
- Требует переработки или удаления

### AsyncObservationAPI
**Файл:** `src/observability/async_observation_api.py`

Асинхронная версия API наблюдения (требует переосмысления).

## Архитектурные границы

### ✅ Допустимые паттерны

1. **Активное логирование в runtime**
   ```python
   # Runtime loop интегрирует структурированное логирование
   structured_logger.log_tick_start(ticks, queue_size)
   structured_logger.log_event(event)
   structured_logger.log_decision(correlation_id)
   ```

2. **JSONL структурированные данные**
   ```python
   # Логирование в JSONL формате
   {
     "timestamp": 1640000000.0,
     "stage": "event",
     "correlation_id": "abc123",
     "data": {"event_type": "recovery", "intensity": 0.8}
   }
   ```

### ⚠️ Текущие проблемы

1. **Мертвый код**
   - UnifiedObservationAPI создан, но не используется
   - PassiveDataSink и AsyncDataSink не получают данных из runtime
   - RawDataCollector возвращает фейковые данные

2. **Архитектурная неопределенность**
   - Система позиционировалась как пассивная, но оказалась активной
   - Документация лгала о реальной архитектуре
   - Требуется честное переосмысление концепции observability

3. **Неиспользуемые компоненты**
   - AsyncObservationAPI требует переработки
   - Passive компоненты не интегрированы в активную архитектуру

## Интеграция

### Runtime интеграция структурированного логгера

StructuredLogger **активно интегрирован** в runtime loop для логирования ключевых этапов:

```python
# runtime/loop.py - активная интеграция
structured_logger = StructuredLogger()  # Создается в начале

# Логирование на каждом тике
structured_logger.log_tick_start(self_state.ticks, queue_size)

# Логирование обработки событий
correlation_id = structured_logger.log_event(event)
structured_logger.log_meaning(event, meaning, correlation_id)
structured_logger.log_decision(correlation_id)

# Логирование действий и feedback
structured_logger.log_action(action_id, correlation_id)
structured_logger.log_feedback(feedback, correlation_id)
```

### Конфигурация и инициализация

```python
from src.observability.structured_logger import StructuredLogger

# Создание логгера с конфигурацией
structured_logger = StructuredLogger(
    log_directory="data/logs",
    enable_console=False,
    enable_file=True
)
```

## Формат данных

### JSONL логи структурированного логирования

Каждая запись представляет собой JSON объект с полной информацией о этапе обработки:

```jsonl
{"timestamp": 1640000000.123, "stage": "tick_start", "tick_number": 1000, "queue_size": 0}
{"timestamp": 1640000000.145, "stage": "event", "correlation_id": "abc123", "event_type": "recovery", "intensity": 0.8}
{"timestamp": 1640000000.156, "stage": "meaning", "correlation_id": "abc123", "significance": 0.9}
{"timestamp": 1640000000.167, "stage": "decision", "correlation_id": "abc123"}
{"timestamp": 1640000000.178, "stage": "action", "correlation_id": "abc123", "action_id": "action_1000_absorb_1640000000178"}
{"timestamp": 1640000000.189, "stage": "feedback", "correlation_id": "abc123", "delay_ticks": 5}
```

### Корреляция событий

Каждое событие получает `correlation_id` для связывания всей цепочки обработки:
- **event** → **meaning** → **decision** → **action** → **feedback**

### Анализ данных

Логи предназначены для внешнего анализа и отладки системы Life.

## Тестирование

### Архитектурные тесты
- **Runtime интеграция**: проверка корректности логирования на каждом тике
- **Формат данных**: валидация JSONL структуры логов
- **Корреляция**: проверка связывания событий по correlation_id
- **Производительность**: измерение влияния логирования на runtime

### Функциональные тесты
- **StructuredLogger**: корректность логирования всех этапов
- **Runtime loop**: работа с активным логированием
- **Data persistence**: сохранение логов в файлы
- **Error handling**: graceful degradation при проблемах I/O

## Мониторинг и поддержка

### Метрики использования
- Количество собранных записей
- Размер хранилища данных
- Время работы observer thread

### Логирование
- DEBUG: детали сбора данных
- INFO: статус операций
- WARNING: проблемы с доступом к файлам
- ERROR: критические ошибки

## Риски и ограничения

### Архитектурные проблемы
- **Активная интеграция**: логирование влияет на производительность runtime
- **Мертвый код**: UnifiedObservationAPI и пассивные компоненты не используются
- **Архитектурный обман**: документация лгала о пассивной природе системы

### Надежность
- **I/O зависимость**: логирование может замедлять работу при проблемах с дисками
- **Объем данных**: JSONL файлы могут расти быстро при высокой активности
- **Error handling**: сбои логирования не должны останавливать runtime

## Будущие улучшения

### Критично (немедленно)
- **Удалить мертвый код**: UnifiedObservationAPI, PassiveDataSink, AsyncDataSink
- **Исправить документацию**: привести в соответствие с реальной архитектурой
- **Признать активную архитектуру**: перестать лгать о "пассивном наблюдении"

### Важно (1-2 недели)
- **Оптимизация производительности**: минимизировать влияние логирования на runtime
- **Асинхронное логирование**: буферизация для снижения I/O блокировок
- **Ротация логов**: управление размером и количеством файлов

### Желательно (месяц)
- **Анализ логов**: инструменты для анализа собранных данных
- **Метрики производительности**: статистика влияния на runtime
- **Конфигурация логирования**: уровни детализации и фильтры

---

## Ссылки

- [Отчет скептика: Архитектурный обман observability](reviews/skeptic_task_1769036620_20260122.md)
- [CHANGELOG: История изменений](../../CHANGELOG.md)