# Компонент Observability

**Последнее обновление:** 2026-01-22
**Статус:** ✅ Стабильная активная архитектура (критические проблемы исправлены)
**Архитектурное решение:** Активное структурированное логирование интегрировано в runtime

---

## Обзор

Компонент Observability реализует **активную систему структурированного логирования** для системы Life. Несмотря на изначальные планы пассивного наблюдения (ADR 001), анализ показал, что система Life требует активного логирования каждого тика для понимания своего поведения и корректной работы.

**Ключевые принципы:**
- **Активное логирование**: структурированное логирование ключевых этапов на каждом тике
- **Runtime интеграция**: StructuredLogger интегрирован в runtime loop
- **Прозрачность операций**: логирование всех стадий: event → meaning → decision → action → feedback
- **Внешний анализ**: данные для инструментов разработчика и отладки

## Архитектурные принципы

### 1. Активное структурированное логирование

### 2. Статус компонентов

#### ✅ Активные компоненты
- **StructuredLogger**: Основной компонент логирования, интегрирован в runtime
- **AsyncLogWriter**: Асинхронная запись логов
- **RuntimeAnalysisEngine**: Анализ в реальном времени (признан как часть активной архитектуры)

#### ✅ Устаревшие компоненты (поддерживаются для совместимости)
- **PassiveDataSink**: Поддерживается для совместимости, но рекомендуется использовать StructuredLogger
- **AsyncDataSink**: Удален как мертвый код (не анализировал данные)

#### Рекомендация: Унифицировать вокруг StructuredLogger как единственного источника данных
- **Runtime интеграция**: StructuredLogger является частью runtime loop
- **Полное покрытие**: логирование всех ключевых этапов обработки
- **Минимальное влияние**: оптимизированные вызовы для сохранения производительности

### 2. Структурированные данные
- **JSONL формат**: структурированное логирование в JSON Lines
- **Корреляция**: correlation_id для связывания событий в цепочки
- **Временные метки**: точное время каждого этапа обработки

### 3. Прозрачность системы
- **Полная видимость**: логирование позволяет понять поведение системы
- **Отладка**: данные для анализа проблем и улучшения системы
- **Без обратной связи**: логирование не влияет на принятие решений

## Компоненты системы

### StructuredLogger
**Файл:** `src/observability/structured_logger.py`

Основной компонент активного структурированного логирования. Логирует ключевые этапы обработки в runtime loop.

**Логируемые этапы:**
- `tick_start`: начало тика с размером очереди событий
- `event`: входящие события с correlation_id
- `meaning`: интерпретация событий
- `decision`: принятые решения
- `action`: выполненные действия
- `feedback`: обратная связь от действий

**Принципы работы:**
- Активное логирование на каждом тике runtime loop
- JSONL формат для эффективного хранения и анализа
- Корреляция событий через correlation_id
- Оптимизированные вызовы для минимального влияния на производительность

### PassiveDataSink (Устаревший)
**Файл:** `src/observability/passive_data_sink.py`

Компонент для пассивного сбора и хранения данных наблюдения. Поддерживается для совместимости, но рекомендуется использовать StructuredLogger для новых реализаций.

**Особенности:**
- Автоматическая ротация логов при достижении максимального размера файла (100MB)
- Потокобезопасная запись данных
- TTL-based очистка старых записей
- Поддержка сжатия и архивирования

**Ротация логов (v2.9):**
```python
def _flush_to_disk(self) -> None:
    """Записать данные на диск с ротацией логов."""
    # Проверяем размер файла перед записью (макс 100MB)
    max_file_size = 100 * 1024 * 1024  # 100MB
    if file_path.exists() and file_path.stat().st_size > max_file_size:
        # Ротируем файл
        timestamp = int(time.time())
        rotated_path = file_path.with_suffix(f".{timestamp}.jsonl")
        file_path.rename(rotated_path)
        logger.info(f"Rotated log file to {rotated_path}")
```

**Конфигурация:**
- `max_file_size`: Максимальный размер файла перед ротацией (100MB по умолчанию)
- `ttl_seconds`: Время жизни записей (автоматическая очистка)
- `compression_enabled`: Включение сжатия данных


## Архитектурные границы

### ✅ Допустимые паттерны

1. **Активное логирование в runtime**
   ```python
   # Runtime loop интегрирует структурированное логирование
   structured_logger.log_tick_start(ticks, queue_size)
   structured_logger.log_event(event)
   structured_logger.log_decision(correlation_id)
   ```

2. **JSONL структурированные данные**
   ```python
   # Логирование в JSONL формате
   {
     "timestamp": 1640000000.0,
     "stage": "event",
     "correlation_id": "abc123",
     "data": {"event_type": "recovery", "intensity": 0.8}
   }
   ```

### ✅ Архитектурные достижения

1. **Четкая активная архитектура**
   - StructuredLogger интегрирован в runtime цикл
   - Активное логирование ключевых стадий обработки
   - Реальный overhead: 690% (измерено 2026-01-22)

2. **Чистая кодовая база**
   - Удален мертвый код (UnifiedObservationAPI, deprecated observation_api.py)
   - Убраны неиспользуемые пассивные компоненты
   - Фокус на работающей функциональности

3. **Правдивая документация**
   - Документация соответствует реальному коду
   - Четкое описание активной архитектуры
   - Нет ложных заявлений о пассивности

## Интеграция

### Runtime интеграция структурированного логгера

StructuredLogger **активно интегрирован** в runtime loop для логирования ключевых этапов:

```python
# runtime/loop.py - активная интеграция
structured_logger = StructuredLogger()  # Создается в начале

# Логирование на каждом тике
structured_logger.log_tick_start(self_state.ticks, queue_size)

# Логирование обработки событий
correlation_id = structured_logger.log_event(event)
structured_logger.log_meaning(event, meaning, correlation_id)
structured_logger.log_decision(correlation_id)

# Логирование действий и feedback
structured_logger.log_action(action_id, correlation_id)
structured_logger.log_feedback(feedback, correlation_id)
```

### Конфигурация и инициализация

```python
from src.observability.structured_logger import StructuredLogger

# Создание логгера с конфигурацией
structured_logger = StructuredLogger(
    log_directory="data/logs",
    enable_console=False,
    enable_file=True
)
```

## Формат данных

### JSONL логи структурированного логирования

Каждая запись представляет собой JSON объект с полной информацией о этапе обработки:

```jsonl
{"timestamp": 1640000000.123, "stage": "tick_start", "tick_number": 1000, "queue_size": 0}
{"timestamp": 1640000000.145, "stage": "event", "correlation_id": "abc123", "event_type": "recovery", "intensity": 0.8}
{"timestamp": 1640000000.156, "stage": "meaning", "correlation_id": "abc123", "significance": 0.9}
{"timestamp": 1640000000.167, "stage": "decision", "correlation_id": "abc123"}
{"timestamp": 1640000000.178, "stage": "action", "correlation_id": "abc123", "action_id": "action_1000_absorb_1640000000178"}
{"timestamp": 1640000000.189, "stage": "feedback", "correlation_id": "abc123", "delay_ticks": 5}
```

### Корреляция событий

Каждое событие получает `correlation_id` для связывания всей цепочки обработки:
- **event** → **meaning** → **decision** → **action** → **feedback**

### Анализ данных

Логи предназначены для внешнего анализа и отладки системы Life.

## Тестирование

### Архитектурные тесты
- **Runtime интеграция**: проверка корректности логирования на каждом тике
- **Формат данных**: валидация JSONL структуры логов
- **Корреляция**: проверка связывания событий по correlation_id
- **Производительность**: измерение влияния логирования на runtime

### Функциональные тесты
- **StructuredLogger**: корректность логирования всех этапов
- **Runtime loop**: работа с активным логированием
- **Data persistence**: сохранение логов в файлы
- **Error handling**: graceful degradation при проблемах I/O

## Мониторинг и поддержка

### Метрики использования
- Количество собранных записей
- Размер хранилища данных
- Время работы observer thread

### Логирование
- DEBUG: детали сбора данных
- INFO: статус операций
- WARNING: проблемы с доступом к файлам
- ERROR: критические ошибки

## Риски и ограничения

### Архитектурные проблемы
- **Активная интеграция**: логирование катастрофически влияет на производительность (690% overhead)
- **Мертвый код**: UnifiedObservationAPI и пассивные компоненты удалены
- **Архитектурный обман**: система признана как активный мониторинг, а не пассивное наблюдение

### Надежность
- **I/O зависимость**: логирование может замедлять работу при проблемах с дисками
- **Объем данных**: JSONL файлы могут расти быстро при высокой активности
- **Error handling**: сбои логирования не должны останавливать runtime

## Будущие улучшения

### Критично (немедленно)
- **Удалить мертвый код**: UnifiedObservationAPI, PassiveDataSink, AsyncDataSink ✅ ВЫПОЛНЕНО
- **Исправить документацию**: привести в соответствие с реальной архитектурой ✅ ВЫПОЛНЕНО
- **Признать активную архитектуру**: перестать лгать о "пассивном наблюдении" ✅ ВЫПОЛНЕНО

### Важно (1-2 недели)
- **Оптимизация производительности**: минимизировать влияние логирования на runtime
- **Асинхронное логирование**: буферизация для снижения I/O блокировок
- **Ротация логов**: управление размером и количеством файлов

### Желательно (месяц)
- **Анализ логов**: инструменты для анализа собранных данных
- **Метрики производительности**: статистика влияния на runtime
- **Конфигурация логирования**: уровни детализации и фильтры

---

## Ссылки

- [Отчет скептика: Архитектурный обман observability](reviews/skeptic_task_1769036620_20260122.md)
- [CHANGELOG: История изменений](../../CHANGELOG.md)