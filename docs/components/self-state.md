# 03_SELF_STATE.md — Внутреннее состояние

## Назначение
Self-State — это "тело" системы. Это структура данных, которая хранит все физические и ментальные параметры Life.
Состояние первично: оно существует даже тогда, когда ничего не происходит.

## Архитектурные особенности

### Потокобезопасность (v2.4)
SelfState обеспечивает **потокобезопасность** между API и runtime потоками:

- **Синхронизация через RLock:** Все изменения состояния защищены `_api_lock` для предотвращения race conditions
- **Консистентность данных:** API всегда читает согласованное состояние без частичных изменений
- **Минимальные накладные расходы:** Использование RLock предотвращает deadlock при рекурсивных вызовах
- **Исключения из блокировки:** Transient поля (`activated_memory`, `last_pattern`) не блокируют изменения

**Защищенные методы:**
- `__setattr__()` - все изменения полей состояния
- `apply_delta()` - применение относительных изменений

## Текущий статус
✅ **Реализован** (v2.5)
*   Файл: [`src/state/self_state.py`](../../src/state/self_state.py)
*   Реализованы базовые параметры (Vital Parameters).
*   **v2.0:** Добавлена поддержка архивной памяти (ArchiveMemory), параметры Learning и Adaptation.
*   **v2.1:** Добавлена валидация полей, защита неизменяемых полей, безопасные методы обновления, логирование изменений, методы is_active() и is_viable().
*   **v2.2:** Добавлены алиасы времени (subjective_age, physical_age), расширенная валидация коэффициентов субъективного времени, улучшенная сериализация snapshots.
*   **v2.3:** Добавлены коэффициенты для учета энергии и сглаживания интенсивности в субъективном времени, интеграция субъективного времени в runtime loop.
*   **v2.4:** Добавлена потокобезопасность между API и runtime потоками через RLock синхронизацию, исправлена логика is_active() для соответствия тестам.
*   **v2.5:** Добавлена атомарная замена снапшотов для гарантии консистентности, улучшена потокобезопасность через RWLock в SnapshotReader.

## Структура состояния

Состояние представляет собой dataclass `SelfState`, который содержит следующие группы параметров:

### 1. Identity (Идентичность)
Неизменяемые параметры, определяющие уникальность жизни.
*   `life_id` (str): Уникальный UUID.
*   `birth_timestamp` (float): Время рождения (Unix timestamp).

### 2. Temporal (Время)
Параметры, отражающие течение времени.
*   `age` (float): Возраст в секундах (физическое время).
*   `ticks` (int): Количество прожитых тактов.
*   `subjective_time` (float): Субъективное время в секундах (метрика восприятия времени).

**Алиасы для удобства:**
*   `physical_age` (property): Алиас для `age` (физическое время).
*   `subjective_age` (property): Алиас для `subjective_time` (субъективное время).

### 3. Vital Parameters (Жизненные показатели)
Динамические параметры, определяющие здоровье системы. Диапазон: [0.0, 1.0] или [0.0, 100.0].

| Параметр | Диапазон | Описание | Влияние |
|----------|----------|----------|---------|
| `energy` | 0-100 | Энергия. Тратится на действия и существование. | При 0 только слабость и бессилие. |
| `integrity` | 0-1 | Целостность. Структурная прочность. | Падает от шоков и ошибок. |
| `stability` | 0-1 | Стабильность. Устойчивость к шуму. | Влияет на точность восприятия. |

### 4. Internal Dynamics (Внутренняя динамика)
Накопленные эффекты.
*   `fatigue` (float): Усталость. Растет со временем, снижается при отдыхе.
*   `tension` (float): Напряжение. Растет от стресса.

### 5. Cognitive Layers (Когнитивные слои)
Параметры для хранения результатов обработки.
*   `memory` (Memory): Эпизодическая память значимых событий (активная память, до 50 записей). Является экземпляром класса `Memory` с поддержкой архивации и механизма забывания (v2.0).
*   `archive_memory` (ArchiveMemory): Архивная память для долгосрочного хранения (v2.0).
*   `intelligence` (dict): Результаты обработки информации.
*   `planning` (dict): Потенциальные последовательности событий.

### 6. Event Processing (Обработка событий)
Временные данные для текущего цикла.
*   `recent_events` (list): Список типов последних событий.
*   `last_significance` (float): Значимость последнего обработанного события.
*   `energy_history` (list): История значений энергии.
*   `stability_history` (list): История значений стабильности.
*   `activated_memory` (list): Активированные записи памяти для текущего события (transient, не сохраняется в snapshot).
*   `last_pattern` (str): Последний выбранный паттерн decision (transient, не сохраняется в snapshot).

### 7. Learning & Adaptation (Обучение и адаптация)
Параметры для Learning Engine (Этап 14) и Adaptation Manager (Этап 15).
*   `learning_params` (dict): Параметры для Learning Engine (event_type_sensitivity, significance_thresholds, response_coefficients).
*   `adaptation_params` (dict): Параметры поведения для Adaptation Manager (behavior_sensitivity, behavior_thresholds, behavior_coefficients).
*   `adaptation_history` (list): История адаптаций для обратимости.

### 8. Subjective Time (Субъективное время)
Параметры для модели субъективного времени (метрика восприятия времени).
*   `subjective_time_base_rate` (float): Базовая скорость субъективного времени (по умолчанию 1.0).
*   `subjective_time_rate_min` (float): Минимальная скорость (по умолчанию 0.1).
*   `subjective_time_rate_max` (float): Максимальная скорость (по умолчанию 3.0).
*   `subjective_time_intensity_coeff` (float): Коэффициент влияния интенсивности (по умолчанию 1.0).
*   `subjective_time_stability_coeff` (float): Коэффициент влияния стабильности (по умолчанию 0.5).
*   `subjective_time_energy_coeff` (float): Коэффициент влияния энергии (по умолчанию 0.5).
*   `subjective_time_intensity_smoothing` (float): Коэффициент экспоненциального сглаживания интенсивности (по умолчанию 0.3).
*   `last_event_intensity` (float): Интенсивность последнего события [0..1], используется как сигнал для субъективного времени.

### 9. Control (Управление)
*   `active` (bool): Флаг активности жизни.

## Инварианты

1.  **Необратимость:** `life_id` и `birth_timestamp` никогда не меняются.
2.  **Границы:** Vital параметры жестко ограничены своими диапазонами.
3.  **Бессмертие:** Если любой Vital параметр падает <= 0, флаг `active` становится `False`. Система не останавливается, а начинает болеть и хандрить. Смерти нет, только слабость и бессилие.

## API

### Базовое использование

```python
from state.self_state import create_initial_state, save_snapshot

# Создание нового состояния
state = create_initial_state()

# Доступ к параметрам
print(state.energy)

# Сохранение на диск
save_snapshot(state)
```

### Алиасы времени (v2.2)

SelfState предоставляет удобные алиасы для работы со временем:

```python
state = create_initial_state()

# Алиасы для физического и субъективного времени
physical_time = state.physical_age     # то же, что state.age
subjective_time = state.subjective_age  # то же, что state.subjective_time

# Установка значений через алиасы
state.physical_age = 100.5     # устанавливает state.age = 100.5
state.subjective_age = 80.3    # устанавливает state.subjective_time = 80.3

# Валидация работает одинаково
state.physical_age = -5.0      # ValueError: age must be >= 0.0
state.subjective_age = -1.0    # ValueError: subjective_time must be >= 0.0
```

**Особенности алиасов:**
- Полностью взаимозаменяемы с базовыми полями
- Поддерживают чтение и запись
- Имеют ту же валидацию, что и базовые поля
- Не сериализуются отдельно (это properties, не поля dataclass)

### Валидация и защита (v2.1)

SelfState теперь включает автоматическую валидацию и защиту полей:

**Валидация полей:**
- `energy`: 0.0 <= value <= 100.0
- `integrity`: 0.0 <= value <= 1.0
- `stability`: 0.0 <= value <= 1.0
- `fatigue`, `tension`, `age`: value >= 0.0
- `ticks`: value >= 0
- `subjective_time`: value >= 0.0
- `subjective_time_base_rate`, `subjective_time_rate_min`, `subjective_time_rate_max`: value >= 0.0
- `subjective_time_energy_coeff`, `subjective_time_intensity_smoothing`: value >= 0.0

**Защита неизменяемых полей:**
- `life_id` и `birth_timestamp` защищены от изменения после инициализации
- Попытка изменения вызывает `AttributeError`

```python
state = create_initial_state()

# Валидация работает автоматически
state.energy = 50.0  # OK
state.energy = 150.0  # ValueError: energy must be between 0.0 and 100.0

# Защита неизменяемых полей
state.life_id = "new_id"  # AttributeError: Cannot modify immutable field 'life_id'
```

### Безопасные методы обновления (v2.1)

Рекомендуется использовать безопасные методы для обновления состояния:

```python
state = create_initial_state()

# Обновление отдельных параметров
state.update_energy(75.0)
state.update_integrity(0.8)
state.update_stability(0.9)

# Одновременное обновление нескольких параметров
state.update_vital_params(energy=50.0, integrity=0.7, stability=0.6)

# Сброс к начальным значениям (кроме life_id и birth_timestamp)
state.reset_to_defaults()
```

### Проверка жизнеспособности (v2.1, обновлено v2.4)

```python
state = create_initial_state()

# Проверка активности (система жизнеспособна если vital параметры выше порогов)
is_active = state.is_active()  # True (если energy > 10, integrity > 0.1, stability > 0.1)
assert state.active == is_active  # active обновляется автоматически

# Более строгая проверка жизнеспособности
is_viable = state.is_viable()  # energy > 10, integrity > 0.1, stability > 0.1

# При изменении vital параметров active обновляется автоматически
state.energy = 5.0  # ниже порога 10
assert state.active == False
assert state.is_active() == False
```

### Логирование изменений (v2.1)

SelfState автоматически логирует все изменения полей в append-only лог:

```python
state = create_initial_state()

# Изменения автоматически логируются
state.energy = 50.0
state.integrity = 0.6

# Получение истории изменений
history = state.get_change_history()
for entry in history:
    print(f"{entry['field']}: {entry['old_value']} -> {entry['new_value']}")

# Получение последних N изменений
recent_changes = state.get_change_history(limit=10)

# Отключение логирования (для тестов)
state.disable_logging()
state.energy = 75.0  # Не будет залогировано
state.enable_logging()
```

Лог сохраняется в `data/logs/state_changes.jsonl` в формате JSONL (одна запись на строку).

### Применение дельт

```python
state = create_initial_state()

# Применение дельт с автоматической валидацией
state.apply_delta({"energy": 10.0, "integrity": 0.1, "stability": -0.1})
# energy увеличится на 10, integrity на 0.1, stability уменьшится на 0.1
# Все значения будут автоматически ограничены допустимыми диапазонами
```

### Выбор метода обновления состояния

SelfState предоставляет несколько способов обновления состояния. Важно понимать разницу между ними:

**1. Безопасные методы (`update_energy()`, `update_integrity()`, `update_stability()`):**
- **Назначение:** Явное обновление конкретного vital параметра абсолютным значением
- **Использование:** Рекомендуется для критичных мест кода (например, `action.py`) для улучшения читаемости
- **Особенности:** Это обертки над прямым присваиванием, валидация происходит автоматически через `__setattr__()`
- **Пример:** `state.update_energy(75.0)` - устанавливает energy в 75.0

**2. Метод `apply_delta()`:**
- **Назначение:** Применение относительных изменений (дельт) к нескольким полям одновременно
- **Использование:** Используется в Runtime Loop для применения изменений из различных источников (метаболизм, события, etc.)
- **Особенности:** Работает только с числовыми полями (int, float), валидация происходит автоматически через `__setattr__()`
- **Пример:** `state.apply_delta({"energy": -5.0, "stability": 0.1})` - уменьшает energy на 5, увеличивает stability на 0.1

**3. Прямое присваивание:**
- **Назначение:** Прямое изменение значения поля
- **Использование:** Работает везде, валидация происходит автоматически через `__setattr__()`
- **Особенности:** Валидация и логирование работают так же, как и для безопасных методов
- **Пример:** `state.energy = 75.0` - устанавливает energy в 75.0

**Рекомендации:**
- Для **абсолютных значений** одного параметра: используйте `update_energy()` и аналогичные методы для читаемости
- Для **относительных изменений** нескольких параметров: используйте `apply_delta()`
- Для **простых случаев** в тестах: прямое присваивание допустимо
- **Важно:** Все три способа обеспечивают одинаковую валидацию и логирование через `__setattr__()`

## Изменения в v2.5

### Добавлено:
- ✅ **Атомарная замена снапшотов:** Снапшоты сначала пишутся во временные файлы (.tmp), затем атомарно переименовываются
- ✅ **RWLock в SnapshotReader:** Reader-writer lock для эффективной синхронизации между множественными читателями и писателями
- ✅ **Игнорирование временных файлов:** SnapshotReader пропускает .tmp файлы для гарантии консистентности

### Улучшено:
- ✅ **Консистентность данных:** Читатели никогда не увидят частично записанные снапшоты
- ✅ **Производительность:** RWLock позволяет множественным читателям работать параллельно
- ✅ **Надежность:** Атомарная замена гарантирует консистентность даже при сбоях во время записи

### Технические детали:
- Снапшоты сохраняются как `snapshot_{tick:06d}.tmp`, затем атомарно заменяются на `snapshot_{tick:06d}.json`
- RWLock обеспечивает эксклюзивный доступ для писателей и параллельный для читателей
- SnapshotReader игнорирует все файлы с расширением .tmp

## Изменения в v2.4

### Добавлено:
- ✅ **Потокобезопасность:** Синхронизация всех изменений состояния через `_api_lock` (RLock)
- ✅ **Консистентность:** Предотвращение race conditions между API и runtime потокам
- ✅ **Исключения из блокировки:** Transient поля (`activated_memory`, `last_pattern`) не требуют синхронизации

### Улучшено:
- ✅ **Логика is_active():** Теперь возвращает True только если система жизнеспособна (vital параметры выше порогов)
- ✅ **Производительность:** Минимальные накладные расходы на синхронизацию через RLock
- ✅ **Надежность:** API всегда читает согласованное состояние без частичных изменений

### Технические детали:
- Все изменения полей состояния в `__setattr__` защищены блокировкой
- Метод `apply_delta()` использует атомарные операции с синхронизацией
- Исключения из блокировки: `activated_memory`, `last_pattern` (transient поля)

## Изменения в v2.3

### Добавлено:
- ✅ `subjective_time_energy_coeff` - коэффициент влияния уровня энергии на субъективное время
- ✅ `subjective_time_intensity_smoothing` - коэффициент экспоненциального сглаживания интенсивности событий
- ✅ Интеграция субъективного времени в runtime loop с учетом энергии и сглаженной интенсивности

### Улучшено:
- ✅ Субъективное время теперь учитывает текущий уровень энергии системы
- ✅ Интенсивность событий сглаживается экспоненциально для более реалистичного поведения
- ✅ Улучшенная интеграция с runtime loop без потери производительности

## Изменения в v2.2

### Добавлено:
- ✅ Алиасы времени: `subjective_age` (алиас для `subjective_time`) и `physical_age` (алиас для `age`)
- ✅ Расширенная валидация коэффициентов субъективного времени
- ✅ Улучшенная сериализация snapshots (фикс проблемы с `_api_lock`)

### Улучшено:
- ✅ Функциональность алиасов полностью интегрирована с существующей системой валидации
- ✅ Сериализация snapshots теперь корректно обрабатывает несериализуемые объекты

## Изменения в v2.1

### Добавлено:
- ✅ Автоматическая валидация полей при изменении
- ✅ Защита неизменяемых полей (`life_id`, `birth_timestamp`)
- ✅ Безопасные методы обновления (`update_energy()`, `update_integrity()`, `update_stability()`, `update_vital_params()`)
- ✅ Метод `is_active()` для проверки жизнеспособности
- ✅ Метод `is_viable()` для более строгой проверки
- ✅ Автоматическое логирование изменений состояния (append-only лог)
- ✅ Метод `get_change_history()` для получения истории изменений
- ✅ Оптимизированная сериализация snapshots
- ✅ Автоматическое обновление `active` при изменении vital параметров

### Улучшено:
- ✅ Валидация в `apply_delta()` теперь использует общую систему валидации
- ✅ Сериализация snapshots оптимизирована (меньше размер файла)

## Производительность и ограничения

### Логирование изменений

**Производительность:**
- Логирование использует батчинг для улучшения производительности (по умолчанию буфер 100 записей)
- При частых изменениях состояния логирование может влиять на производительность
- Для оптимизации можно использовать режим "только критичные изменения" (логировать только `energy`, `integrity`, `stability`)

**Ротация логов:**
- Лог-файл автоматически ротируется при достижении 10MB
- Старые логи сохраняются как `state_changes_{timestamp}.jsonl.backup`
- Рекомендуется периодически очищать старые backup-файлы

**Оптимизация логирования:**
```python
state = create_initial_state()

# Режим логирования только критичных изменений (vital параметры)
state.set_log_only_critical(True)
# Теперь логируются только изменения energy, integrity, stability

# Настройка размера буфера (больше = лучше производительность, но больше риск потери данных)
state.set_log_buffer_size(200)  # По умолчанию 100

# Принудительная запись буфера на диск
state._flush_log_buffer()
```

**Разделение ответственности с LogManager:**

`SelfState` выполняет **защитные flush** для предотвращения потери данных, в то время как `LogManager` управляет **политическими flush** в runtime loop:

- **SelfState (защитные flush):**
  - Автоматический flush при переполнении буфера (`_log_change()`)
  - Flush при изменении размера буфера (`set_log_buffer_size()`)
  - Flush при включении логирования (`enable_logging()`)
  - Flush при отключении логирования (`disable_logging()`)

- **LogManager (политические flush):**
  - Периодический flush (раз в N тиков)
  - Flush перед/после снапшота
  - Flush при исключениях
  - Flush при завершении

Защитные flush в `SelfState` вызываются синхронно при изменении конфигурации или переполнении буфера и не зависят от политики `LogManager`. Это обеспечивает надежность системы и предотвращает потерю данных независимо от настроек политики flush. В runtime loop flush управляется через `LogManager`, который использует `self_state._flush_log_buffer()` как callback-функцию.

### Ограничения валидации

**Валидируются только базовые поля:**
- Валидация работает для: `energy`, `integrity`, `stability`, `fatigue`, `tension`, `age`, `ticks`
- **НЕ валидируются:** `learning_params`, `adaptation_params`, `memory`, `planning`, `intelligence` и другие сложные структуры
- Для сложных структур данных (`learning_params`, `adaptation_params`) валидация не выполняется - разработчик должен самостоятельно проверять корректность значений

**Применение дельт:**
- Метод `apply_delta()` работает **только** с числовыми полями (int, float)
- Попытка применить дельту к нечисловому полю (list, dict, str) вызовет `TypeError`
- Это намеренное ограничение для предотвращения некорректных операций

### Trade-offs и компромиссы

**Логирование vs Производительность:**
- Полное логирование всех изменений обеспечивает полную трассируемость, но может замедлить систему при частых изменениях
- Режим "только критичные" улучшает производительность, но теряется информация о некритичных изменениях
- Батчинг улучшает производительность, но увеличивает риск потери данных при сбое (незаписанные записи в буфере)

**Сериализация:**
- Логирование временно отключается во время `save_snapshot()` для производительности
- Изменения состояния, которые могут произойти во время сериализации (например, при конвертации dataclass), не будут залогированы
- Это намеренное решение для оптимизации - изменения во время сериализации обычно незначительны

**Защита полей:**
- Защита неизменяемых полей (`life_id`, `birth_timestamp`) работает только после инициализации объекта
- При загрузке из snapshot через `load_snapshot()` защита работает корректно, так как `_initialized` устанавливается правильно

**Безопасные методы обновления:**
- Методы `update_energy()`, `update_integrity()`, `update_stability()` - это обертки над прямым присваиванием
- Валидация происходит автоматически через `__setattr__()`, поэтому эти методы не добавляют дополнительной функциональности
- Однако их использование рекомендуется для явности и возможного расширения в будущем

### Рекомендации по использованию

1. **Для критичных мест (action.py, runtime loop):** Используйте безопасные методы (`update_energy()`, `update_integrity()`, `update_stability()`)
2. **Для тестов:** Можно использовать прямое присваивание, но рекомендуется отключать логирование через `disable_logging()`
3. **Для высоконагруженных систем:** Используйте `set_log_only_critical(True)` для улучшения производительности
4. **Для отладки:** Используйте полное логирование и `get_change_history()` для анализа изменений состояния
5. **Для production:** Настройте ротацию логов и периодически очищайте старые backup-файлы

### История изменений в get_change_history()

**Фильтрация по life_id:**
- По умолчанию `get_change_history()` фильтрует записи по `life_id` текущего экземпляра
- Если несколько экземпляров Life используют один лог-файл, каждый экземпляр видит только свои изменения
- Для получения всех изменений (включая другие экземпляры) используйте `filter_by_life_id=False`

```python
# Получить только изменения текущего экземпляра (по умолчанию)
history = state.get_change_history()

# Получить все изменения из лога (включая другие экземпляры)
all_history = state.get_change_history(filter_by_life_id=False)
```

## Связанные документы

*   [runtime-loop.md](./runtime-loop.md) — использование состояния в runtime loop
*   [subjective-time.md](./subjective-time.md) — параметры субъективного времени
*   [memory.md](./memory.md) — структура памяти
*   [learning.md](./learning.md) — параметры обучения
*   [adaptation.md](./adaptation.md) — параметры адаптации
