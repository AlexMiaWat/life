# Документация задачи #1: MCP Engine v2 для life-docs

> **Дата создания:** 2026-01-20
> **Сессия:** 20260120_094041
> **Приоритет:** Высокий
> **Статус:** Планирование

## 1. Техническое описание задачи

### 1.1. Обзор

Задача направлена на создание улучшенной версии MCP (Model Context Protocol) engine для работы с документацией проекта Life. Текущая реализация (`mcp_index.py`) использует простой линейный поиск по файлам, что неэффективно для больших объемов документации и не предоставляет гибких возможностей поиска.

### 1.2. Текущее состояние

**Текущая реализация:**
- Файл: `mcp_index.py` + `mcp_index_engine.py` (новый модуль)
- Поиск: использование инвертированного индекса через `IndexEngine` (✅ реализовано)
- Индексация: реализована в модуле `mcp_index_engine.py` (✅ реализовано)
- Кэширование: кэш содержимого файлов (`content_cache`) и инвертированный индекс (`inverted_index`) (✅ реализовано)
- Ранжирование: отсутствует (результаты в порядке обнаружения) (⏳ в планах)
- Режимы поиска: поддержка **AND/OR/PHRASE** через параметр `search_mode` с использованием индекса (✅ реализовано)

**Ограничения текущей реализации:**
1. **Производительность**: O(n*m) где n - количество файлов, m - размер файлов
2. **Точность**: нет учета релевантности, контекста, структуры документации
3. **Гибкость**: нет индекса/ранжирования; режимы AND/OR/PHRASE реализованы, но поиск всё ещё линейный
4. **Масштабируемость**: при росте документации производительность деградирует линейно

### 1.3. Целевое состояние

**MCP Engine v2 должен предоставлять:**
1. **Многословный поиск** с поддержкой режимов AND/OR/PHRASE
2. **Инвертированный индекс** для быстрого поиска по токенам
3. **Кэширование контента** для избежания повторного чтения файлов
4. **Умное ранжирование** на основе:
   - Структуры директорий `docs/` (core > system > concepts > meta > test > archive)
   - Статуса документа (активный/архивный)
   - Частоты вхождения терминов (TF-IDF)
   - Позиции совпадений в документе
5. **Управление индексом** через отдельную MCP-команду для обновления/перестроения
6. **Fallback стратегия** без использования LLM для базового поиска

### 1.4. Подзадачи

1. ✅ **Реализовать `search_mode` (AND/OR/PHRASE)** для `search_docs`/`search_todo` - **ВЫПОЛНЕНО**
2. ✅ **Вынести индексатор в отдельный модуль** (`mcp_index_engine.py`) с кэшем - **ВЫПОЛНЕНО**
3. ⏳ **Добавить умное ранжирование** по структуре и статусу документа - **В ПЛАНАХ**
4. ⏳ **Добавить команду обновления индекса** (`refresh_index`) - **В ПЛАНАХ**
5. ⏳ **Спроектировать fallback стратегию** без LLM - **В ПЛАНАХ**

## 2. Архитектурные решения и обоснование

### 2.1. Архитектура модуля индексации

```
mcp_index_engine.py
├── IndexEngine (класс)
│   ├── content_cache: Dict[str, str]  # Кэш содержимого файлов
│   ├── inverted_index: Dict[str, Set[str]]  # Инвертированный индекс
│   ├── document_metadata: Dict[str, DocumentMeta]  # Метаданные документов
│   └── index_version: int  # Версия индекса для инвалидации
│
├── DocumentMeta (dataclass)
│   ├── path: str
│   ├── category: str  # core/system/concepts/meta/test/archive
│   ├── status: str  # active/archived
│   ├── last_modified: float
│   └── word_count: int
│
└── SearchResult (dataclass)
    ├── path: str
    ├── score: float
    ├── context: str
    └── matches: List[MatchInfo]
```

**Обоснование:**
- **Разделение ответственности**: индексация вынесена в отдельный модуль, что упрощает тестирование и поддержку
- **Кэширование**: `content_cache` избегает повторного чтения файлов при поиске
- **Инвертированный индекс**: обеспечивает O(1) поиск по токенам вместо O(n)
- **Метаданные**: позволяют реализовать умное ранжирование без повторного анализа файлов

### 2.2. Структура ранжирования

**Иерархия важности директорий:**
```
core/          → вес 1.0  (самый важный)
system/        → вес 0.9
concepts/      → вес 0.8
meta/          → вес 0.7
test/          → вес 0.6
archive/       → вес 0.4  (наименее важный)
```

**Формула ранжирования:**
```python
score = (
    category_weight * 0.3 +           # Вес категории (30%)
    status_weight * 0.2 +             # Вес статуса (20%)
    tf_idf_score * 0.3 +              # TF-IDF (30%)
    position_bonus * 0.1 +            # Бонус за позицию (10%)
    match_density * 0.1               # Плотность совпадений (10%)
)
```

**Обоснование:**
- **Категория**: отражает важность документа в структуре проекта
- **Статус**: архивные документы менее релевантны
- **TF-IDF**: стандартная метрика релевантности в информационном поиске
- **Позиция**: совпадения в заголовках/начале документа важнее
- **Плотность**: документы с большим количеством совпадений релевантнее

### 2.3. Режимы поиска

**AND mode (по умолчанию):**
- Все слова запроса должны присутствовать в документе
- Используется для точного поиска

**OR mode:**
- Хотя бы одно слово запроса должно присутствовать
- Используется для широкого поиска

**PHRASE mode:**
- Точная фраза должна присутствовать в документе
- Используется для поиска цитат и точных формулировок

**Обоснование:**
- Различные сценарии использования требуют разных стратегий поиска
- AND для точности, OR для полноты, PHRASE для точных совпадений

### 2.4. Fallback стратегия

**Уровни fallback:**
1. **Инвертированный индекс** (основной метод)
2. **Линейный поиск по кэшу** (если индекс не построен)
3. **Простой grep-подобный поиск** (последний резерв)

**Обоснование:**
- Система должна работать даже при отсутствии индекса
- Постепенная деградация функциональности вместо полного отказа
- Соответствие принципу "без магии" - все механизмы явные

### 2.5. Интеграция с существующей архитектурой

**Соответствие принципам проекта:**
- ✅ **Слоистая архитектура**: модуль индексации - отдельный слой, не влияющий на другие компоненты
- ✅ **Без активного управления**: индекс обновляется по запросу, не автоматически
- ✅ **Явные механизмы**: все алгоритмы прозрачны и документированы
- ✅ **Медленные изменения**: индекс обновляется только при явном запросе

**Зависимости:**
- `mcp_index.py` → использует `mcp_index_engine.py`
- Не влияет на другие компоненты системы
- Изолирован от runtime loop и других активных компонентов

## 3. План реализации (пошаговый)

### Этап 1: Создание модуля индексации (2-3 часа)

**Шаг 1.1:** Создать файл `mcp_index_engine.py`
- Определить класс `IndexEngine`
- Реализовать структуры данных (`DocumentMeta`, `SearchResult`)
- Добавить базовые методы: `__init__`, `_load_document`, `_tokenize`

**Шаг 1.2:** Реализовать индексацию
- Метод `build_index(docs_dir: Path)` - построение индекса
- Метод `_add_to_index(doc_path: str, tokens: List[str])` - добавление в индекс
- Метод `_update_metadata(doc_path: str, content: str)` - обновление метаданных

**Шаг 1.3:** Реализовать кэширование
- Метод `_cache_content(doc_path: str, content: str)` - кэширование содержимого
- Метод `get_cached_content(doc_path: str) -> Optional[str]` - получение из кэша
- Логика инвалидации кэша при изменении файлов

**Критерии завершения:**
- Модуль создан и может построить индекс для `docs/`
- Кэш работает корректно
- Базовые unit-тесты проходят

### Этап 2: Реализация режимов поиска (2-3 часа)

**Шаг 2.1:** Реализовать токенизацию запроса
- Метод `_tokenize_query(query: str) -> List[str]`
- Обработка кавычек для PHRASE mode
- Нормализация (lowercase, удаление пунктуации)

**Шаг 2.2:** Реализовать AND mode
- Метод `_search_and(tokens: List[str]) -> Set[str]`
- Пересечение множеств документов для каждого токена

**Шаг 2.3:** Реализовать OR mode
- Метод `_search_or(tokens: List[str]) -> Set[str]`
- Объединение множеств документов

**Шаг 2.4:** Реализовать PHRASE mode
- Метод `_search_phrase(phrase: str) -> Set[str]`
- Поиск точной фразы в кэшированном контенте

**Шаг 2.5:** Интегрировать режимы в основной метод поиска
- Метод `search(query: str, mode: str = "AND", limit: int = 10) -> List[SearchResult]`
- Параметр `mode` в MCP tool `search_docs` и `search_todo`

**Критерии завершения:**
- Все три режима работают корректно
- Тесты для каждого режима проходят
- Интеграция с MCP tools завершена

### Этап 3: Реализация ранжирования (3-4 часа)

**Шаг 3.1:** Реализовать определение категории документа
- Метод `_get_category(path: str) -> str`
- Маппинг путей к категориям (core/system/concepts/meta/test/archive)
- Веса категорий

**Шаг 3.2:** Реализовать TF-IDF расчет
- Метод `_calculate_tf_idf(token: str, doc_path: str) -> float`
- TF (Term Frequency) - частота термина в документе
- IDF (Inverse Document Frequency) - обратная частота документа

**Шаг 3.3:** Реализовать бонусы за позицию и плотность
- Метод `_calculate_position_bonus(matches: List[MatchInfo]) -> float`
- Метод `_calculate_match_density(matches: List[MatchInfo], doc_length: int) -> float`

**Шаг 3.4:** Реализовать общий расчет score
- Метод `_calculate_score(doc_path: str, matches: List[MatchInfo]) -> float`
- Применение формулы ранжирования
- Сортировка результатов по score

**Критерии завершения:**
- Ранжирование работает корректно
- Результаты соответствуют ожиданиям (core документы выше archive)
- Тесты проверяют корректность ранжирования

### Этап 4: MCP команда обновления индекса (1-2 часа)

**Шаг 4.1:** Добавить метод обновления индекса
- Метод `refresh_index()` в `IndexEngine`
- Проверка изменений файлов (по `last_modified`)
- Инкрементальное обновление (только измененные файлы)

**Шаг 4.2:** Добавить MCP tool
- `@app.tool() async def refresh_index() -> str`
- Вызов `IndexEngine.refresh_index()`
- Возврат статуса обновления

**Шаг 4.3:** Добавить автоматическую проверку при старте
- Опциональная проверка актуальности индекса при первом поиске
- Предупреждение, если индекс устарел

**Критерии завершения:**
- Команда `refresh_index` доступна через MCP
- Инкрементальное обновление работает
- Тесты проверяют обновление индекса

### Этап 5: Fallback стратегия (1-2 часа)

**Шаг 5.1:** Реализовать проверку наличия индекса
- Метод `_is_index_built() -> bool`
- Проверка, что индекс не пустой

**Шаг 5.2:** Реализовать fallback уровни
- Уровень 1: использование индекса (если доступен)
- Уровень 2: линейный поиск по кэшу (если индекс недоступен)
- Уровень 3: простой grep (последний резерв)

**Шаг 5.3:** Интегрировать fallback в методы поиска
- Модификация `search()` для использования fallback
- Логирование используемого уровня

**Критерии завершения:**
- Fallback работает на всех уровнях
- Система не падает при отсутствии индекса
- Тесты проверяют все уровни fallback

### Этап 6: Интеграция и тестирование (2-3 часа)

**Шаг 6.1:** Интегрировать `IndexEngine` в `mcp_index.py`
- Импорт модуля
- Создание экземпляра `IndexEngine`
- Замена текущей реализации `search_docs` и `search_todo`

**Шаг 6.2:** Обновить существующие MCP tools
- Добавить параметр `search_mode` в `search_docs` и `search_todo`
- Сохранить обратную совместимость (по умолчанию AND mode)

**Шаг 6.3:** Написать интеграционные тесты
- Тесты для всех режимов поиска
- Тесты для ранжирования
- Тесты для обновления индекса
- Тесты для fallback

**Шаг 6.4:** Производительность и оптимизация
- Бенчмарки: сравнение старой и новой реализации
- Профилирование горячих точек
- Оптимизация при необходимости

**Критерии завершения:**
- Все тесты проходят
- Производительность улучшена минимум в 2 раза
- Обратная совместимость сохранена

## 4. Потенциальные риски и их митигация

### 4.1. Риск: Производительность индексации

**Описание:** Построение индекса для большого количества файлов может занять много времени.

**Вероятность:** Средняя
**Влияние:** Высокое

**Митигация:**
- Инкрементальное обновление индекса (только измененные файлы)
- Асинхронная индексация в фоне
- Кэширование результатов индексации на диск
- Опциональная ленивая индексация (по требованию)

### 4.2. Риск: Потребление памяти

**Описание:** Кэш содержимого и инвертированный индекс могут занимать много памяти.

**Вероятность:** Средняя
**Влияние:** Среднее

**Митигация:**
- Ограничение размера кэша (LRU eviction)
- Сжатие содержимого в кэше
- Опциональное отключение кэша для больших файлов
- Мониторинг использования памяти

### 4.3. Риск: Неточное ранжирование

**Описание:** Алгоритм ранжирования может не соответствовать ожиданиям пользователей.

**Вероятность:** Высокая
**Влияние:** Среднее

**Митигация:**
- Настраиваемые веса для компонентов score
- A/B тестирование различных формул
- Сбор обратной связи от пользователей
- Возможность ручной настройки весов через конфиг

### 4.4. Риск: Регрессии в существующем функционале

**Описание:** Изменения могут сломать существующие интеграции.

**Вероятность:** Средняя
**Влияние:** Высокое

**Митигация:**
- Сохранение обратной совместимости API
- Полное покрытие тестами перед изменениями
- Постепенная миграция (старый код остается как fallback)
- Тщательное тестирование всех сценариев использования

### 4.5. Риск: Сложность поддержки

**Описание:** Новая архитектура может быть сложной для понимания и поддержки.

**Вероятность:** Средняя
**Влияние:** Среднее

**Митигация:**
- Подробная документация кода
- Комментарии и docstrings для всех методов
- Примеры использования
- ADR документ с обоснованием решений

### 4.6. Риск: Зависимости от внешних библиотек

**Описание:** Использование новых библиотек может создать проблемы с зависимостями.

**Вероятность:** Низкая
**Влияние:** Низкое

**Митигация:**
- Минимизация внешних зависимостей (использовать только стандартную библиотеку где возможно)
- Если нужны библиотеки - только проверенные и стабильные
- Документирование всех зависимостей
- Версионирование зависимостей в `requirements.txt`

## 5. Критерии приемки

### 5.1. Функциональные критерии

✅ **FC1:** Реализованы все три режима поиска (AND/OR/PHRASE)
✅ **FC2:** Индексатор вынесен в отдельный модуль `mcp_index_engine.py`
✅ **FC3:** Реализовано кэширование содержимого файлов
✅ **FC4:** Реализован инвертированный индекс
✅ **FC5:** Реализовано умное ранжирование по структуре и статусу
✅ **FC6:** Добавлена MCP команда `refresh_index` для обновления индекса
✅ **FC7:** Реализована fallback стратегия без LLM
✅ **FC8:** Обратная совместимость сохранена (старые вызовы работают)

### 5.2. Производительность

✅ **PC1:** Поиск по индексу быстрее линейного поиска минимум в 2 раза
✅ **PC2:** Построение индекса для всей документации занимает < 5 секунд
✅ **PC3:** Обновление индекса (инкрементальное) занимает < 1 секунды для типичных изменений

### 5.3. Качество кода

✅ **QC1:** Покрытие тестами >= 80%
✅ **QC2:** Все тесты проходят
✅ **QC3:** Нет критических линтер ошибок
✅ **QC4:** Код соответствует стилю проекта (PEP 8)

### 5.4. Документация

✅ **DC1:** Документированы все публичные методы
✅ **DC2:** Добавлены примеры использования
✅ **DC3:** Обновлена документация MCP tools
✅ **DC4:** Создан ADR документ с обоснованием архитектурных решений

### 5.5. Интеграция

✅ **IC1:** Интеграция с существующим `mcp_index.py` работает корректно
✅ **IC2:** MCP сервер запускается без ошибок
✅ **IC3:** Все существующие тесты MCP проходят
✅ **IC4:** Нет конфликтов с другими компонентами системы

## 6. Связь с другими задачами и компонентами проекта

### 6.1. Связь с другими задачами TODO

**Зависимости:**
- Нет блокирующих зависимостей
- Может выполняться параллельно с другими задачами

**Влияние на другие задачи:**
- Улучшает работу агентов, использующих MCP для поиска документации
- Может быть использован в задачах по улучшению документации (задача #54)

### 6.2. Связь с компонентами системы

**MCP Server (`mcp_index.py`):**
- Прямая интеграция: `mcp_index.py` использует `mcp_index_engine.py`
- Не влияет на другие части MCP сервера

**Документация (`docs/`):**
- Использует структуру `docs/` для ранжирования
- Не изменяет документацию, только читает её

**Индексация (`Index_docs.py`, `Index_code.py`):**
- Не конфликтует с существующими скриптами индексации
- Может использовать результаты `Index_docs.py` для предварительной индексации

**API Server:**
- Не влияет на API сервер
- MCP сервер работает независимо от API

### 6.3. Соответствие архитектуре проекта

**Слоистая архитектура (ADR 002):**
- ✅ Модуль индексации - отдельный слой
- ✅ Не нарушает границы между слоями
- ✅ Минимальные зависимости

**Философия проекта (ADR 001):**
- ✅ Без активного управления: индекс обновляется по запросу
- ✅ Явные механизмы: все алгоритмы прозрачны
- ✅ Медленные изменения: изменения индекса только по запросу

**Технологический стек (ADR 003):**
- ✅ Использует Python 3.10+
- ✅ Минимизирует внешние зависимости
- ✅ Соответствует стилю проекта

### 6.4. Потенциальные улучшения в будущем

**Multi-provider для LLM (из подзадачи):**
- Архитектура позволяет добавить LLM-based поиск как дополнительный провайдер
- Fallback стратегия обеспечивает работу без LLM

**Семантический поиск:**
- Текущая реализация может быть расширена векторным поиском
- Инвертированный индекс может быть дополнен векторным индексом

**Распределенная индексация:**
- Архитектура позволяет масштабировать индексацию на несколько узлов
- Кэш может быть вынесен в Redis или другой distributed cache

## 7. Дополнительные соображения

### 7.1. Тестирование

**Unit тесты:**
- Тесты для `IndexEngine` (все методы)
- Тесты для режимов поиска
- Тесты для ранжирования
- Тесты для fallback стратегии

**Интеграционные тесты:**
- Тесты MCP tools с новым engine
- Тесты производительности
- Тесты на реальной документации

**Тестовые данные:**
- Использовать реальную структуру `docs/`
- Создать тестовые документы для проверки ранжирования
- Тесты на граничных случаях (пустые запросы, очень длинные запросы)

### 7.2. Мониторинг и метрики

**Метрики для отслеживания:**
- Время построения индекса
- Время выполнения поиска
- Размер индекса в памяти
- Частота использования различных режимов поиска
- Эффективность ранжирования (через обратную связь)

### 7.3. Миграция

**План миграции:**
1. Создать новый модуль параллельно со старым кодом
2. Добавить feature flag для переключения между старой и новой реализацией
3. Тестирование новой реализации в production-like окружении
4. Постепенное переключение пользователей
5. Удаление старого кода после полной миграции

**Обратная совместимость:**
- Старый API должен продолжать работать
- Новые параметры опциональны
- Старые вызовы используют значения по умолчанию

## 8. Заключение

Задача #1 представляет собой значительное улучшение MCP engine для работы с документацией проекта Life. Реализация включает современные подходы к информационному поиску (инвертированный индекс, TF-IDF, умное ранжирование) при сохранении простоты и соответствия философии проекта.

Ключевые преимущества:
- Улучшенная производительность поиска
- Более релевантные результаты благодаря ранжированию
- Гибкость через различные режимы поиска
- Масштабируемость через индексацию
- Надежность через fallback стратегию

Задача может быть выполнена за 12-18 часов работы и не имеет блокирующих зависимостей от других задач.

---

**Автор документации:** AI Agent (Project Executor)
**Дата:** 2026-01-20
**Версия:** 1.0
