# Документация задачи #3: Субъективное время (Subjective Time) как “сквозная ось” жизни

> **Дата создания:** 2026-01-20  
> **Сессия:** 20260120_094041  
> **Приоритет:** Высокий  
> **Статус:** Планирование

## 1. Техническое описание задачи

### 1.1. Обзор

Задача вводит в систему Life понятие **субъективного времени** — внутренней шкалы “проживания”, которая может идти быстрее/медленнее физического времени, оставаясь при этом **монотонной** и **детерминированно вычисляемой** из текущего состояния и событий.

Субъективное время должно стать “сквозной осью”:

- в состоянии (`SelfState`) — чтобы разные подсистемы могли ссылаться на одну и ту же шкалу;
- в памяти (`MemoryEntry`) — чтобы события/воспоминания имели привязку не только к физическому timestamp, но и к субъективному;
- в мониторинге (`src/monitor/console.py`) — чтобы наблюдатель видел physical vs subjective time.

### 1.2. Текущее состояние (as-is)

**Физическое время уже есть:**

- `SelfState.age`: возраст в секундах, обновляется в runtime loop через `apply_delta({"age": dt})`.
- `SelfState.ticks`: счетчик тиков.

**Память хранит физическое время:**

- `MemoryEntry.timestamp`: `float` (epoch seconds).

**Мониторинг показывает только physical time:**

- `src/monitor/console.py` выводит `age` и пишет `tick_log.jsonl` с `age`, `energy`, `integrity`, `stability`, `last_significance`.

**Ограничения/дыры в модели времени:**

- Вся история и метрики привязаны только к физическому времени, хотя сама система по смыслу строит субъективный опыт через Meaning Engine.
- Нет “временного измерения” для интенсивности/значимости опыта в терминах внутреннего хода времени.

### 1.3. Целевое состояние (to-be)

1. В `SelfState` добавлены поля субъективного времени:
   - `subjective_time`: накопленное субъективное время (секунды по внутренней шкале).
   - `subjective_age`: (опционально) alias/читаемое поле, если нужно различать “время” и “возраст”; в рамках задачи достаточно одного поля, чтобы не плодить дубли.
   - коэффициенты модуляции (например `subjective_time_alpha`, `subjective_time_min_rate`, `subjective_time_max_rate`) — как параметры модели, но без превращения в оптимизационный контур.

2. В runtime loop интегрирован расчет приращения субъективного времени:
   - при каждом тике вычисляется \(dS\) на основе `dt` и факторов состояния/интенсивности последних событий;
   - гарантия: `subjective_time` **не убывает** и **не скачет отрицательно**.

3. `MemoryEntry` расширен субъективной временной меткой:
   - `subjective_timestamp`: значение `self_state.subjective_time` (или иное согласованное число) в момент записи.
   - Цель: воспоминания можно сортировать/анализировать по субъективной шкале (например “сколько субъективного времени прошло между событиями”), не отменяя физическую шкалу.

4. Мониторинг показывает “physical vs subjective time”:
   - в консоли: `age` и `subjective_time` рядом;
   - в `tick_log.jsonl`: добавлено поле `subjective_time` (и при необходимости — `subjective_rate`).

### 1.4. Подзадачи (как в TODO)

- Добавить в `SelfState` поля субъективного времени и коэффициенты модуляции.
- Интегрировать вычисление субъективного времени в runtime loop (учесть energy/stability + интенсивность последних событий).
- Протянуть субъективный timestamp в `MemoryEntry` и привязать воспоминания к субъективному времени.
- Обновить мониторинг (`src/monitor/console.py`) чтобы показывать physical vs subjective time.
- Добавить тесты: монотонность subjective time, диапазоны, влияние интенсивности/стабильности.

## 2. Архитектурные решения и обоснование

### 2.1. Соответствие архитектуре проекта (ADR 001 / ADR 002)

**ADR 001 (философия)**:

- ✅ **Нет целей и оптимизации**: субъективное время — это измерение/метрика, а не функция, управляющая поведением ради результата.
- ✅ **Медленные изменения**: коэффициенты и влияние факторов должны быть ограничены (rate clamp), чтобы избежать “скачков”.
- ✅ **Без активного управления**: расчет выполняется внутри Runtime Loop как часть течения времени; никакой подсистемы “контроля времени” не вводится.
- ✅ **Нейтральная фиксация**: Memory и Monitor лишь записывают/показывают субъективную метку, не интерпретируя её “как хорошо/плохо”.

**ADR 002 (слои)**:

- ✅ Runtime Loop — единственная точка, где время “движется”. Поэтому расчет субъективного времени выполняется в loop и записывается в `SelfState`.
- ✅ Memory получает субъективный timestamp через данные `SelfState` при создании `MemoryEntry`.
- ✅ Monitor читает `SelfState` и визуализирует.

### 2.2. Модель субъективного времени (минимально достаточная)

Требования к модели:

- **Монотонность**: \(dS \ge 0\).
- **Ограниченность скорости**: \(rate \in [r_{min}, r_{max}]\), чтобы не нарушать принцип “медленные изменения”.
- **Интерпретируемость**: формула прозрачна, параметры явно заданы в `SelfState` или конфиге.
- **Детерминированность**: одинаковое состояние/события → одинаковое приращение.

Рекомендуемая форма:

- \(dS = dt \cdot rate\)
- \(rate = clamp(r_{min}, r_{max}, base + \Delta_{state} + \Delta_{events})\)

Где:

- **base**: 1.0 (по умолчанию субъективное время равно физическому).
- \(\Delta_{state}\): функция от `energy` и `stability` (и/или `fatigue`, `tension`, если концептуально подтверждено).
  - Интуитивно: низкая стабильность/энергия может “замедлять” или “ускорять” субъективное время, но это должно быть явно выбрано и зафиксировано.
- \(\Delta_{events}\): функция от интенсивности/значимости недавних событий.
  - Источник: `event.intensity` и/или `meaning.significance`, плюс агрегирование за тик (например max/avg).

**Выбор “интенсивности последних событий”**:

- В рамках задачи достаточно использовать:
  - `meaning.significance` как субъективно-ориентированную меру;
  - fallback на `event.intensity`, если significance не вычислялась/не положительна.

### 2.3. Где хранить параметры и почему

Варианты:

1. **Поля в `SelfState`** (рекомендуется для первых итераций)
   - Плюсы: сериализуются в snapshot, видны мониторингу и тестам, минимальная инфраструктура.
   - Минусы: рост `SelfState`.

2. Отдельный конфиг/политика (как в задаче #2 про `LifePolicy`)
   - Плюсы: лучше разделение ответственности.
   - Минусы: может быть преждевременно, если еще нет выделенной “политики времени”.

Решение: **начать с полей в `SelfState`**, а позже (после разгрузки `src/runtime/loop.py`) можно вынести расчёт в небольшой модуль/политику (без изменения поведения).

### 2.4. Расширение `MemoryEntry` и обратная совместимость

Добавление `subjective_timestamp` должно быть сделано так, чтобы:

- старые записи (без поля) оставались валидными;
- сериализация/десериализация snapshots не ломалась.

Рекомендуемый контракт:

- `subjective_timestamp: Optional[float] = None` в `MemoryEntry`.
- При записи новых событий: заполняем `subjective_timestamp=self_state.subjective_time`.
- При чтении старых данных: отсутствие поля означает “неизвестно”, а не 0.

### 2.5. Мониторинг: только визуализация, без влияния

`src/monitor/console.py` должен:

- показывать `age` (physical) и `subjective_time` (subjective) рядом;
- логировать эти числа в `tick_log.jsonl`;
- не вводить никакой логики “коррекции времени”.

## 3. План реализации (пошаговый)

### Этап 1: Проектирование полей и контрактов данных

- Определить минимальный набор полей в `SelfState`:
  - `subjective_time: float = 0.0`
  - параметры rate/clamp (например `subjective_time_min_rate`, `subjective_time_max_rate`, `subjective_time_alpha`).
- Определить контракт вычисления `rate` (прозрачная формула + clamp).
- Определить, какое значение записывать в память как `subjective_timestamp` (по умолчанию — `self_state.subjective_time` после инкремента на тик или до; выбрать одно и закрепить).

### Этап 2: Изменения в `SelfState`

- Добавить новые поля в `src/state/self_state.py`.
- Обновить `save_snapshot`/`load_snapshot` совместимо (если требуется явный mapping/игнорирование лишнего).
- Убедиться, что новые поля не ломают `__setattr__`/валидацию (они числовые, но не входят в список валидируемых — решить, нужна ли валидация/границы).

### Этап 3: Интеграция расчёта в Runtime Loop

- В `src/runtime/loop.py` добавить вычисление:
  - собрать “сигнал событий” за тик (например `event_intensity_max` или `meaning_significance_max`);
  - вычислить `rate` и \(dS\);
  - применить `self_state.apply_delta({"subjective_time": dS})`.
- Обеспечить детерминированность и монотонность:
  - clamp rate;
  - `dS = max(0.0, dt * rate)`.

### Этап 4: Протяжка `subjective_timestamp` в `MemoryEntry`

- В `src/memory/memory.py` расширить `MemoryEntry`:
  - `subjective_timestamp: Optional[float] = None`.
- В местах записи памяти (например в loop при `self_state.memory.append(MemoryEntry(...))`):
  - добавлять `subjective_timestamp=self_state.subjective_time`.
- Для Feedback-записей тоже добавлять `subjective_timestamp` (это важно для согласованности “сквозной оси”).

### Этап 5: Обновление мониторинга

- В `src/monitor/console.py`:
  - добавить вывод `subjective_time` (и при желании “rate”).
  - добавить в `tick_log.jsonl` поля:
    - `subjective_time`
    - (опционально) `subjective_rate`
    - (опционально) `subjective_minus_physical = subjective_time - age` для удобства анализа.

### Этап 6: Тестирование

- Unit-тесты на модель субъективного времени:
  - **монотонность**: при любом \(dt \ge 0\) `subjective_time` не уменьшается;
  - **диапазоны**: `rate` всегда в \([r_{min}, r_{max}]\);
  - **влияние интенсивности**: при прочих равных, более высокая significance/intensity изменяет `dS` в ожидаемую сторону;
  - **влияние стабильности/энергии**: при прочих равных, изменение этих полей влияет на `rate` предсказуемо.
- Интеграционные тесты:
  - запись `MemoryEntry` содержит `subjective_timestamp`;
  - мониторинг логирует `subjective_time`.

## 4. Потенциальные риски и их митигация

### 4.1. Риск: “Субъективное время” начнет неявно управлять поведением

- **Вероятность:** Средняя  
- **Влияние:** Высокое (нарушение ADR 001)
- **Митигация:**
  - использовать `subjective_time` только как метрику/ось записи и визуализации;
  - не применять её как параметр выбора паттернов decision в рамках этой задачи;
  - зафиксировать в документации “не используется для оптимизации/целей”.

### 4.2. Риск: Нестабильность/скачки из-за плохой формулы rate

- **Вероятность:** Средняя  
- **Влияние:** Среднее/Высокое
- **Митигация:**
  - clamp \([r_{min}, r_{max}]\) и мягкая зависимость (линейная/сглаженная);
  - ограничить вклад событий агрегированием (max/avg по тику) и/или экспоненциальным сглаживанием;
  - тесты на диапазоны/монотонность.

### 4.3. Риск: Ломается сериализация/совместимость snapshot и памяти

- **Вероятность:** Средняя  
- **Влияние:** Высокое
- **Митигация:**
  - `subjective_timestamp` сделать `Optional` с default;
  - при загрузке старых snapshot корректно обрабатывать отсутствие полей;
  - добавить тест “загрузка старых данных без поля”.

### 4.4. Риск: Расхождение “physical vs subjective” вводит в заблуждение наблюдателя

- **Вероятность:** Низкая/Средняя  
- **Влияние:** Среднее
- **Митигация:**
  - явно показывать оба значения в мониторинге;
  - (опционально) логировать `rate` и \(\Delta = subjective\_time - age\), чтобы было понятно “почему”.

## 5. Критерии приемки

### 5.1. Функциональные критерии

✅ **FC1:** В `SelfState` присутствует поле субъективного времени (например `subjective_time`) и параметры модуляции/ограничения скорости  
✅ **FC2:** Runtime loop обновляет `subjective_time` на каждом тике с учетом состояния и интенсивности/значимости событий  
✅ **FC3:** `MemoryEntry` содержит `subjective_timestamp` (необязательное поле) и новые записи заполняют его  
✅ **FC4:** Мониторинг (`src/monitor/console.py`) показывает physical и subjective time и логирует `subjective_time` в `tick_log.jsonl`  
✅ **FC5:** Добавлены тесты, покрывающие: монотонность, диапазоны rate, влияние интенсивности и stability/energy

### 5.2. Нефункциональные критерии

✅ **NFC1:** Добавление субъективного времени не вводит целей/оптимизационных контуров (соответствие ADR 001)  
✅ **NFC2:** Не нарушены границы слоев: все обновления времени происходят в Runtime Loop, Memory/Monitor только фиксируют данные (соответствие ADR 002)  
✅ **NFC3:** Обратная совместимость snapshots/памяти сохранена (старые данные читаются)

## 6. Связь с другими задачами и компонентами проекта

### 6.1. Связь с задачами из TODO-листа (20260120_094041)

- **Задача #3 (эта):** ввод субъективного времени.
- **Связь с задачей “Разгрузить `src/runtime/loop.py`” (задача #2):**
  - расчет субъективного времени — кандидат на вынос в отдельную “политику времени” после рефакторинга loop, чтобы не увеличивать сложность hot-path.
- **Связь с задачей “Потокобезопасность и консистентность state между API и runtime” (задача #4):**
  - `subjective_time` становится частью состояния, которое API будет читать через immutable snapshot; важно обеспечить консистентность публикации значения вместе с остальными полями.
- **Связь с “Наблюдаемость (observability)” (средний приоритет):**
  - `subjective_time` и `subjective_rate` — естественные метрики для логов/трассировки.

### 6.2. Компоненты, которых касается задача

- `src/state/self_state.py` — добавление полей субъективного времени, snapshot-совместимость.
- `src/runtime/loop.py` — расчет и обновление субъективного времени.
- `src/memory/memory.py` — расширение `MemoryEntry` новым полем.
- `src/monitor/console.py` — вывод/логирование physical vs subjective time.
- Тесты: `src/test/` — новые unit/integration тесты для инвариантов времени.

### 6.3. Согласование с концепцией

- ✅ Субъективное время продолжает линию “Meaning Engine переводит факты в опыт”, но остается **измерением**, а не управлением.
- ✅ Не добавляет “смерть/цели/планирование” и не меняет архитектурные границы.
- ✅ Делает историю системы богаче: память и наблюдение получают вторую ось времени для анализа без вмешательства.

---

**Автор документации:** AI Agent (Project Executor)  
**Дата:** 2026-01-20  
**Версия:** 1.0

