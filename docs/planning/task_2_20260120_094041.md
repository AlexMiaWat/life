# Документация задачи #2: Разгрузить `src/runtime/loop.py` (менеджеры + политика + hot-path)

> **Дата создания:** 2026-01-20
> **Сессия:** 20260120_094041
> **Приоритет:** Высокий
> **Статус:** Планирование

## 1. Техническое описание задачи

### 1.1. Обзор

Задача направлена на снижение сложности и “скрытых” затрат в runtime hot-path за счет выноса отдельных ответственностей из `src/runtime/loop.py` в специализированные компоненты:

- `SnapshotManager`: управление снапшотами (периодичность, формат, ошибки, изоляция I/O).
- `LogManager`: управление логированием/буферизацией и политикой сброса буфера, чтобы **не вызывать** `SelfState._flush_log_buffer()` на каждом тике.
- `LifePolicy`: единая политика “weakness/penalties” (пороги, коэффициенты, конфигурируемость, тестируемость).
- Удаление `print()` из hot-path runtime в пользу `logger` с уровнями, которые **выключены по умолчанию**.
- Добавление unit-тестов, проверяющих корректность делегирования и отсутствие регрессий поведения.

### 1.2. Текущее состояние (as-is)

**Файл:** `src/runtime/loop.py`

Наблюдаемые проблемы:

1. **Смешение обязанностей**
   - В одном месте находятся: оркестрация слоев, обработка событий, Learning/Adaptation, архивация/decay памяти, “weakness penalties”, мониторинг, снапшоты, обработка исключений, регистрация feedback-действий.

2. **Скрытые расходы в hot-path**
   - В `finally` вызывается `self_state._flush_log_buffer()` **на каждом тике**. При активном логировании `SelfState` это влечет регулярный I/O и снижает стабильность интервала тика.
   - В hot-path присутствует много `print()` (в том числе при каждом событии/архивации/штрафах слабости), что увеличивает задержки и шум в выводе.

3. **Политика “слабости” размазана и нет конфигурации**
   - Порог `weakness_threshold = 0.05` и коэффициенты штрафов зашиты в цикл.
   - Непрозрачно, как изменять пороги/коэффициенты без редактирования runtime.

4. **Трудно тестировать**
   - Из-за монолитности `run_loop` сложно unit-тестами доказать, что изменения не меняют поведение.

Связанный контекст:
- `SelfState` уже содержит буфер логирования и методы `set_log_buffer_size`, `set_log_only_critical`, `_flush_log_buffer()` (см. `src/state/self_state.py`).
- Мониторинг (`src/monitor/console.py`) делает вывод в консоль и пишет `data/tick_log.jsonl`.

### 1.3. Целевое состояние (to-be)

1. `run_loop` становится **координатором**, который:
   - вызывает компоненты/менеджеры по расписанию (tick-based),
   - применяет изменения к `SelfState`,
   - обеспечивает единый error-handling,
   - сохраняет контракт совместимости (подписи, базовая семантика).

2. Побочные эффекты (I/O) уходят из hot-path:
   - снапшот — через `SnapshotManager` по заданной политике,
   - лог-флаш — через `LogManager` по заданной политике.

3. Политика “weakness/penalties” вынесена в `LifePolicy` и тестируется как чистая логика (без I/O).

4. `print()` удалены из `src/runtime/loop.py` (кроме крайних случаев), заменены на `logger.debug/info/warning/error`.

5. Добавлены unit-тесты:
   - “делегирование” (что loop вызывает менеджеры в нужных местах),
   - “отсутствие регрессий” для ключевых инвариантов (например, что на слабости применяются ожидаемые штрафы; что снапшоты вызываются по периодам; что flush не дергается на каждом тике).

## 2. Архитектурные решения и обоснование

### 2.1. Соответствие общей архитектуре проекта

**ADR 002 (многослойная архитектура)** фиксирует, что Runtime Loop — центральный координатор слоев, но отмечает риск: “Loop становится бутылочным горлышком”. Рефакторинг в менеджеры — прямой ответ на этот риск: мы **не меняем** слоистость, а упрощаем координатор.

Также это соответствует принципам:
- **Разделение ответственности**: оркестрация ≠ политика ≠ I/O.
- **Без активного управления**: политики и менеджеры задают предсказуемые правила, не добавляя оптимизации/целей.

### 2.2. Предлагаемая структура компонентов

Рекомендуемое размещение (в пределах `src/runtime/`):

- `src/runtime/snapshot_manager.py`
  - `SnapshotManager(period_ticks: int, saver: Callable[[SelfState], None])`
  - `should_snapshot(ticks: int) -> bool`
  - `maybe_snapshot(self_state: SelfState) -> bool` (возвращает “сделан ли снапшот”)

- `src/runtime/log_manager.py`
  - `LogManager(flush_policy: FlushPolicy, flush_fn: Callable[[], None])`
  - `maybe_flush(self_state: SelfState, *, phase: Literal["tick", "shutdown"])`
  - поддержка “не flush на каждом тике”, а:
    - по таймеру (например раз в N тиков),
    - на снапшоте,
    - при исключениях,
    - при завершении.

- `src/runtime/life_policy.py`
  - `LifePolicy(weakness_threshold: float, penalty_k: float, stability_multiplier: float, integrity_multiplier: float)`
  - `is_weak(self_state: SelfState) -> bool`
  - `weakness_penalty(dt: float) -> dict[str, float]` (чистая функция по dt/параметрам)

**Обоснование:**
- `SnapshotManager` и `LogManager` локализуют I/O и расписание.
- `LifePolicy` делает поведение явным, меняемым и тестируемым.
- В `run_loop` остается только поток управления и интеграция слоев (как в `docs/components/runtime-loop.md`).

### 2.3. Принцип “не ломаем контракты”

Ограничения, которые должны сохраниться:
- `run_loop(...)` сохраняет сигнатуру и базовое поведение по времени, обработке событий и остановке.
- `save_snapshot(self_state)` остается единым механизмом сериализации (не меняем формат в рамках задачи #2).
- Семантика “active False при vital <= 0” сохраняется (не вводим “смерть”, только состояние слабости/неактивности).

## 3. План реализации (пошаговый)

### Этап 0: Зафиксировать наблюдаемое поведение (до рефакторинга)

- Собрать список “точек ответственности” в `src/runtime/loop.py`:
  - snapshots (каждые `snapshot_period`),
  - flush логов (`SelfState._flush_log_buffer()`),
  - weakness penalties,
  - вывод/логирование (`print()`),
  - обработка исключений.
- Выделить минимальные сценарии для unit-тестов (см. Этап 5).

### Этап 1: Вынести снапшоты в `SnapshotManager`

- Создать `src/runtime/snapshot_manager.py`.
- В `SnapshotManager` инкапсулировать:
  - периодичность (ticks-based),
  - вызов `save_snapshot(self_state)`,
  - обработку исключений (логировать и продолжать, не ронять loop).
- В `run_loop` заменить inline-блок снапшота на вызов менеджера.

### Этап 2: Вынести логирование/буферизацию в `LogManager`

- Создать `src/runtime/log_manager.py`.
- Определить политику flush:
  - **не** дергать flush в `finally` на каждом тике,
  - flush на “границах”: перед/после снапшота, раз в N тиков, при exception, при завершении.
- В `run_loop` заменить `finally: self_state._flush_log_buffer()` на:
  - `log_manager.maybe_flush(..., phase="tick")` (редко),
  - `log_manager.maybe_flush(..., phase="shutdown")` (обязательно).

### Этап 3: Вынести “weakness/penalties” в `LifePolicy`

- Создать `src/runtime/life_policy.py`.
- Перенести параметры:
  - `weakness_threshold`,
  - коэффициенты штрафов (включая множители для stability/integrity).
- Сделать расчет штрафов отдельным методом, возвращающим `deltas` для `apply_delta`.
- В `run_loop` оставить только:
  - `if policy.is_weak(self_state): self_state.apply_delta(policy.weakness_penalty(dt))`

### Этап 4: Убрать `print()` из hot-path runtime

- Заменить `print()` на `logger`:
  - debug для подробных сообщений (очередь событий, “after interpret”),
  - info для важных редких событий (например, “archived_count > 0”),
  - warning/error для ошибок.
- Убедиться, что по умолчанию подробные сообщения не спамят (через уровень логирования).

### Этап 5: Добавить unit-тесты (делегирование + отсутствие регрессий)

Рекомендуемая структура тестов: `src/test/test_runtime_loop_managers.py`.

- **Тест 5.1:** `SnapshotManager` вызывает `save_snapshot` строго по периоду.
- **Тест 5.2:** `LogManager` не вызывает flush каждый тик (например, flush раз в N тиков и при shutdown).
- **Тест 5.3:** `LifePolicy`:
  - `is_weak` на границе порога,
  - корректные дельты penalties как функция от dt,
  - монотонность (при большем dt штраф не меньше по модулю).
- **Тест 5.4:** Интеграционный unit-уровень: `run_loop` делегирует менеджерам (использовать заглушки/spy-объекты).

### Этап 6: Чистка и сверка с документацией

- Обновить `docs/components/runtime-loop.md`, если обнаружено расхождение с реальным поведением (в рамках этой задачи — только если рефакторинг выявит явное несоответствие; без расширения функционала).
- Убедиться, что изменения не ломают существующие тесты и стиль проекта.

## 4. Потенциальные риски и их митигация

### 4.1. Риск: Регрессия поведения из-за рефакторинга

- **Вероятность:** Средняя
- **Влияние:** Высокое
- **Митигация:**
  - unit-тесты на делегирование и расчеты (Этап 5),
  - минимальные изменения логики: перенос кода без изменения формул/порогов,
  - сравнение ключевых побочных эффектов (когда делается snapshot, когда применяется penalty).

### 4.2. Риск: Потеря логов из-за менее частого flush

- **Вероятность:** Средняя
- **Влияние:** Среднее/Высокое (зависит от требований к трассируемости)
- **Митигация:**
  - flush на shutdown обязателен,
  - flush перед снапшотом (как точка консистентности),
  - настраиваемая политика flush (ticks-based / time-based),
  - документировать компромисс “батчинг vs риск потери данных при падении”.

### 4.3. Риск: Сложность конфигурации политики

- **Вероятность:** Низкая
- **Влияние:** Среднее
- **Митигация:**
  - значения по умолчанию совпадают с текущими константами в loop,
  - явная структура параметров в `LifePolicy`,
  - минимальный public API.

### 4.4. Риск: Логирование станет слишком шумным или слишком тихим

- **Вероятность:** Средняя
- **Влияние:** Среднее
- **Митигация:**
  - `logger.debug` для спама, `logger.info` только для редких событий,
  - единообразный префикс/контекст в сообщениях,
  - тесты не зависят от логов.

## 5. Критерии приемки

### 5.1. Функциональные критерии

✅ **FC1:** В `src/runtime/loop.py` больше нет inline-логики снапшотов — используется `SnapshotManager`
✅ **FC2:** В `src/runtime/loop.py` больше нет “flush на каждом тике” — используется `LogManager` с политикой flush
✅ **FC3:** В `src/runtime/loop.py` логика “weakness/penalties” вынесена в `LifePolicy` (единые пороги/коэффициенты)
✅ **FC4:** `print()` удалены из hot-path `run_loop` и заменены на `logger`
✅ **FC5:** Добавлены unit-тесты на делегирование и отсутствие регрессий поведения

### 5.2. Нефункциональные критерии

✅ **NFC1:** Hot-path не выполняет регулярный дисковый I/O на каждом тике (кроме случаев, явно заданных политикой)
✅ **NFC2:** Код `run_loop` читабелен как оркестратор слоев (соответствует ADR 002)
✅ **NFC3:** Все существующие тесты проходят; новые тесты покрывают вынесенные компоненты

## 6. Связь с другими задачами и компонентами проекта

### 6.1. Связь с задачами из TODO-листа (20260120_094041)

- **Задача #2** (эта): “Разгрузить `src/runtime/loop.py`…”
- Связанные/соседние по смыслу:
  - **Наблюдаемость (observability)**: структурированные логи и метрики могут опираться на `LogManager` как на точку расширения.
  - **Производительность (profiling hot-path)**: этот рефакторинг уменьшает накладные расходы и делает профилирование точнее (I/O изолирован).
  - **Потокобезопасность state между API и runtime**: при введении snapshot для API `SnapshotManager` станет естественной точкой синхронизации/атомарной публикации снапшота.

### 6.2. Компоненты, которых касается задача

- `src/runtime/loop.py` — основной объект рефакторинга.
- `src/state/self_state.py` — источник лог-буфера и `save_snapshot`.
- `src/monitor/console.py` — мониторинг/вывод (в идеале не зависеть от `print()` из loop).
- Тесты: новые unit-тесты + проверка существующих runtime/integration тестов.

### 6.3. Согласование с концепцией и принципами

- ✅ **Архитектура**: сохраняем “слоеный пирог” и роль Loop как координатора, уменьшая его связанность и сложность.
- ✅ **Принципы проекта**: без оптимизации/целей; изменения — структурные, не поведенческие.
- ✅ **Зависимости**: новые менеджеры должны зависеть только от минимального API (`SelfState`, `save_snapshot`, `logger`), не тянуть новые внешние библиотеки.

---

**Автор документации:** AI Agent (Project Executor)
**Дата:** 2026-01-20
**Версия:** 1.0
