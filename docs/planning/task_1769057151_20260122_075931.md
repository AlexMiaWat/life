# Задача #1769057151: Критические архитектурные исправления перед следующим этапом

**Идентификатор:** task_1769057151_20260122_075931

**Дата создания:** 2026-01-22

**Статус:** Реализация (после отчета Скептика)

**Приоритет:** Критический

---

## 1. Техническое описание задачи

### 1.1. Цель задачи

Выполнить комплекс критических архитектурных исправлений, необходимых для обеспечения стабильности и поддерживаемости проекта Life перед переходом к следующему этапу развития. Задача включает 8 ключевых направлений исправлений, которые должны быть выполнены последовательно для предотвращения дальнейшего накопления технического долга.

### 1.2. Текущий статус реализации

**Требует полной реализации:**
- Отсутствие traceability для текущей задачи в системе управления проектом
- Экспериментальные компоненты интегрированы в runtime loop без проверок FeatureFlags
- EventGenerator не разделен на независимые компоненты (находится в состоянии частичного рефакторинга)
- SelfState представляет собой God object с 50+ полями без композиции
- Отсутствуют архитектурные контракты между компонентами
- Не проведена оценка рисков экспериментальных компонентов
- Test bloat: 2678 тестов при кодовой базе ~10k строк
- Отсутствуют ADR (Architecture Decision Records) для принятых решений

### 1.3. Объем изменений

**Критические компоненты для исправления:**
- `src/runtime/loop.py` - добавить проверки FeatureFlags для экспериментальных компонентов
- `src/environment/generator.py` - полная декомпозиция EventGenerator
- `src/state/self_state.py` - реорганизация на composition-based подход
- `src/config/feature_flags.py` - расширение и интеграция в runtime
- `docs/adr/` - создание ADR для архитектурных решений
- `src/contracts/` - создание архитектурных контрактов
- `src/test/` - оптимизация тестовой базы

---

## 2. Архитектурные решения и обоснование

### 2.1. Архитектурные принципы

**Принцип 1: Traceability всех задач**
- Каждая задача должна иметь полный план, критерии приемки и статус в системе управления
- Документация должна быть доступна для аудита и анализа
- Изменения должны быть отслеживаемы и обратимы

**Принцип 2: Изоляция экспериментального кода**
- Экспериментальные компоненты должны быть полностью изолированы через FeatureFlags
- Runtime loop должен проверять флаги перед загрузкой экспериментальных компонентов
- Возможность полного отключения экспериментального кода без side effects

**Принцип 3: Композиция вместо наследования**
- SelfState должен быть разделен на независимые компоненты состояния
- Каждый аспект состояния (энергия, память, время) должен быть отдельным классом
- Составление состояния через композицию для лучшей тестируемости

**Принцип 4: Явные архитектурные контракты**
- Все интерфейсы между компонентами должны быть документированы
- Диапазоны значений, обработка ошибок и гарантии должны быть четко определены
- Контракты должны быть тестируемы и enforceable

### 2.2. Решение проблемы EventGenerator

**Текущая проблема:**
```python
class EventGenerator:  # 900+ строк, множественная ответственность
    def generate(self): ...
    def _adapt_intensity(self): ...      # Должен быть отдельный класс
    def _calculate_pattern_modifier(self): ...  # Должен быть отдельный класс
    def _calculate_smoothed_modifier(self): ...  # Должен быть отдельный класс
```

**Целевая архитектура:**
```python
class EventGenerator:  # Только генерация событий
    def __init__(self, intensity_calculator: IntensityCalculator,
                 pattern_analyzer: PatternAnalyzer,
                 smoothing_engine: SmoothingEngine):
        ...

class IntensityCalculator:  # Отдельный компонент расчета интенсивностей
    def calculate(self, event_type: str, context: Context) -> float: ...

class PatternAnalyzer:  # Отдельный компонент анализа паттернов
    def analyze(self, events: List[Event]) -> PatternModifiers: ...

class SmoothingEngine:  # Отдельный компонент сглаживания
    def smooth(self, value: float, history: List[float]) -> float: ...
```

### 2.3. Реорганизация SelfState

**От monolithic к composition-based:**
```python
# Текущий подход (God object)
@dataclass
class SelfState:
    # 50+ полей разных аспектов
    energy: float = 100.0
    subjective_time: float = 0.0
    memory: Optional[Memory] = None
    # ... еще 40+ полей

# Новый подход (composition)
@dataclass
class SelfState:
    energy_state: EnergyState
    time_state: TimeState
    memory_state: MemoryState
    consciousness_state: ConsciousnessState

@dataclass
class EnergyState:
    level: float = 100.0
    recovery_rate: float = 1.0

@dataclass
class TimeState:
    subjective_time: float = 0.0
    base_rate: float = 1.0
    circadian_phase: float = 0.0
```

### 2.4. Feature Flags для экспериментальных компонентов

**Принцип изоляции:**
```python
class RuntimeLoop:
    def __init__(self):
        self.feature_flags = FeatureFlags()

    def initialize_experimental_components(self):
        if self.feature_flags.is_memory_hierarchy_enabled():
            self.memory_hierarchy = MemoryHierarchyManager()
        else:
            self.memory_hierarchy = None

        if self.feature_flags.is_clarity_moments_enabled():
            self.clarity_moments = ClarityMoments()
        else:
            self.clarity_moments = None
```

### 2.5. Архитектурные контракты

**Пример контракта для IntensityCalculator:**
```python
@dataclass
class IntensityContract:
    """Контракт для расчета интенсивности событий"""

    # Диапазоны входных значений
    input_ranges = {
        'base_intensity': (0.0, 1.0),
        'energy': (0.0, 100.0),
        'stability': (0.0, 2.0)
    }

    # Гарантии выходных значений
    output_guarantees = {
        'intensity': (0.1, 3.0),  # Минимум 0.1, максимум 3.0
        'precision': 0.001        # Точность расчета
    }

    # Обработка ошибок
    error_handling = {
        'invalid_input': 'clamp_to_range',
        'calculation_error': 'fallback_to_base_intensity'
    }
```

---

## 3. План реализации (пошаговый)

### Фаза 1: Внедрение traceability и FeatureFlags (1-2 дня)

**Шаг 1.1:** Создание плана задачи и критериев приемки
- Документировать задачу в системе управления
- Определить критерии приемки для всех 8 направлений
- Создать traceability в docs/planning/

**Шаг 1.2:** Интеграция FeatureFlags в runtime loop
- Добавить проверки флагов перед загрузкой экспериментальных компонентов
- Создать fallback-логику для отключенных компонентов
- Протестировать изоляцию экспериментального кода

### Фаза 2: Рефакторинг EventGenerator (3-4 дня)

**Шаг 2.1:** Анализ текущей структуры
- Документировать все ответственности EventGenerator
- Определить границы разделения на компоненты
- Создать интерфейсы для новых компонентов

**Шаг 2.2:** Создание IntensityCalculator
- Выделить всю логику расчета интенсивностей
- Создать архитектурный контракт для компонента
- Интегрировать с EventGenerator через composition

**Шаг 2.3:** Создание PatternAnalyzer
- Выделить логику анализа паттернов событий
- Создать контракт и интерфейс
- Интегрировать в композицию

**Шаг 2.4:** Создание SmoothingEngine
- Выделить логику сглаживания значений
- Определить алгоритмы и контракты
- Финальная интеграция в EventGenerator

### Фаза 3: Реорганизация SelfState (3-4 дня)

**Шаг 3.1:** Анализ полей и ответственностей
- Классифицировать все 50+ полей по аспектам состояния
- Определить группы связанных полей
- Спроектировать новые классы состояния

**Шаг 3.2:** Создание компонентов состояния
- EnergyState: энергия, восстановление, метаболизм
- TimeState: субъективное время, циркадный ритм
- MemoryState: память, архив, эхо
- ConsciousnessState: ясность, сознание, экспериментальные поля

**Шаг 3.3:** Миграция к composition
- Обновить все места использования SelfState
- Создать backward compatibility layer
- Тестирование совместимости

### Фаза 4: Архитектурные контракты (2-3 дня)

**Шаг 4.1:** Анализ интерфейсов компонентов
- Документировать все публичные интерфейсы
- Определить диапазоны значений и гарантии
- Создать обработку ошибок

**Шаг 4.2:** Создание контрактов для ключевых компонентов
- EventGenerator и его субкомпоненты
- SelfState и компоненты состояния
- Runtime loop и экспериментальные компоненты

**Шаг 4.3:** Интеграция контрактов в код
- Добавить проверки контрактов в runtime
- Создать тесты для валидации контрактов
- Документировать контракты

### Фаза 5: Оценка рисков экспериментальных компонентов (2-3 дня)

**Шаг 5.1:** Performance testing
- Измерить baseline производительности
- Протестировать влияние каждого экспериментального компонента
- Создать benchmarks для сравнения

**Шаг 5.2:** Stability analysis
- Тестирование на memory leaks
- Анализ race conditions
- Проверка обработки edge cases

**Шаг 5.3:** Создание отчета по рискам
- Документировать все найденные риски
- Предложить mitigation strategies
- Определить safe defaults для FeatureFlags

### Фаза 6: Оптимизация тестирования (2-3 дня)

**Шаг 6.1:** Анализ текущей тестовой базы
- Классифицировать тесты по типам и ценности
- Выявить избыточные и бесполезные тесты
- Оценить покрытие и maintenance cost

**Шаг 6.2:** Стратегия оптимизации
- Удалить тесты с низкой ценностью
- Консолидировать похожие тесты
- Создать фабрики для тестовых данных

**Шаг 6.3:** Имплементация оптимизаций
- Рефакторинг тестовой базы
- Обновление CI/CD pipelines
- Документация новой стратегии тестирования

### Фаза 7: ADR для архитектурных решений (1-2 дня)

**Шаг 7.1:** Документирование принятых решений
- Создать ADR для каждого ключевого решения
- Документировать альтернативы и обоснования выбора
- Связать ADR с конкретными изменениями кода

**Шаг 7.2:** ADR для будущих решений
- Создать шаблоны для будущих ADR
- Определить процесс принятия архитектурных решений
- Интегрировать ADR в процесс разработки

---

## 4. Потенциальные риски и их митигация

### 4.1. Риски регрессии при рефакторинге

**Риск:** Масштабные изменения могут сломать существующую функциональность
- **Вероятность:** Высокая
- **Влияние:** Сбои в работе системы, потеря данных
- **Митигация:**
  - Поэтапное выполнение с промежуточным тестированием
  - Создание comprehensive test suite перед изменениями
  - Наличие плана отката для каждого этапа

### 4.2. Риски производительности

**Риск:** Новые компоненты и проверки могут замедлить систему
- **Вероятность:** Средняя
- **Влияние:** Увеличение latency, снижение throughput
- **Митигация:**
  - Performance benchmarks на каждом этапе
  - Оптимизация критических путей
  - Graceful degradation при перегрузке

### 4.3. Риски совместимости

**Риск:** Изменения интерфейсов нарушат интеграцию компонентов
- **Вероятность:** Высокая
- **Влияние:** Сбои в работе подсистем
- **Митигация:**
  - Создание compatibility layers
  - Поэтапная миграция с тестированием
  - Документация breaking changes

### 4.4. Риски сложности

**Риск:** Новые компоненты сделают систему сложнее для понимания
- **Вероятность:** Средняя
- **Влияние:** Снижение maintainability
- **Митигация:**
  - Четкая документация всех компонентов
  - Архитектурные контракты
  - Code reviews для всех изменений

---

## 5. Критерии приемки

### 5.1. Функциональные критерии

**Критерий 1:** Traceability внедрена
- ✅ Созданы docs/planning/task_1769057151_*
- ✅ Критерии приемки определены для всех направлений
- ✅ Статус задачи отслеживается в системе управления

**Критерий 2:** FeatureFlags интегрированы
- ✅ Runtime loop проверяет флаги перед загрузкой экспериментальных компонентов
- ✅ Экспериментальный код полностью изолирован
- ✅ Возможность полного отключения без side effects

**Критерий 3:** EventGenerator разделен
- ✅ Создан IntensityCalculator как независимый компонент
- ✅ Создан PatternAnalyzer как независимый компонент
- ✅ Создан SmoothingEngine как независимый компонент
- ✅ EventGenerator использует composition вместо монолитной структуры

**Критерий 4:** SelfState реорганизован
- ✅ Создан EnergyState компонент
- ✅ Создан TimeState компонент
- ✅ Создан MemoryState компонент
- ✅ SelfState использует composition-based подход

**Критерий 5:** Архитектурные контракты созданы
- ✅ Контракты для всех ключевых интерфейсов
- ✅ Диапазоны значений документированы
- ✅ Обработка ошибок определена

**Критерий 6:** Риски оценены
- ✅ Performance testing проведен
- ✅ Stability analysis выполнен
- ✅ Отчет по рискам создан

**Критерий 7:** Тестирование оптимизировано
- ✅ Количество тестов уменьшено минимум на 30%
- ✅ Тестовая база организована по стратегии
- ✅ CI/CD время выполнения тестов оптимизировано

**Критерий 8:** ADR созданы
- ✅ ADR для всех ключевых архитектурных решений
- ✅ Шаблоны для будущих ADR
- ✅ Процесс документирования архитектурных решений

### 5.2. Нефункциональные критерии

**Критерий 9:** Качество кода
- ✅ Все новые компоненты соответствуют SOLID принципам
- ✅ Код покрыт unit и integration тестами
- ✅ Документация обновлена

**Критерий 10:** Производительность
- ✅ Нет деградации производительности >5%
- ✅ Memory leaks отсутствуют
- ✅ Система стабильна при длительной работе

---

## 6. Связь с другими задачами и компонентами проекта

### 6.1. Зависимости от других задач

**Блокирующие задачи:**
- Текущая задача является фундаментом для всех последующих архитектурных изменений
- Должна быть выполнена перед любыми новыми фичами

### 6.2. Влияние на компоненты проекта

**Core компоненты:**
- `src/runtime/loop.py` - интеграция FeatureFlags
- `src/environment/generator.py` - полная декомпозиция
- `src/state/self_state.py` - реорганизация на composition

**Infrastructure:**
- `src/config/feature_flags.py` - расширение функциональности
- `src/contracts/` - новые архитектурные контракты
- `docs/adr/` - новые ADR документы

**Testing:**
- `src/test/` - оптимизация тестовой базы
- CI/CD pipelines - обновление для новых тестов

---

## 7. Ресурсы и сроки

### 7.1. Оценка трудозатрат

- **Фаза 1:** 1-2 дня (traceability и FeatureFlags)
- **Фаза 2:** 3-4 дня (EventGenerator рефакторинг)
- **Фаза 3:** 3-4 дня (SelfState реорганизация)
- **Фаза 4:** 2-3 дня (архитектурные контракты)
- **Фаза 5:** 2-3 дня (оценка рисков)
- **Фаза 6:** 2-3 дня (оптимизация тестирования)
- **Фаза 7:** 1-2 дня (ADR создание)

**Итого:** 14-21 день разработки

### 7.2. Ресурсы

**Команда:**
- 1 ведущий архитектор/разработчик
- 1 QA инженер для тестирования
- 1 технический писатель для документации

**Инфраструктура:**
- Тестовое окружение для каждого этапа
- Профилировщик производительности
- CI/CD для автоматического тестирования

---

## 8. Приложения

### 8.1. Список изменяемых файлов

```
docs/planning/task_1769057151_20260122_075931.md    # План задачи
src/runtime/loop.py                                 # FeatureFlags интеграция
src/environment/generator.py                        # Полная декомпозиция
src/state/self_state.py                             # Composition-based реорганизация
src/config/feature_flags.py                         # Расширение функциональности
src/contracts/                                      # Новые архитектурные контракты
docs/adr/                                           # Architecture Decision Records
src/test/                                           # Оптимизация тестовой базы
```

### 8.2. Новые компоненты

```python
# Новые классы состояния
class EnergyState:
class TimeState:
class MemoryState:
class ConsciousnessState:

# Компоненты EventGenerator
class IntensityCalculator:
class PatternAnalyzer:
class SmoothingEngine:

# Архитектурные контракты
class IntensityContract:
class StateContract:
class GeneratorContract:
```

### 8.3. Метрики успеха

- **Architectural Quality:** Все компоненты соответствуют SOLID
- **Test Efficiency:** Уменьшение количества тестов на 30% при сохранении покрытия
- **Performance:** Не более 5% деградации производительности
- **Maintainability:** Снижение cyclomatic complexity ключевых компонентов
- **Documentation:** 100% покрытие архитектурных решений ADR