# 10.1_ACTIVATION_Memory.md — Активация памяти

## Текущий статус
✅ **Реализован** (v1.0)
*   Файл: [`src/activation/activation.py`](../../src/activation/activation.py)
*   Интегрирован в [`src/state/self_state.py`](../../src/state/self_state.py)
*   Интегрирован в [`src/runtime/loop.py`](../../src/runtime/loop.py)
*   Мониторинг в [`src/monitor/console.py`](../../src/monitor/console.py)

### Описание реализации
Активация памяти происходит после обработки событий в runtime loop. Функция `activate_memory` фильтрует память по совпадению `event_type` и возвращает топ-3 по `meaning_significance`. Результат сохраняется в transient поле `activated_memory` SelfState, которое не сохраняется в snapshot.

#### Пример структуры activated_memory
```python
activated_memory: list[MemoryEntry]  # Transient поле, очищается при load
```

#### Принципы
- Только read-only: Активация не изменяет память, только извлекает релевантные записи.
- Минимальное сходство: Совпадение по `event_type`, сортировка по `meaning_significance`.
- Transient: Активированные воспоминания не сохраняются между сессиями.
- Ограничение: Топ-3 воспоминания для предотвращения перегрузки.

## Концепция
Активация делает память полезной, превращая пассивное хранилище в активный контекст для текущих решений.

## Принципы работы

1.  **Триггер по событию:** Активация происходит после обработки каждого пакета событий.
2.  **Сходство по типу:** Воспоминания активируются если `event_type` совпадает с текущим событием.
3.  **Ранжирование по значимости:** Среди совпадающих выбираются наиболее значимые.
4.  **Ограниченный объём:** Не более 3 воспоминаний для поддержания фокуса.

## Текущая реализация

### Функция activate_memory
Функция [`activate_memory`](../../src/activation/activation.py) реализует минимальную логику активации:
*   Вход: `current_event_type: str`, `memory: List[MemoryEntry]`, `limit: int = 3`
*   Выход: `List[MemoryEntry]` — топ воспоминаний по значимости

### Интеграция в SelfState
Поле `activated_memory` добавлено в [`SelfState`](../../src/state/self_state.py) как transient поле:
*   Не сохраняется в snapshot (исключается в `save_snapshot`)
*   Очищается при загрузке состояния

### Интеграция в Runtime Loop
В [`loop.py`](../../src/runtime/loop.py) после обработки событий:
*   Вызывается `activate_memory` с типом последнего события
*   Результат присваивается `self_state.activated_memory`

### Мониторинг
В [`console.py`](../../src/monitor/console.py) добавлен вывод:
*   Количество активированных воспоминаний
*   Максимальная значимость среди активированных

## Ограничения (Limits)

1.  **Простое сходство:** Только по `event_type`, без сложных ассоциаций.
2.  **Фиксированный лимит:** Топ-3, без динамического регулирования.
3.  **Нет TTL:** Активированные воспоминания остаются до следующей активации.

## Пример использования

```python
from src.activation.activation import activate_memory
from src.memory.memory import MemoryEntry

# Пример активации
memory = [
    MemoryEntry(event_type="decay", meaning_significance=0.8, timestamp=1.0),
    MemoryEntry(event_type="decay", meaning_significance=0.6, timestamp=2.0),
    MemoryEntry(event_type="recovery", meaning_significance=0.9, timestamp=3.0),
]

activated = activate_memory("decay", memory)
print(f"Активировано: {len(activated)}")  # 2
print(f"Топ значимость: {activated[0].meaning_significance}")  # 0.8
```

## Связь с другими модулями

*   **Memory:** Предоставляет данные для активации (см. [`src/memory/`](../../src/memory/)).
*   **Decision:** Может использовать activated_memory как input (будущий этап).
*   **Monitor:** Отображает статус активации (см. [`src/monitor/`](../../src/monitor/)).