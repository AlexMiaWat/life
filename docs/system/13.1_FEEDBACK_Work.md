# 13.1 FEEDBACK Work

## Статус: ✅ Реализовано и протестировано (v1.1)

## Описание

Модуль Feedback фиксирует последствия действий без оценки успешности или неудачи. Feedback наблюдает изменения состояния после выполнения действия и записывает факты для будущего использования (Learning/Adaptation).

**Важно**: См. [12.3_ACTION_FEEDBACK_INTERFACE.md](../archive/12.3_ACTION_FEEDBACK_INTERFACE.md) для жестких границ между Action и Feedback. Action не знает о существовании Feedback, регистрация действий происходит в Runtime Loop.

## Принципы

- **Безоценочность**: Feedback фиксирует факты изменений, не оценивает их как "хорошо" или "плохо"
- **Асинхронность**: Последствия могут проявиться не сразу, требуется задержка для наблюдения
- **Объективность**: Регистрируются только измеримые изменения состояния
- **Независимость**: Feedback не влияет на текущие решения, только записывает данные

## Архитектура интеграции

### Позиция в Runtime Loop

```
Action (12) → [выполнение действия]
    ↓
[задержка 3-10 тиков]
    ↓
Feedback (13) → [наблюдение изменений]
    ↓
[запись в Memory]
```

### Входные данные

Feedback получает:
1. **От Action**: 
   - `action_id` (уникальный идентификатор действия)
   - `action_pattern` (тип паттерна: "dampen", "absorb", "ignore")
   - `timestamp` (время выполнения)
   - `state_before` (снимок состояния до действия)

2. **От Self-State**:
   - `state_after` (текущее состояние для сравнения)
   - Изменения параметров (energy, stability, integrity)

3. **От Environment** (опционально):
   - События, произошедшие после действия (через EventQueue)

### Выходные данные

Feedback записывает:
1. **В Memory**: 
   - Immutable запись FeedbackRecord с полями:
     - `action_id`: ID связанного действия
     - `action_pattern`: Паттерн действия
     - `state_delta`: Изменения состояния (dict)
     - `timestamp`: Время регистрации
     - `delay_ticks`: Количество тиков между действием и наблюдением

2. **В Self-State** (опционально):
   - `pending_feedback`: Список ожидающих наблюдения действий (transient, не сохраняется)

## Структура данных

### PendingAction

```python
@dataclass
class PendingAction:
    action_id: str
    action_pattern: str
    state_before: dict  # {"energy": 50.0, "stability": 0.8, "integrity": 0.9}
    timestamp: float
    check_after_ticks: int  # Случайное значение 3-10
    ticks_waited: int = 0  # Счетчик ожидания
```

### FeedbackRecord

```python
@dataclass
class FeedbackRecord:
    action_id: str
    action_pattern: str
    state_delta: dict  # {"energy": -0.01, "stability": 0.0, "integrity": 0.0}
    timestamp: float
    delay_ticks: int
    associated_events: list[str] = field(default_factory=list)  # Типы событий из Environment
```

**Примечание**: FeedbackRecord может быть расширением MemoryEntry или отдельной структурой, сохраняемой в Memory.

## Механизм работы

### 1. Регистрация действия

**Важно**: Регистрация происходит в Runtime Loop (`loop.py`), а НЕ в модуле Action. Это соответствует принципу "Action does not know Feedback exists" из [12.3_ACTION_FEEDBACK_INTERFACE.md](../archive/12.3_ACTION_FEEDBACK_INTERFACE.md).

После выполнения Action (в `loop.py` после `execute_action()`):
- Сохраняется снимок состояния (`state_before`) с ключами: `energy`, `stability`, `integrity`
  - **Критично**: Снимок должен быть сделан ДО `execute_action()`, так как Action может изменить состояние
- Создается запись `PendingAction` с:
  - `action_id`: `f"action_{self_state.ticks}_{pattern}_{int(time.time()*1000)}"`
  - `action_pattern`: паттерн из Decision (эквивалент `action_type` из интерфейса)
  - `state_before`: снимок состояния (эквивалент `raw_effects` до действия)
  - `timestamp`: текущее время (эквивалент `start_timestamp`)
  - `check_after_ticks`: случайное значение от 3 до 10
- Запись добавляется в список `pending_actions` (хранится в Runtime Loop, не в SelfState)

### 2. Наблюдение последствий

В каждом тике Runtime Loop (после обработки событий, до мониторинга):
- Проверяются все `PendingAction` записи
- Для каждой записи:
  - Увеличивается `ticks_waited`
  - Если `ticks_waited >= check_after_ticks`:
    - Сравнивается `state_before` с текущим состоянием SelfState
    - Вычисляется `state_delta` для ключей: `energy`, `stability`, `integrity`
    - Если изменения превышают порог (любое изменение > 0.001):
      - Собираются связанные события из EventQueue (если есть)
      - Создается `FeedbackRecord`
      - Запись добавляется в Memory как MemoryEntry с `event_type="feedback"`
    - `PendingAction` удаляется из списка
  - Если `ticks_waited > 20`: запись удаляется (потеряна связь)

### 3. Ограничения

- **Максимальная задержка**: Если прошло >20 тиков без проверки, запись удаляется
- **Минимальные изменения**: Если все изменения в `state_delta` < 0.001, запись не создается
- **Один Feedback на Action**: Каждое действие регистрируется только один раз

## Интерфейс реализации

### Модуль: `src/feedback/`

#### Файл: `src/feedback/feedback.py`

```python
from dataclasses import dataclass, field
from typing import List, Dict, Optional
import random
import time
from state.self_state import SelfState
from environment.event_queue import EventQueue

@dataclass
class PendingAction:
    action_id: str
    action_pattern: str
    state_before: Dict[str, float]
    timestamp: float
    check_after_ticks: int
    ticks_waited: int = 0

@dataclass
class FeedbackRecord:
    action_id: str
    action_pattern: str
    state_delta: Dict[str, float]
    timestamp: float
    delay_ticks: int
    associated_events: List[str] = field(default_factory=list)

def register_action(action_id: str, action_pattern: str, 
                   state_before: Dict[str, float], timestamp: float,
                   pending_actions: List[PendingAction]) -> None:
    """
    Регистрирует действие для последующего наблюдения Feedback.
    
    Args:
        action_id: Уникальный идентификатор действия
        action_pattern: Паттерн действия ("dampen", "absorb", "ignore")
        state_before: Снимок состояния до действия
        timestamp: Время выполнения действия
        pending_actions: Список ожидающих действий (изменяется in-place)
    """
    pending = PendingAction(
        action_id=action_id,
        action_pattern=action_pattern,
        state_before=state_before.copy(),
        timestamp=timestamp,
        check_after_ticks=random.randint(3, 10)
    )
    pending_actions.append(pending)

def observe_consequences(self_state: SelfState, 
                        pending_actions: List[PendingAction],
                        event_queue: Optional[EventQueue] = None) -> List[FeedbackRecord]:
    """
    Наблюдает последствия действий и создает Feedback записи.
    
    Args:
        self_state: Текущее состояние Life
        pending_actions: Список ожидающих действий (изменяется in-place)
        event_queue: Очередь событий для сбора связанных событий (опционально)
    
    Returns:
        Список созданных Feedback записей
    """
    feedback_records = []
    to_remove = []
    
    for pending in pending_actions:
        pending.ticks_waited += 1
        
        if pending.ticks_waited >= pending.check_after_ticks:
            # Вычисляем изменения состояния
            state_after = {
                'energy': self_state.energy,
                'stability': self_state.stability,
                'integrity': self_state.integrity
            }
            
            state_delta = {
                k: state_after.get(k, 0) - pending.state_before.get(k, 0)
                for k in ['energy', 'stability', 'integrity']
            }
            
            # Проверяем минимальный порог изменений
            if any(abs(v) > 0.001 for v in state_delta.values()):
                # Собираем связанные события (опционально)
                associated_events = []
                if event_queue and not event_queue.is_empty():
                    # События за последние N тиков (упрощенная версия)
                    # В полной реализации можно отслеживать события по timestamp
                    recent_events = event_queue.pop_all() if not event_queue.is_empty() else []
                    associated_events = [e.type for e in recent_events]
                
                # Создаем Feedback запись
                feedback = FeedbackRecord(
                    action_id=pending.action_id,
                    action_pattern=pending.action_pattern,
                    state_delta=state_delta,
                    timestamp=time.time(),
                    delay_ticks=pending.ticks_waited,
                    associated_events=associated_events
                )
                feedback_records.append(feedback)
            
            to_remove.append(pending)
        elif pending.ticks_waited > 20:
            # Слишком долго ждали, удаляем
            to_remove.append(pending)
    
    # Удаляем обработанные записи
    for pending in to_remove:
        pending_actions.remove(pending)
    
    return feedback_records
```

#### Файл: `src/feedback/__init__.py`

```python
from feedback.feedback import (
    register_action,
    observe_consequences,
    PendingAction,
    FeedbackRecord
)

__all__ = [
    'register_action',
    'observe_consequences',
    'PendingAction',
    'FeedbackRecord'
]
```

## Интеграция в Runtime Loop

### Изменения в `src/runtime/loop.py`:

1. **Импорты** (в начале файла):
```python
from feedback import register_action, observe_consequences, FeedbackRecord
from dataclasses import asdict
```

2. **Инициализация** (в начале функции `run_loop`):
```python
pending_actions = []  # Список ожидающих Feedback действий
```

3. **После execute_action** (строка ~65, ПЕРЕД `execute_action()`):
```python
# КРИТИЧНО: Сохраняем снимок состояния ДО действия
state_before = {
    'energy': self_state.energy,
    'stability': self_state.stability,
    'integrity': self_state.integrity
}

# Выполняем действие (может изменить состояние)
execute_action(pattern, self_state)

# Регистрируем для Feedback (после выполнения)
# Action не знает о Feedback - регистрация происходит в Loop
action_id = f"action_{self_state.ticks}_{pattern}_{int(time.time()*1000)}"
action_timestamp = time.time()
register_action(action_id, pattern, state_before, action_timestamp, pending_actions)
```

**Важно**: 
- `state_before` должен быть сохранен ДО `execute_action()`, так как `execute_action()` может изменить состояние (например, для "dampen")
- Action не знает о Feedback - это соответствует архитектурному принципу из 12.3_ACTION_FEEDBACK_INTERFACE.md

4. **В начале каждого тика** (после обработки событий, перед мониторингом, строка ~73):
```python
# Наблюдаем последствия прошлых действий
feedback_records = observe_consequences(
    self_state, 
    pending_actions, 
    event_queue
)

# Сохраняем Feedback в Memory
for feedback in feedback_records:
    # Используем MemoryEntry для совместимости
    # Feedback данные можно хранить в дополнительном поле или отдельной структуре
    feedback_entry = MemoryEntry(
        event_type="feedback",
        meaning_significance=0.0,  # Feedback не имеет значимости
        timestamp=feedback.timestamp
    )
    self_state.memory.append(feedback_entry)
    # Примечание: для полной реализации может потребоваться расширение MemoryEntry
    # или создание отдельного хранилища для FeedbackRecord
```

## Ограничения (Limits)

См. [concepts/13_FEEDBACK.md](../concepts/13_FEEDBACK.md) и [12.3_ACTION_FEEDBACK_INTERFACE.md](../archive/12.3_ACTION_FEEDBACK_INTERFACE.md) для концептуальных ограничений.

**Критические запреты:**
- ❌ Feedback НЕ содержит флагов `success` или `failure`
- ❌ Feedback НЕ запускает коррекцию поведения
- ❌ Feedback НЕ обучает систему напрямую
- ❌ Feedback НЕ влияет на текущие решения Decision
- ❌ Feedback НЕ интерпретирует `execution_status` (если Action его эмитит)
- ❌ Feedback НЕ нормализует эффекты
- ❌ Feedback НЕ классифицирует исходы

**Feedback только:**
- ✅ Фиксирует факты изменений (raw facts)
- ✅ Связывает изменения с действиями по `action_id`
- ✅ Предоставляет данные для будущего Learning/Adaptation
- ✅ Timestamp и persist записи
- ✅ Коррелирует по `action_id`

**Архитектурные принципы:**
- Action не знает о Feedback (регистрация в Loop)
- Feedback зависит от вывода Action, но не наоборот
- Нет обратных вызовов, сигналов или запросов от Feedback к Action

## Хранение Feedback в Memory

### Вариант 1: Расширение MemoryEntry (рекомендуется для v1.0)

Для минимальной реализации можно использовать существующий `MemoryEntry` с `event_type="feedback"` и хранить `FeedbackRecord` отдельно или сериализовать в JSON:

```python
# В loop.py при сохранении Feedback
feedback_entry = MemoryEntry(
    event_type="feedback",
    meaning_significance=0.0,  # Feedback не имеет значимости
    timestamp=feedback.timestamp
)
self_state.memory.append(feedback_entry)

# FeedbackRecord можно хранить в отдельном словаре или сериализовать
# Для простоты v1.0: хранить только action_id в event_type
# Полные данные FeedbackRecord можно восстановить из pending_actions до удаления
```

**Ограничение v1.0**: Полные данные `FeedbackRecord` (state_delta, delay_ticks, associated_events) теряются после записи в Memory. Для полной реализации нужен вариант 2.

### Вариант 2: Расширение MemoryEntry (для полной реализации)

Расширить `MemoryEntry` для поддержки Feedback данных:

```python
@dataclass
class MemoryEntry:
    event_type: str
    meaning_significance: float
    timestamp: float
    feedback_data: Optional[Dict] = None  # Для Feedback записей (сериализованный FeedbackRecord)
```

Или создать отдельное поле в SelfState:

```python
@dataclass
class SelfState:
    # ... существующие поля ...
    memory: list[MemoryEntry] = field(default_factory=list)
    feedback_memory: list[FeedbackRecord] = field(default_factory=list)  # Отдельное хранилище
```

**Рекомендация для v1.0**: Использовать Вариант 1 (минимальная реализация). Полные данные Feedback можно добавить позже при необходимости для Learning/Adaptation.

## Тестирование и верификация

### Базовые тесты

1. **Регистрация действия**:
   - После `execute_action()` создается `PendingAction`
   - `state_before` корректно сохраняет состояние ДО действия
   - `action_id` уникален

2. **Наблюдение последствий**:
   - После 3-10 тиков создается `FeedbackRecord`
   - `state_delta` корректно вычисляется (после - до)
   - Записи удаляются после обработки

3. **Хранение в Memory**:
   - `FeedbackRecord` сохраняется в Memory
   - Записи не перезаписываются (append-only)
   - Ограничение размера Memory работает (clamp_size=50)

4. **Граничные случаи**:
   - Если прошло >20 тиков без проверки, запись удаляется
   - Если изменения <0.001, запись не создается
   - Если Action не изменил состояние, `state_delta` близок к нулю

### Проверка архитектурной целостности

- ✅ Action не знает о Feedback (нет импортов, нет вызовов)
- ✅ Регистрация происходит только в Runtime Loop
- ✅ Feedback не содержит оценок (success/failure)
- ✅ Feedback не влияет на Decision
- ✅ Feedback только записывает факты

## Следующие шаги

После реализации Feedback:
1. Интеграция в Runtime Loop согласно спецификации
2. Тестирование на реальных сценариях (см. раздел выше)
3. Верификация архитектурной целостности
4. Подготовка к этапу 14 (Learning) — использование Feedback данных

## Связь с будущими этапами

### Learning (14)

Feedback предоставляет данные для Learning:
- `state_delta` показывает, какие изменения произошли после действия
- `action_pattern` связывает изменения с типом действия
- `associated_events` показывает контекст среды

Learning будет анализировать Feedback записи для поиска паттернов, но сам Feedback не выполняет обучение.

### Adaptation (15)

Adaptation может использовать Feedback для медленной перестройки поведения:
- Если определенные `action_pattern` часто приводят к негативным `state_delta`, Adaptation может изменить параметры Decision
- Но сам Feedback не запускает Adaptation — это делает отдельный модуль
