# Экспериментальные возможности системы Life

## Обзор

Этот раздел содержит документацию по экспериментальным возможностям системы Life. Эти возможности расширяют внутренний мир системы без нарушения основной логики существования.

## Многоуровневая система памяти

### Назначение

**Многоуровневая система памяти** - экспериментальная реализация иерархической модели памяти по аналогии с когнитивной психологией человека. Расширяет существующую эпизодическую память дополнительными уровнями: сенсорной, семантической и процедурной памятью.

### Архитектурные принципы

1. **Иерархичность**: Данные постепенно переносятся от нижних уровней к верхним
2. **Опциональность**: Система полностью опциональна и может быть отключена
3. **Изоляция**: Не изменяет существующие интерфейсы компонентов
4. **Консолидация**: Периодический перенос данных между уровнями памяти

### Компоненты

#### MemoryHierarchyManager класс
Расположение: `src/experimental/memory_hierarchy/hierarchy_manager.py`

Основные методы:
- `add_sensory_event()` - добавление события в сенсорный буфер
- `process_sensory_events()` - обработка событий для MeaningEngine
- `consolidate_memory()` - консолидация данных между уровнями
- `get_hierarchy_status()` - получение статуса всей иерархии

#### SensoryBuffer класс
Расположение: `src/experimental/memory_hierarchy/sensory_buffer.py`

Кольцевой буфер для кратковременного хранения сенсорных данных.

#### SemanticMemoryStore класс
Расположение: `src/experimental/memory_hierarchy/semantic_store.py`

Хранилище семантических знаний и концепций.

#### ProceduralMemoryStore класс
Расположение: `src/experimental/memory_hierarchy/procedural_store.py`

Хранилище навыков, автоматизмов и паттернов поведения.

### Уровни памяти

1. **Sensory Memory** (Сенсорная память) - ✅ Реализовано
2. **Episodic Memory** (Эпизодическая память) - Используется существующая
3. **Semantic Memory** (Семантическая память) - ✅ Реализовано
4. **Procedural Memory** (Процедурная память) - ✅ Реализовано

## Clarity Moments - Система моментов ясности

### Назначение

**Моменты ясности** - это особые состояния системы Life, которые возникают при определенных условиях (высокая стабильность и энергия) и временно повышают восприимчивость к событиям внешнего мира.

### Архитектурные принципы

1. **Экспериментальность**: Система полностью опциональна и может быть отключена
2. **Интеграция**: Использует существующие компоненты без изменения интерфейсов
3. **Наблюдаемость**: Все состояния логируются для анализа поведения
4. **Ограниченность**: Моменты ясности имеют фиксированную длительность

### Компоненты

#### ClarityMoments класс
Расположение: `src/experimental/clarity_moments.py`

Основные методы:
- `check_clarity_conditions()` - проверка условий активации
- `activate_clarity_moment()` - активация момента ясности
- `update_clarity_state()` - обновление состояния в тиках
- `deactivate_clarity_moment()` - деактивация момента ясности

#### Новые поля SelfState
```python
clarity_state: bool = False      # Флаг активности момента ясности
clarity_duration: int = 0       # Оставшаяся длительность в тиках
clarity_modifier: float = 1.0   # Модификатор значимости событий
```

### Условия активации

Момент ясности активируется при следующих условиях:
- **Стабильность** > 0.8 (высокая стабильность)
- **Энергия** > 0.7 (достаточный уровень энергии)
- **Clarity не активен** (нет overlapping состояний)
- **Интервал проверки** (>= 10 тиков между проверками)

### Механизм работы

1. **Проверка условий**: Каждые 10 тиков проверяются условия активации
2. **Создание события**: При активации создается событие `clarity_moment`
3. **Усиление восприятия**: MeaningEngine усиливает значимость событий на 1.5x
4. **Ограниченная длительность**: Состояние активно 50 тиков (примерно 5 секунд)
5. **Автоматическая деактивация**: По истечении времени состояние сбрасывается

### Интеграция с компонентами

#### Runtime Loop
- ClarityMoments интегрирован в основной цикл
- Проверка условий происходит после обновления внутренних ритмов
- Создание событий добавляется в EventQueue

#### MeaningEngine
- При appraisal учитывается clarity_modifier
- Значимость событий умножается на модификатор (1.5 при clarity)
- Не влияет на базовую логику оценки

#### SelfState
- Новые поля сохраняются в snapshot
- Валидация через FieldValidator
- Поддержка сериализации/десериализации

### Логирование

Система ClarityMoments логирует:
- Активацию моментов ясности с параметрами состояния
- Деактивацию с итоговой статистикой
- Текущее состояние через StructuredLogger

### Конфигурация

#### Включение/отключение
```python
run_loop(
    # ...
    disable_clarity_moments=False,  # True для отключения
    # ...
)
```

#### Настраиваемые параметры
```python
# В ClarityMoments классе
CLARITY_STABILITY_THRESHOLD = 0.8
CLARITY_ENERGY_THRESHOLD = 0.7
CLARITY_DURATION_TICKS = 50
CLARITY_SIGNIFICANCE_BOOST = 1.5
CLARITY_CHECK_INTERVAL = 10
```

### Тестирование

#### Unit тесты
- `src/test/test_clarity_moments.py` - базовая функциональность
- Проверка условий активации/деактивации
- Тестирование состояний и модификаторов

#### Integration тесты
- `src/test/test_clarity_moments_integration.py` - интеграция с runtime loop
- Тестирование с MeaningEngine
- Проверка создания событий

### Примеры использования

#### Ручное тестирование
```bash
# Запуск с включенными clarity moments
python -c "
from src.runtime.loop import run_loop
from src.state.self_state import SelfState
import threading

state = SelfState()
state.stability = 0.9
state.energy = 0.8

stop_event = threading.Event()
run_loop(state, lambda: None, stop_event=stop_event, disable_clarity_moments=False)
"
```

#### Мониторинг
```python
# Получение статуса clarity
clarity_moments.get_clarity_status(self_state)
# {
#     'active': True,
#     'duration_remaining': 25,
#     'total_events': 3,
#     'modifier': 1.5
# }
```

### Будущие улучшения

1. **Адаптивные пороги**: Динамическая настройка условий активации
2. **Множественные типы clarity**: Разные виды моментов ясности
3. **Влияние на другие компоненты**: Расширение эффектов clarity
4. **Статистика**: Детальный анализ частоты и продолжительности

## Memory Hierarchy System - Многоуровневая система памяти

### Назначение

**Многоуровневая система памяти** - это экспериментальная реализация иерархической модели памяти по аналогии с когнитивной психологией человека. Система включает четыре уровня памяти: сенсорную, эпизодическую, семантическую и процедурную.

### Архитектурные принципы

1. **Иерархичность**: Данные постепенно переносятся от нижних уровней к верхним
2. **Опциональность**: Система полностью опциональна и может быть отключена
3. **Изоляция**: Не изменяет существующие интерфейсы компонентов
4. **Консолидация**: Периодический перенос данных между уровнями памяти

### Компоненты

#### SensoryBuffer класс
Расположение: `src/experimental/memory_hierarchy/sensory_buffer.py`

**Назначение**: Кратковременное хранение сырых сенсорных данных до их обработки MeaningEngine.

**Основные возможности:**
- **Кольцевой буфер** фиксированного размера (256 записей по умолчанию)
- **TTL-based автоматическая очистка** (2 секунды по умолчанию)
- **Интеграция с EventQueue** для прозрачной работы
- **Структурированное логирование** всех операций

**Ключевые методы:**
- `add_event(event)` - добавить событие в буфер
- `get_events_for_processing()` - получить события для обработки
- `peek_events()` - просмотреть события без удаления
- `get_buffer_status()` - получить статистику буфера

#### MemoryHierarchyManager класс
Расположение: `src/experimental/memory_hierarchy/hierarchy_manager.py`

**Назначение**: Центральный менеджер для координации работы между уровнями памяти.

**Основные возможности:**
- **Управление переносом данных** между уровнями памяти
- **Координация консолидации** (sensory → episodic → semantic)
- **Управление procedural learning** из опыта
- **API для запросов** к разным уровням памяти

**Ключевые методы:**
- `add_sensory_event(event)` - добавить событие в сенсорный буфер
- `process_sensory_events()` - обработать события для MeaningEngine
- `consolidate_memory(self_state)` - выполнить консолидацию между уровнями
- `get_hierarchy_status()` - получить статус всей иерархии
- `query_memory(level, **params)` - запрос к конкретному уровню памяти

### Уровни памяти

#### 1. Sensory Memory (Сенсорная память)
- **Длительность**: 1-2 секунды
- **Объем**: Ограниченный кольцевой буфер
- **Функция**: Временное хранение сырых сенсорных данных
- **Очистка**: Автоматическая по TTL

#### 2. Episodic Memory (Эпизодическая память)
- **Длительность**: Минуты/часы
- **Объем**: Неограниченный (с забыванием)
- **Функция**: Хранение личного опыта и событий
- **Интеграция**: Расширение существующей Memory системы

#### 3. Semantic Memory (Семантическая память)
- **Длительность**: Долгосрочная
- **Объем**: Концепции и знания
- **Функция**: Знания и онтология понятий
- **Статус**: Запланировано к реализации

#### 4. Procedural Memory (Процедурная память)
- **Длительность**: Долгосрочная
- **Объем**: Навыки и паттерны
- **Функция**: Автоматизмы поведения
- **Статус**: Запланировано к реализации

### Механизм консолидации

**Консолидация** - процесс переноса данных между уровнями памяти:

1. **Sensory → Episodic**: События с высокой интенсивностью (>0.7) автоматически переносятся в эпизодическую память
2. **Episodic → Semantic**: Повторяющиеся паттерны извлекаются как семантические концепции
3. **Semantic → Procedural**: Знания конвертируются в автоматизированные навыки

**Интервалы консолидации:**
- Sensory → Episodic: При каждом вызове `consolidate_memory()`
- Episodic → Semantic: По достижении порога повторений
- Semantic консолидация: Каждые 60 секунд

### Интеграция с компонентами

#### Runtime Loop
- MemoryHierarchyManager интегрирован в основной цикл
- Добавление событий происходит в каждом тике
- Консолидация памяти вызывается периодически

#### EventQueue
- SensoryBuffer прозрачно интегрируется с EventQueue
- События автоматически попадают в сенсорный буфер
- Обработка событий происходит через стандартный интерфейс

#### SelfState
- Новые поля сохраняются в snapshot
- Валидация через FieldValidator
- Поддержка сериализации/десериализации

```python
# Новые поля SelfState для многоуровневой памяти
sensory_buffer_size: int = 0        # Текущий размер сенсорного буфера
semantic_concepts_count: int = 0    # Количество семантических концепций
procedural_patterns_count: int = 0  # Количество процедурных паттернов
```

### Логирование

Система Memory Hierarchy логирует:
- Добавление событий в сенсорный буфер
- Перенос данных между уровнями
- Статистику консолидации
- Статус всей иерархии памяти

### Конфигурация

#### Включение/отключение
```python
run_loop(
    # ...
    enable_memory_hierarchy=True,  # True для включения экспериментальной памяти
    # ...
)
```

#### Настраиваемые параметры
```python
# В SensoryBuffer классе
DEFAULT_BUFFER_SIZE = 256
DEFAULT_TTL_SECONDS = 2.0
CLEANUP_INTERVAL_SECONDS = 0.5

# В MemoryHierarchyManager классе
SENSORY_TO_EPISODIC_THRESHOLD = 5
EPISODIC_TO_SEMANTIC_THRESHOLD = 10
SEMANTIC_CONSOLIDATION_INTERVAL = 60.0
```

### Тестирование

#### Unit тесты
- `src/test/test_memory_hierarchy.py` - базовая функциональность
- Проверка TTL механизмов и кольцевого буфера
- Тестирование консолидации между уровнями

#### Integration тесты
- `src/test/test_memory_hierarchy_integration.py` - интеграция с runtime loop
- Тестирование с EventQueue и SelfState
- Проверка создания MemoryEntry

### Примеры использования

#### Ручное тестирование
```bash
# Запуск с включенной многоуровневой памятью
python -c "
from src.runtime.loop import run_loop
from src.state.self_state import SelfState
from src.experimental.memory_hierarchy import MemoryHierarchyManager
import threading

state = SelfState()
hierarchy = MemoryHierarchyManager()

stop_event = threading.Event()
run_loop(state, lambda: None, stop_event=stop_event,
         enable_memory_hierarchy=True, memory_hierarchy=hierarchy)
"
```

#### Мониторинг состояния
```python
# Получение статуса иерархии памяти
status = hierarchy.get_hierarchy_status()
print(f"Sensory buffer size: {status['sensory_buffer']['buffer_size']}")
print(f"Transfers sensory→episodic: {status['hierarchy_manager']['transfers_sensory_to_episodic']}")
```

### Будущие улучшения

1. **Semantic Store**: Реализация семантической памяти с онтологией
2. **Procedural Store**: Система навыков и автоматизмов
3. **Advanced Consolidation**: Более сложные алгоритмы переноса данных
4. **Memory Search**: API для поиска по уровням памяти
5. **Performance Optimization**: Оптимизация для больших объемов данных

## Consciousness System - Система сознания

### Назначение

**Система сознания** - экспериментальная реализация модели сознания с уровнями осознанности и метриками. Включает базовую осознанность, саморефлексию и метакогницию.

### Архитектурные принципы

1. **Уровневость**: Иерархическая модель сознания
2. **Метрики**: Количественная оценка уровней сознания
3. **Опциональность**: Полностью отключаемая система
4. **Интеграция**: Использует существующие компоненты

### Уровни сознания

#### 1. Basic Awareness (Базовая осознанность)
- **Описание**: Реактивное восприятие и обработка событий
- **Метрики**: Частота тиков, обработка событий
- **Состояние**: "awake" - базовое рабочее состояние

#### 2. Self-Reflection (Саморефлексия)
- **Описание**: Анализ собственного поведения и состояния
- **Метрики**: Качество анализа, паттерны поведения
- **Статус**: ✅ Реализовано в ConsciousnessEngine

#### 3. Meta-Cognition (Метакогниция)
- **Описание**: Осознание собственных когнитивных процессов
- **Метрики**: Глубина абстрактного мышления
- **Статус**: ✅ Реализовано в ConsciousnessEngine

### Новые поля SelfState

```python
# Сознание
consciousness_level: float = 0.0       # Уровень сознания [0.0-1.0]
current_consciousness_state: str = "awake"  # Текущее состояние сознания
self_reflection_score: float = 0.0     # Оценка саморефлексии [0.0-1.0]
meta_cognition_depth: float = 0.0      # Глубина метакогниции [0.0-1.0]
```

### Компоненты системы сознания

#### ConsciousnessEngine класс
Расположение: `src/experimental/consciousness/engine.py`

Основные методы:
- `calculate_consciousness_level()` - расчет общего уровня сознания
- `assess_self_reflection()` - оценка саморефлексии
- `evaluate_meta_cognition()` - оценка метакогниции
- `determine_consciousness_state()` - определение состояния сознания

#### ConsciousnessMetrics класс
Расположение: `src/experimental/consciousness/metrics.py`

Метрики для количественной оценки сознания.

#### ConsciousnessStates класс
Расположение: `src/experimental/consciousness/states.py`

Управление состояниями сознания и переходами между ними.

### Состояния сознания

#### Основные состояния
- **unconscious** - отсутствие активного сознания
- **dreaming** - сниженное сознание, низкая энергия
- **awake** - базовое бодрствование
- **flow** - состояние потока, высокая эффективность
- **reflective** - рефлексивное состояние, анализ поведения
- **meta** - метакогнитивное состояние, анализ процессов

### Интеграция
- ✅ Интегрировано в runtime loop
- ✅ Обновляет SelfState поля
- ✅ API endpoints для мониторинга
- ✅ Полное логирование операций

## Другие экспериментальные возможности

*В разработке:*
- Internal Rhythms (внутренние ритмы жизни)
- Memory Echo (эхо памяти)
- Silence Awareness (осознание тишины)

## Безопасность и ограничения

- **Опциональность**: Все экспериментальные возможности можно отключить
- **Изоляция**: Не влияют на критическую функциональность
- **Мониторинг**: Полное логирование для анализа поведения
- **Тестирование**: Высокий уровень покрытия тестами
