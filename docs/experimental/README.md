# Экспериментальные возможности системы Life

## Обзор

Этот раздел содержит документацию по экспериментальным возможностям системы Life. Эти возможности расширяют внутренний мир системы без нарушения основной логики существования.

## Многоуровневая система памяти

### Назначение

**Многоуровневая система памяти** - экспериментальная реализация иерархической модели памяти по аналогии с когнитивной психологией человека. Расширяет существующую эпизодическую память дополнительными уровнями: сенсорной, семантической и процедурной памятью.

### Архитектурные принципы

1. **Иерархичность**: Данные постепенно переносятся от нижних уровней к верхним
2. **Опциональность**: Система полностью опциональна и может быть отключена
3. **Изоляция**: Не изменяет существующие интерфейсы компонентов
4. **Консолидация**: Периодический перенос данных между уровнями памяти

### Компоненты

#### MemoryHierarchyManager класс
Расположение: `src/experimental/memory_hierarchy/hierarchy_manager.py`

Основные методы:
- `add_sensory_event()` - добавление события в сенсорный буфер
- `process_sensory_events()` - обработка событий для MeaningEngine
- `consolidate_memory()` - консолидация данных между уровнями
- `get_hierarchy_status()` - получение статуса всей иерархии

#### SensoryBuffer класс
Расположение: `src/experimental/memory_hierarchy/sensory_buffer.py`

Кольцевой буфер для кратковременного хранения сенсорных данных.

#### SemanticMemoryStore класс (v2.0)
Расположение: `src/experimental/memory_hierarchy/semantic_store.py`

Хранилище семантических знаний и концепций с расширенными возможностями анализа.

**Основные возможности (v2.0):**
- **Расширенная статистика**: Полная статистика по концепциям и ассоциациям
- **Анализ концепций**: Методы получения всех концепций и их характеристик
- **Анализ ассоциаций**: Методы получения всех ассоциаций и их статистики
- **Производительность**: Оптимизированные методы для больших объемов данных

**Новые методы (v2.0):**
- `get_all_concepts()` - получить все концепции
- `get_concepts_count()` - получить количество концепций
- `get_concept_statistics()` - подробная статистика по концепциям
- `get_all_associations()` - получить все ассоциации
- `get_associations_count()` - получить количество ассоциаций
- `get_association_statistics()` - подробная статистика по ассоциациям
- `get_full_statistics()` - полная статистика хранилища

#### ProceduralMemoryStore класс
Расположение: `src/experimental/memory_hierarchy/procedural_store.py`

Хранилище навыков, автоматизмов и паттернов поведения.

### Уровни памяти

1. **Sensory Memory** (Сенсорная память) - ✅ Реализовано
2. **Episodic Memory** (Эпизодическая память) - Используется существующая
3. **Semantic Memory** (Семантическая память) - ✅ Реализовано
4. **Procedural Memory** (Процедурная память) - ✅ Реализовано

## Unified Clarity and Consciousness System - Унифицированная система моментов ясности и состояний сознания

### Назначение

**Унифицированная система моментов ясности и состояний сознания** - комплексная экспериментальная реализация расширенных когнитивных состояний системы Life. Интегрирует ClarityMoments, ParallelConsciousnessEngine и MemoryHierarchyManager для создания комплексной системы управления когнитивными состояниями с множественными типами моментов ясности и расширенными состояниями сознания.

### Архитектурные принципы

1. **Унификация**: Единый API для управления всеми аспектами ясности и сознания
2. **Расширенная типизация**: Множественные типы моментов ясности и состояний сознания
3. **Интеграция компонентов**: ClarityMoments ↔ ParallelConsciousnessEngine ↔ MemoryHierarchyManager
4. **Опциональность**: Полностью отключаемая система с гранулярным контролем
5. **Наблюдаемость**: Детальное логирование и метрики для анализа
6. **Эволюционная совместимость**: Не нарушает существующие интерфейсы

### Типы моментов ясности

#### ClarityType Enum
```python
class ClarityType(Enum):
    BASIC = "basic"          # Базовая ясность - повышение восприимчивости
    COGNITIVE = "cognitive"  # Когнитивная ясность - улучшение обработки
    EMOTIONAL = "emotional"  # Эмоциональная ясность - усиление эмпатии
    EXISTENTIAL = "existential"  # Экзистенциальная ясность - глубокие инсайты
```

#### Особенности типов
- **Basic**: Увеличивает восприимчивость к событиям (модификатор 1.5x)
- **Cognitive**: Улучшает обработку информации и принятие решений
- **Emotional**: Усиливает эмоциональный интеллект и эмпатию
- **Existential**: Предоставляет глубокие инсайты и понимание

### Расширенные состояния сознания

#### ConsciousnessState Enum
```python
class ConsciousnessState(Enum):
    # Базовые состояния
    UNCONSCIOUS = "unconscious"
    DREAMING = "dreaming"
    AWAKE = "awake"
    REFLECTIVE = "reflective"

    # Расширенные состояния
    FLOW = "flow"              # Оптимальная производительность
    DEEP_REFLECTION = "deep_reflection"  # Глубокий самоанализ
    META_AWARENESS = "meta_awareness"    # Осознание процессов
    ENLIGHTENMENT = "enlightenment"      # Пиковые состояния
```

#### Характеристики состояний
- **Flow**: Повышенная эффективность, требует стабильности >0.8 и энергии >0.7
- **Deep Reflection**: Самоанализ паттернов, требует self_reflection_score >0.6
- **Meta Awareness**: Осознание когнитивных процессов, требует meta_cognition_depth >0.7
- **Enlightenment**: Пиковые состояния, требует высокой стабильности (>0.9) и метакогниции (>0.8)

### Компоненты системы

#### UnifiedClarityConsciousnessSystem класс
Расположение: `src/experimental/unified_clarity_consciousness.py`

**Центральный компонент системы**:
- Интегрирует все подсистемы (ClarityMoments, ParallelConsciousnessEngine, Memory)
- Управляет переходами между состояниями
- Координирует детекцию моментов ясности
- Предоставляет унифицированный API

**Основные методы**:
- `check_clarity_conditions()` - расширенная проверка условий ясности
- `determine_consciousness_state()` - определение состояния сознания
- `activate_clarity_event()` - активация момента ясности с типом
- `transition_consciousness_state()` - переход между состояниями
- `get_unified_status()` - получение полного статуса системы

#### ClarityConsciousnessManager класс
Расположение: `src/experimental/clarity_consciousness_manager.py`

**Высокоуровневый менеджер**:
- Предоставляет единый API управления
- Управляет конфигурацией системы
- Координирует все компоненты
- Обеспечивает мониторинг и метрики

**Основные возможности**:
- Адаптивные пороги детекции
- Управление состоянием системы
- Интеграция с памятью
- Мониторинг производительности

#### ClarityConsciousnessMonitor класс
Расположение: `src/experimental/clarity_consciousness_monitor.py`

**Система мониторинга**:
- Отслеживание метрик ясности и сознания
- Детекция аномалий и паттернов
- Генерация отчетов о состоянии
- Предупреждения о проблемах

#### ClarityMoments класс (расширенный)
Расположение: `src/experimental/clarity_moments.py`

**Улучшенная система моментов ясности**:
- Поддержка множественных типов ясности
- Адаптивные условия активации
- Интеграция с состояниями сознания
- История моментов ясности

### Новые поля SelfState

```python
# Расширенные поля ясности
clarity_type: Optional[str] = None         # Тип текущего момента ясности
clarity_intensity: float = 0.0            # Интенсивность [0.0-1.0]
clarity_history: List[Dict] = []           # История моментов ясности

# Расширенные поля сознания
consciousness_state_type: str = "awake"   # Расширенный тип состояния
consciousness_state_intensity: float = 0.0  # Интенсивность состояния [0.0-1.0]
state_transition_history: List[Dict] = []  # История переходов

# Дополнительные метрики
neural_activity: float = 0.0              # Нейронная активность [0.0-1.0]
cognitive_load: float = 0.3               # Когнитивная нагрузка [0.0-1.0]
```

### Механизм работы

#### Детекция моментов ясности
1. **Мониторинг условий**: Проверка stability, energy, consciousness_level
2. **Оценка контекста**: Учет текущего состояния сознания и когнитивной нагрузки
3. **Определение типа**: Выбор подходящего типа ясности на основе условий
4. **Активация**: Создание ClarityEvent с соответствующими параметрами
5. **Эффекты**: Применение модификаторов к различным компонентам

#### Переходы состояний сознания
1. **Оценка метрик**: Анализ consciousness_level, stability, energy
2. **Приоритет состояний**: Enlightenment → Meta Awareness → Flow → Deep Reflection
3. **Проверка условий**: Дополнительные требования для расширенных состояний
4. **Плавный переход**: Предотвращение резких изменений состояния
5. **Влияние на компоненты**: Адаптация поведения системы к состоянию

#### Интеграция с памятью
- **Flow/Meta состояния**: Усиление консолидации памяти
- **Moments ясности**: Создание специальных MemoryEntry с повышенной значимостью
- **История состояний**: Сохранение паттернов для анализа

### Конфигурация

#### ClarityConsciousnessConfig
```python
@dataclass
class ClarityConsciousnessConfig:
    # Настройки детекции ясности
    clarity_stability_threshold: float = 0.8
    clarity_energy_threshold: float = 0.7
    clarity_consciousness_threshold: float = 0.6
    clarity_cognitive_load_max: float = 0.7

    # Настройки состояний сознания
    enable_flow_state: bool = True
    enable_deep_reflection: bool = True
    enable_meta_awareness: bool = True
    enable_enlightenment: bool = True

    # Настройки производительности
    clarity_check_interval: float = 1.0
    state_transition_cooldown: float = 5.0
    max_clarity_history_size: int = 100
    max_transition_history_size: int = 50
```

#### Включение/отключение
```python
run_loop(
    # ...
    enable_unified_clarity_system=True,     # Включение унифицированной системы
    clarity_consciousness_config=config,     # Конфигурация системы
    # ...
)
```

### Интеграция с компонентами

#### Runtime Loop
- UnifiedClarityConsciousnessSystem интегрирован в основной цикл
- Проверка условий происходит в каждом тике
- Координация с ParallelConsciousnessEngine

#### MeaningEngine
- Учет типа и интенсивности моментов ясности
- Различные модификаторы для разных типов clarity
- Влияние состояний сознания на оценку значимости

#### MemoryHierarchyManager
- Усиленная консолидация в состояниях flow/meta
- Специальные MemoryEntry для моментов ясности
- Интеграция с сенсорным буфером

#### ParallelConsciousnessEngine
- Синхронизация состояний сознания
- Совместное управление переходами
- Обмен метриками и сигналами

### Логирование и метрики

#### ClarityConsciousnessMetrics
```python
@dataclass
class ClarityConsciousnessMetrics:
    clarity_events_total: int = 0
    clarity_events_by_type: Dict[str, int] = field(default_factory=dict)
    state_transitions_total: int = 0
    state_transitions_by_type: Dict[str, int] = field(default_factory=dict)
    average_clarity_intensity: float = 0.0
    average_consciousness_level: float = 0.0
    memory_consolidation_boosts: int = 0
```

#### StructuredLogger интеграция
- Детальное логирование активаций моментов ясности
- Отслеживание переходов состояний сознания
- Метрики производительности системы
- Предупреждения о потенциальных проблемах

### Тестирование

#### Unit тесты
- `src/test/test_unified_clarity_consciousness.py` - базовая функциональность
- `src/test/test_clarity_consciousness_manager.py` - менеджер системы
- `src/test/test_clarity_types.py` - типы данных и перечисления
- Проверка условий активации различных типов ясности
- Тестирование переходов между состояниями сознания

#### Integration тесты
- `src/test/test_clarity_consciousness_integration.py` - полная интеграция
- Тестирование с MemoryHierarchyManager
- Проверка влияния на MeaningEngine и принятие решений
- Валидация сохранения состояния в SelfState

#### Smoke тесты
- `src/test/test_smoke_clarity_consciousness.py` - быстрая проверка
- Проверка базовой работоспособности
- Тестирование конфигурационных опций

### Примеры использования

#### Базовое использование
```python
from src.experimental.unified_clarity_consciousness import UnifiedClarityConsciousnessSystem
from src.experimental.clarity_consciousness_manager import ClarityConsciousnessManager

# Создание системы
config = ClarityConsciousnessConfig()
manager = ClarityConsciousnessManager(config)
system = UnifiedClarityConsciousnessSystem(manager=manager)

# Проверка условий в runtime loop
status = system.check_clarity_conditions(self_state)
if status['should_activate']:
    system.activate_clarity_event(
        clarity_type=ClarityType.COGNITIVE,
        intensity=0.8,
        self_state=self_state
    )
```

#### Мониторинг состояния
```python
# Получение полного статуса системы
status = manager.get_unified_status()
print(f"Текущий тип ясности: {status['current_clarity_type']}")
print(f"Состояние сознания: {status['consciousness_state']}")
print(f"Интенсивность: {status['clarity_intensity']:.2f}")

# Метрики производительности
metrics = manager.get_metrics()
print(f"Всего моментов ясности: {metrics.clarity_events_total}")
print(f"Переходов состояний: {metrics.state_transitions_total}")
```

#### Ручное тестирование
```bash
# Запуск с унифицированной системой ясности
python -c "
from src.runtime.loop import run_loop
from src.state.self_state import SelfState
from src.experimental.clarity_consciousness_manager import ClarityConsciousnessManager
import threading

state = SelfState()
state.stability = 0.9
state.energy = 0.8
state.consciousness_level = 0.7

manager = ClarityConsciousnessManager()
stop_event = threading.Event()

run_loop(
    state,
    lambda: None,
    stop_event=stop_event,
    enable_unified_clarity_system=True,
    clarity_consciousness_manager=manager
)
"
```

### Будущие улучшения

1. **Адаптивные алгоритмы**: Машинное обучение для оптимизации условий активации
2. **Дополнительные типы ясности**: Нейронная, социальная, творческая ясность
3. **Расширенные состояния**: Медитация, творческий поток, эмпатическое резонанс
4. **Интеграция с обучением**: Моменты ясности влияют на адаптацию системы
5. **Внешние триггеры**: Возможность активации извне через API
6. **Анализ паттернов**: Статистический анализ эффективности состояний
7. **Персонализация**: Адаптация под индивидуальные паттерны поведения

## Clarity Moments - Система моментов ясности (Legacy)

### Назначение

**Моменты ясности** - это особые состояния системы Life, которые возникают при определенных условиях (высокая стабильность и энергия) и временно повышают восприимчивость к событиям внешнего мира.

*Примечание: Это устаревшая реализация. Рекомендуется использовать UnifiedClarityConsciousnessSystem для новых проектов.*

### Архитектурные принципы

1. **Экспериментальность**: Система полностью опциональна и может быть отключена
2. **Интеграция**: Использует существующие компоненты без изменения интерфейсов
3. **Наблюдаемость**: Все состояния логируются для анализа поведения
4. **Ограниченность**: Моменты ясности имеют фиксированную длительность

### Компоненты

#### ClarityMoments класс
Расположение: `src/experimental/clarity_moments.py`

Основные методы:
- `check_clarity_conditions()` - проверка условий активации
- `activate_clarity_moment()` - активация момента ясности
- `update_clarity_state()` - обновление состояния в тиках
- `deactivate_clarity_moment()` - деактивация момента ясности

#### Новые поля SelfState
```python
clarity_state: bool = False      # Флаг активности момента ясности
clarity_duration: int = 0       # Оставшаяся длительность в тиках
clarity_modifier: float = 1.0   # Модификатор значимости событий
```

### Условия активации

Момент ясности активируется при следующих условиях:
- **Стабильность** > 0.8 (высокая стабильность)
- **Энергия** > 0.7 (достаточный уровень энергии)
- **Clarity не активен** (нет overlapping состояний)
- **Интервал проверки** (>= 10 тиков между проверками)

### Механизм работы

1. **Проверка условий**: Каждые 10 тиков проверяются условия активации
2. **Создание события**: При активации создается событие `clarity_moment`
3. **Усиление восприятия**: MeaningEngine усиливает значимость событий на 1.5x
4. **Ограниченная длительность**: Состояние активно 50 тиков (примерно 5 секунд)
5. **Автоматическая деактивация**: По истечении времени состояние сбрасывается

### Интеграция с компонентами

#### Runtime Loop
- ClarityMoments интегрирован в основной цикл
- Проверка условий происходит после обновления внутренних ритмов
- Создание событий добавляется в EventQueue

#### MeaningEngine
- При appraisal учитывается clarity_modifier
- Значимость событий умножается на модификатор (1.5 при clarity)
- Не влияет на базовую логику оценки

#### SelfState
- Новые поля сохраняются в snapshot
- Валидация через FieldValidator
- Поддержка сериализации/десериализации

### Логирование

Система ClarityMoments логирует:
- Активацию моментов ясности с параметрами состояния
- Деактивацию с итоговой статистикой
- Текущее состояние через StructuredLogger

### Конфигурация

#### Включение/отключение
```python
run_loop(
    # ...
    disable_clarity_moments=False,  # True для отключения
    # ...
)
```

#### Настраиваемые параметры
```python
# В ClarityMoments классе
CLARITY_STABILITY_THRESHOLD = 0.8
CLARITY_ENERGY_THRESHOLD = 0.7
CLARITY_DURATION_TICKS = 50
CLARITY_SIGNIFICANCE_BOOST = 1.5
CLARITY_CHECK_INTERVAL = 10
```

### Тестирование

#### Unit тесты
- `src/test/test_clarity_moments.py` - базовая функциональность
- Проверка условий активации/деактивации
- Тестирование состояний и модификаторов

#### Integration тесты
- `src/test/test_clarity_moments_integration.py` - интеграция с runtime loop
- Тестирование с MeaningEngine
- Проверка создания событий

### Примеры использования

#### Ручное тестирование
```bash
# Запуск с включенными clarity moments
python -c "
from src.runtime.loop import run_loop
from src.state.self_state import SelfState
import threading

state = SelfState()
state.stability = 0.9
state.energy = 0.8

stop_event = threading.Event()
run_loop(state, lambda: None, stop_event=stop_event, disable_clarity_moments=False)
"
```

#### Мониторинг
```python
# Получение статуса clarity
clarity_moments.get_clarity_status(self_state)
# {
#     'active': True,
#     'duration_remaining': 25,
#     'total_events': 3,
#     'modifier': 1.5
# }
```

### Будущие улучшения

1. **Адаптивные пороги**: Динамическая настройка условий активации
2. **Множественные типы clarity**: Разные виды моментов ясности
3. **Влияние на другие компоненты**: Расширение эффектов clarity
4. **Статистика**: Детальный анализ частоты и продолжительности

## Memory Hierarchy System - Многоуровневая система памяти

### Назначение

**Многоуровневая система памяти** - это экспериментальная реализация иерархической модели памяти по аналогии с когнитивной психологией человека. Система включает четыре уровня памяти: сенсорную, эпизодическую, семантическую и процедурную.

### Архитектурные принципы

1. **Иерархичность**: Данные постепенно переносятся от нижних уровней к верхним
2. **Опциональность**: Система полностью опциональна и может быть отключена
3. **Изоляция**: Не изменяет существующие интерфейсы компонентов
4. **Консолидация**: Периодический перенос данных между уровнями памяти

### Компоненты

#### SensoryBuffer класс
Расположение: `src/experimental/memory_hierarchy/sensory_buffer.py`

**Назначение**: Кратковременное хранение сырых сенсорных данных до их обработки MeaningEngine.

**Основные возможности:**
- **Кольцевой буфер** фиксированного размера (256 записей по умолчанию)
- **TTL-based автоматическая очистка** (2 секунды по умолчанию)
- **Интеграция с EventQueue** для прозрачной работы
- **Структурированное логирование** всех операций
- **Thread-safe операции** с использованием locking механизмов
- **Расширенная статистика** и метрики производительности

**Ключевые методы:**
- `add_event(event)` - добавить событие в буфер
- `get_events_for_processing()` - получить события для обработки
- `peek_events()` - просмотреть события без удаления
- `get_buffer_status()` - получить статистику буфера
- `get_stats()` - получить детальную статистику буфера
- `clear()` - очистить буфер
- `_cleanup_expired()` - удалить истекшие записи

**Обновления (2026-01-21):**
- **Thread-safety**: Добавлена полная потокобезопасность для многопоточного использования
- **Производительность**: Оптимизированы операции для больших буферов (>1000 записей)
- **Тестирование**: Расширенное статическое тестирование всех аспектов функциональности
- **Граничные случаи**: Улучшенная обработка edge cases (нулевые TTL, пустые буферы, максимальные размеры)

**Расширение сенсорного буфера (2026-01-22):**
- **Новые записи**: Добавлены дополнительные события chain_1 с timestamps 1769055898-1769055983
- **Общий объем**: Сенсорный буфер теперь содержит расширенный набор тестовых данных для анализа паттернов
- **Цепочки событий**: Новые записи демонстрируют последовательности событий для тестирования зависимостей

#### MemoryHierarchyManager класс (v2.0)
Расположение: `src/experimental/memory_hierarchy/hierarchy_manager.py`

**Назначение**: Центральный менеджер для координации работы между уровнями памяти с настраиваемыми порогами переноса.

**Основные возможности:**
- **Управление переносом данных** между уровнями памяти с настраиваемыми порогами
- **Координация консолидации** (sensory → episodic → semantic) с улучшенной логикой
- **Управление procedural learning** из опыта
- **API для запросов** к разным уровням памяти
- **Динамическая настройка** порогов переноса данных
- **Расширенная статистика** и метрики производительности

**Ключевые методы:**
- `add_sensory_event(event)` - добавить событие в сенсорный буфер
- `process_sensory_events()` - обработать события для MeaningEngine
- `consolidate_memory(self_state)` - выполнить консолидацию между уровнями
- `get_hierarchy_status()` - получить статус всей иерархии
- `query_memory(level, **params)` - запрос к конкретному уровню памяти
- `set_transfer_thresholds()` - настроить пороги переноса между уровнями
- `get_transfer_thresholds()` - получить текущие пороги переноса

**Настраиваемые пороги переноса (v2.0):**
```python
# Конструктор с настройками
manager = MemoryHierarchyManager(
    sensory_to_episodic_threshold=5,      # Дефолт: 5
    episodic_to_semantic_threshold=10,    # Дефолт: 10
    semantic_consolidation_interval=60.0  # Дефолт: 60 сек
)

# Динамическая настройка
manager.set_transfer_thresholds(
    sensory_to_episodic=3,      # Более агрессивный перенос
    episodic_to_semantic=8,     # Более ранняя семантизация
    semantic_consolidation_interval=30.0  # Частая консолидация
)
```

**Улучшенная логика консолидации (v2.0):**
- **Улучшенная семантизация**: Учет средней значимости при создании концепций
- **Расширенные свойства концепций**: Добавление метаданных (source_event_type, observation_count, avg_significance)
- **Повышенная уверенность**: Более точный расчет confidence на основе количества наблюдений

### Уровни памяти

#### 1. Sensory Memory (Сенсорная память)
- **Длительность**: 1-2 секунды
- **Объем**: Ограниченный кольцевой буфер
- **Функция**: Временное хранение сырых сенсорных данных
- **Очистка**: Автоматическая по TTL

#### 2. Episodic Memory (Эпизодическая память)
- **Длительность**: Минуты/часы
- **Объем**: Неограниченный (с забыванием)
- **Функция**: Хранение личного опыта и событий
- **Интеграция**: Расширение существующей Memory системы

#### 3. Semantic Memory (Семантическая память)
- **Длительность**: Долгосрочная
- **Объем**: Концепции и знания
- **Функция**: Знания и онтология понятий
- **Статус**: Запланировано к реализации

#### 4. Procedural Memory (Процедурная память)
- **Длительность**: Долгосрочная
- **Объем**: Навыки и паттерны
- **Функция**: Автоматизмы поведения
- **Статус**: Запланировано к реализации

### Механизм консолидации

**Консолидация** - процесс переноса данных между уровнями памяти:

1. **Sensory → Episodic**: События с высокой интенсивностью (>0.7) автоматически переносятся в эпизодическую память
2. **Episodic → Semantic**: Повторяющиеся паттерны извлекаются как семантические концепции
3. **Semantic → Procedural**: Знания конвертируются в автоматизированные навыки

**Интервалы консолидации:**
- Sensory → Episodic: При каждом вызове `consolidate_memory()`
- Episodic → Semantic: По достижении порога повторений
- Semantic консолидация: Каждые 60 секунд

### Интеграция с компонентами

#### Runtime Loop
- MemoryHierarchyManager интегрирован в основной цикл
- Добавление событий происходит в каждом тике
- Консолидация памяти вызывается периодически

#### EventQueue
- SensoryBuffer прозрачно интегрируется с EventQueue
- События автоматически попадают в сенсорный буфер
- Обработка событий происходит через стандартный интерфейс

#### SelfState
- Новые поля сохраняются в snapshot
- Валидация через FieldValidator
- Поддержка сериализации/десериализации

```python
# Новые поля SelfState для многоуровневой памяти
sensory_buffer_size: int = 0        # Текущий размер сенсорного буфера
semantic_concepts_count: int = 0    # Количество семантических концепций
procedural_patterns_count: int = 0  # Количество процедурных паттернов
```

### Логирование

Система Memory Hierarchy логирует:
- Добавление событий в сенсорный буфер
- Перенос данных между уровнями
- Статистику консолидации
- Статус всей иерархии памяти

### Конфигурация

#### Включение/отключение
```python
run_loop(
    # ...
    enable_memory_hierarchy=True,  # True для включения экспериментальной памяти
    # ...
)
```

#### Настраиваемые параметры
```python
# В SensoryBuffer классе
DEFAULT_BUFFER_SIZE = 256
DEFAULT_TTL_SECONDS = 2.0
CLEANUP_INTERVAL_SECONDS = 0.5

# В MemoryHierarchyManager классе
SENSORY_TO_EPISODIC_THRESHOLD = 5
EPISODIC_TO_SEMANTIC_THRESHOLD = 10
SEMANTIC_CONSOLIDATION_INTERVAL = 60.0
```

### Тестирование

#### Unit тесты
- `src/test/test_memory_hierarchy.py` - базовая функциональность
- Проверка TTL механизмов и кольцевого буфера
- Тестирование консолидации между уровнями

#### Integration тесты
- `src/test/test_memory_hierarchy_integration.py` - интеграция с runtime loop
- Тестирование с EventQueue и SelfState
- Проверка создания MemoryEntry

### Примеры использования

#### Ручное тестирование
```bash
# Запуск с включенной многоуровневой памятью
python -c "
from src.runtime.loop import run_loop
from src.state.self_state import SelfState
from src.experimental.memory_hierarchy import MemoryHierarchyManager
import threading

state = SelfState()
hierarchy = MemoryHierarchyManager()

stop_event = threading.Event()
run_loop(state, lambda: None, stop_event=stop_event,
         enable_memory_hierarchy=True, memory_hierarchy=hierarchy)
"
```

#### Мониторинг состояния
```python
# Получение статуса иерархии памяти
status = hierarchy.get_hierarchy_status()
print(f"Sensory buffer size: {status['sensory_buffer']['buffer_size']}")
print(f"Transfers sensory→episodic: {status['hierarchy_manager']['transfers_sensory_to_episodic']}")
```

### Будущие улучшения

1. **Semantic Store**: Реализация семантической памяти с онтологией
2. **Procedural Store**: Система навыков и автоматизмов
3. **Advanced Consolidation**: Более сложные алгоритмы переноса данных
4. **Memory Search**: API для поиска по уровням памяти
5. **Performance Optimization**: Оптимизация для больших объемов данных

## Consciousness System - Система сознания

### Назначение

**Система сознания** - экспериментальная реализация модели сознания с уровнями осознанности и метриками. Включает базовую осознанность, саморефлексию и метакогницию.

### Архитектурные принципы

1. **Уровневость**: Иерархическая модель сознания
2. **Метрики**: Количественная оценка уровней сознания
3. **Опциональность**: Полностью отключаемая система
4. **Интеграция**: Использует существующие компоненты

### Уровни сознания

#### 1. Basic Awareness (Базовая осознанность)
- **Описание**: Реактивное восприятие и обработка событий
- **Метрики**: Частота тиков, обработка событий
- **Состояние**: "awake" - базовое рабочее состояние

#### 2. Self-Reflection (Саморефлексия)
- **Описание**: Анализ собственного поведения и состояния
- **Метрики**: Качество анализа, паттерны поведения
- **Статус**: ✅ Реализовано в ConsciousnessEngine

#### 3. Meta-Cognition (Метакогниция)
- **Описание**: Осознание собственных когнитивных процессов
- **Метрики**: Глубина абстрактного мышления
- **Статус**: ✅ Реализовано в ConsciousnessEngine

### Новые поля SelfState

```python
# Сознание
consciousness_level: float = 0.0       # Уровень сознания [0.0-1.0]
current_consciousness_state: str = "awake"  # Текущее состояние сознания
self_reflection_score: float = 0.0     # Оценка саморефлексии [0.0-1.0]
meta_cognition_depth: float = 0.0      # Глубина метакогниции [0.0-1.0]
```

### Компоненты системы сознания

#### ConsciousnessEngine класс
Расположение: `src/experimental/consciousness/engine.py`

Основные методы:
- `calculate_consciousness_level()` - расчет общего уровня сознания
- `assess_self_reflection()` - оценка саморефлексии
- `evaluate_meta_cognition()` - оценка метакогниции
- `determine_consciousness_state()` - определение состояния сознания

#### ConsciousnessMetrics класс
Расположение: `src/experimental/consciousness/metrics.py`

Метрики для количественной оценки сознания.

#### ConsciousnessStates класс
Расположение: `src/experimental/consciousness/states.py`

Управление состояниями сознания и переходами между ними.

### Состояния сознания

#### Основные состояния
- **unconscious** - отсутствие активного сознания
- **dreaming** - сниженное сознание, низкая энергия
- **awake** - базовое бодрствование
- **flow** - состояние потока, высокая эффективность
- **reflective** - рефлексивное состояние, анализ поведения
- **meta** - метакогнитивное состояние, анализ процессов

### Интеграция
- ✅ Интегрировано в runtime loop
- ✅ Обновляет SelfState поля
- ✅ API endpoints для мониторинга
- ✅ Полное логирование операций

### Обновление архитектуры (2026-01-21)

**Система сознания была обновлена для использования AdaptiveProcessingManager:**

#### Изменения в ParallelConsciousnessEngine
- **Интеграция с AdaptiveProcessingManager**: Engine теперь использует AdaptiveProcessingManager для анализа системных условий
- **Совместимость API**: Сохранена обратная совместимость с существующими интерфейсами
- **Улучшенная обработка**: Добавлена поддержка новых типов обработки через adaptive состояния
- **Новое свойство transition_history (2026-01-22)**: Добавлено property `transition_history` для обратной совместимости с методом `get_transition_history()`

#### Изменения в ConsciousnessMetrics
- **Интеграция метрик**: Метрики consciousness теперь интегрируются с метриками AdaptiveProcessingManager
- **Расширенная статистика**: Добавлены новые метрики производительности и анализа трендов
- **Совместимость**: Сохранена совместимость с legacy API

#### Изменения в ConsciousnessStates
- **Архитектурная совместимость**: Обновлены импорты для работы с AdaptiveProcessingManager
- **Форматирование кода**: Приведено к единому стилю с остальной кодовой базой

#### Преимущества обновления
- **Унифицированная архитектура**: Все экспериментальные компоненты теперь используют общий AdaptiveProcessingManager
- **Улучшенная производительность**: Оптимизированная обработка через адаптивные режимы
- **Расширенная функциональность**: Доступ к новым возможностям adaptive processing
- **Совместимость**: Полная обратная совместимость с существующими интеграциями

## Другие экспериментальные возможности

## Silence Awareness - Система осознания тишины

### Назначение

**Silence Awareness** - система, позволяющая Life осознавать периоды тишины как значимое событие. Автоматически детектирует длительные периоды без внешних событий и генерирует события типа `silence`, которые влияют на уровень сознания и поведение системы.

### Архитектурные принципы

1. **Пассивная детекция**: Система не ищет тишину активно, а реагирует на ее наличие
2. **Автоматическая генерация**: События тишины создаются автоматически при превышении порога
3. **Контекстуальная оценка**: Комфортность тишины зависит от длительности и состояния системы
4. **Интеграция с сознанием**: Тишина влияет на уровень consciousness_level

### Компоненты

#### SilenceDetector класс
Расположение: `src/environment/silence_detector.py`

**Функциональность:**
- Отслеживание времени последнего события
- Детекция периодов тишины (>30 секунд)
- Генерация событий `silence` с различной интенсивностью
- Предотвращение слишком частой генерации

#### Интеграция с EventQueue
EventQueue автоматически работает с SilenceDetector:
- Обновление времени при добавлении/извлечении событий
- Метод `check_and_generate_silence()` для проверки
- Получение статуса через `get_silence_status()`

### Тип события silence

**Спецификация:**
- **Интенсивность:** [-0.4, 0.6] (отрицательная = тревожная, положительная = комфортная)
- **Генерация:** Автоматическая через детектор (не случайная)
- **Частота:** Максимум 1 событие каждые 5 минут
- **Метаданные:** Информация о длительности, комфортности, источнике

### Влияние на сознание

**ConsciousnessEngine интеграция:**
- Тишина повышает consciousness_level на 0-10%
- Комфортная тишина дает больший бонус
- Фактор рассчитывается на основе интенсивности и количества событий

### Примеры

#### Базовое использование
```python
from src.environment.event_queue import EventQueue

# Создание очереди с системой тишины
queue = EventQueue(enable_silence_detection=True)

# После периода без событий
silence_event = queue.check_and_generate_silence()
if silence_event:
    print(f"Осознана тишина: интенсивность {silence_event.intensity:.2f}")
```

#### Мониторинг
```python
status = queue.get_silence_status()
print(f"Тишина активна: {status['is_silence_active']}")
print(f"Длительность: {status['current_silence_duration']:.1f} сек")
```

### Тестирование

**Комплект тестов:**
- Unit тесты для SilenceDetector
- Интеграционные тесты с EventQueue
- Тесты влияния на MeaningEngine
- Тесты влияния на ConsciousnessEngine

**Ключевые проверки:**
- Корректная детекция периодов тишины
- Правильные диапазоны интенсивности
- Влияние на уровень сознания
- Архитектурная совместимость

*Реализовано: Silence Awareness (осознание тишины)*

*В разработке:*
- Internal Rhythms (внутренние ритмы жизни)
- Memory Echo (эхо памяти)

## Безопасность и ограничения

- **Опциональность**: Все экспериментальные возможности можно отключить
- **Изоляция**: Не влияют на критическую функциональность
- **Мониторинг**: Полное логирование для анализа поведения
- **Тестирование**: Высокий уровень покрытия тестами
