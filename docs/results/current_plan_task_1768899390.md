# План выполнения: Добавить unit-тесты на корректность делегирования и отсутствие регрессий поведения

> **Задача:** “Добавить unit-тесты на корректность делегирования и отсутствие регрессий поведения”
> **Контекст:** разгрузка `src/runtime/loop.py` через менеджеры/политики + защита от поведенческих регрессий
> **Источник требований:** `docs/planning/task_2_20260120_094041.md` (Этап 5)
> **Дата создания:** 2026-01-20
> **ID:** task_1768899390

## 1. Контекст (что именно считаем “делегированием”)

Под “делегированием” в рамках проекта подразумевается, что `run_loop` в `src/runtime/loop.py` выступает **оркестратором**, а детали выполнения вынесены в отдельные компоненты с минимальным API:

- **SnapshotManager**: решает “когда” и “как” делать snapshot; `run_loop` не содержит inline-логики периодичности и обработки ошибок снапшота.
- **LogManager**: решает “когда” flush-ить лог-буфер; `run_loop` не делает flush на каждом тике.
- **LifePolicy**: содержит пороги/коэффициенты слабости и возвращает deltas; `run_loop` не содержит inline-формул штрафов.

Задача текущего шага — покрыть это unit-тестами, чтобы:

- гарантировать **корректность делегирования** (вызовы происходят в правильных местах),
- гарантировать **отсутствие регрессий поведения** (периодичность, инварианты, отсутствие неожиданного I/O/side-effects).

## 2. Что изучено из документации (ограничения/инварианты)

- **Тестовый контур**: все тесты в `src/test/`, pytest; есть unit/integration/property-based (`docs/testing/README.md`).
- **Runtime Loop**: ошибки не должны “убивать” жизнь; исключения логируются (`docs/components/runtime-loop.md`).
- **Action ↔ Feedback граница**: Action не знает о Feedback; регистрация действий делается в Loop, не в Action (`docs/archive/interfaces/action-feedback-interface.md`, `docs/components/feedback.md`).

## 3. Где разместить тесты и какая стратегия

- **Новый файл тестов (рекомендуется):** `src/test/test_runtime_loop_managers.py`
- **Стратегия:** spy/stub через `monkeypatch` (подмена функций/методов) и минимальные фикстуры, чтобы не поднимать реальный сервер.
- **Фокус:** unit-уровень + “интеграционный unit” (проверяем оркестрацию `run_loop`, но без реального I/O).

## 4. План работ (по шагам)

### Шаг 1: Инвентаризация точек делегирования (в тест-терминах)

- Зафиксировать, какие методы должны вызываться из `run_loop`:
  - `SnapshotManager.maybe_snapshot(...)` (или эквивалентный API),
  - `LogManager.maybe_flush(..., phase="tick"/"shutdown"/"exception")`,
  - `LifePolicy.is_weak(self_state)` и `LifePolicy.weakness_penalty(dt)` (или эквивалент).
- Зафиксировать “критические” места: **tick**, **exception**, **shutdown**, **snapshot-boundary**.

### Шаг 2: Тест 5.1 — SnapshotManager: строго по периоду

- Создать тест, который прогоняет набор `ticks` и проверяет:
  - `save_snapshot` вызывается **только** на ожидаемых тиках (например, кратных `period_ticks`),
  - при исключении внутри snapshot — loop продолжает жить (ошибка логируется, но тест не должен падать из-за stop-loop, если это ожидание проекта).

### Шаг 3: Тест 5.2 — LogManager: нет flush на каждом тике, но есть flush на shutdown

- Проверить, что:
  - на фазе `tick` flush происходит **реже**, чем “каждый тик” (например, 0 или \(\lfloor N / k \rfloor\) при политике “раз в k тиков”),
  - на фазе `shutdown` flush **обязателен** (ровно 1 раз при корректном завершении),
  - на фазе `exception` flush выполняется по политике (если так задокументировано) и не приводит к каскадным падениям.

### Шаг 4: Тест 5.3 — LifePolicy: границы, дельты и монотонность

- Проверить:
  - `is_weak` на границе порога (строгое/нестрогое сравнение фиксируем тестом),
  - `weakness_penalty(dt)` возвращает корректный набор ключей (energy/stability/integrity) и типы,
  - **монотонность**: при большем `dt` модуль штрафа не уменьшается (для каждого параметра).

### Шаг 5: Тест 5.4 — “интеграционный unit”: `run_loop` делегирует менеджерам

- Сконструировать минимальный запуск `run_loop` на малом числе тиков (или через управляемую остановку), где:
  - `SnapshotManager`, `LogManager`, `LifePolicy` — spy-объекты (счетчики вызовов),
  - подтверждаем, что `run_loop` вызывает менеджеры в ожидаемом порядке/фазах (как минимум: tick → maybe_snapshot → maybe_flush, и shutdown → maybe_flush).

### Шаг 6: Регрессионные проверки на “неожиданные побочные эффекты”

- Негативные проверки (минимальные, без хрупкости):
  - отсутствие зависимости тестов от `print()`/stdout,
  - отсутствие реального дискового I/O (snapshot/flush должны быть замоканы).
- Архитектурный smoke-check (по документации):
  - в тестах не должно появляться обратной связи Feedback → Action; при необходимости — отдельный тест на отсутствие импортов (опционально).

## 5. Критерии приемки

- ✅ Добавлен файл `src/test/test_runtime_loop_managers.py` (или эквивалент) с тестами 5.1–5.4.
- ✅ Тесты фиксируют:
  - периодичность снапшотов,
  - отсутствие flush “каждый тик”,
  - корректность и монотонность `LifePolicy`,
  - факт делегирования из `run_loop` в менеджеры/политику.
- ✅ Тесты не хрупкие: не зависят от stdout и не требуют реального сервера/диска.
- ✅ Все существующие тесты проекта продолжают проходить.

---

**Автор плана:** AI Agent (Project Executor)
