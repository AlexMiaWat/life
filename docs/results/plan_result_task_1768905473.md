# Отчет о проблемах текущего подхода

## Задача
Зафиксировать проблемы текущего подхода: идентичность объектов, висящие потоки/серверы, непредсказуемость.

## 1. Проблемы с идентичностью объектов

### 1.1. Глобальные переменные в main_server_api.py

**Проблема:** В файле `src/main_server_api.py` используются глобальные переменные для управления состоянием сервера:
- `server` - экземпляр HTTPServer
- `self_state` - состояние системы
- `event_queue` - очередь событий
- `api_thread` - поток API сервера
- `loop_thread` - поток runtime loop
- `loop_stop` - событие остановки
- `monitor`, `log` - функции мониторинга
- `config` - конфигурация

**Последствия:**
- При перезагрузке модулей через `importlib.reload()` старые объекты могут оставаться в памяти
- Новые объекты создаются, но ссылки на старые могут сохраняться в других модулях
- Это приводит к проблемам с идентичностью: `old_object is not new_object`, но они могут использоваться одновременно
- Сравнение объектов через `is` может давать неожиданные результаты

**Пример проблемы:**
```python
# В reloader_thread():
importlib.reload(console_module)
monitor = console_module.monitor  # Новая ссылка
# Но старые модули могут все еще использовать старую ссылку
```

**Местоположение:** `src/main_server_api.py`, строки 234, 303-305, 344-415

### 1.2. Перезагрузка модулей и идентичность объектов

**Проблема:** При использовании `importlib.reload()` в функции `reloader_thread()`:
- Старые классы и функции остаются в памяти
- Новые версии создаются, но старые объекты могут ссылаться на старые классы
- Это создает ситуацию, когда `isinstance(new_obj, OldClass)` может быть `True`, но `isinstance(new_obj, NewClass)` тоже может быть `True` (если классы имеют одинаковое имя)

**Последствия:**
- Непредсказуемое поведение при проверке типов
- Проблемы с сериализацией/десериализацией (старые объекты могут использовать старые версии классов)
- Утечки памяти (старые объекты не могут быть удалены сборщиком мусора)

**Местоположение:** `src/main_server_api.py`, строки 288-293

### 1.3. Отсутствие явного управления жизненным циклом объектов

**Проблема:** Нет явного механизма для:
- Отслеживания всех созданных объектов
- Гарантированного освобождения ресурсов
- Проверки, что объекты действительно удалены из памяти

**Последствия:**
- Невозможно гарантировать, что старые объекты удалены
- Проблемы с утечками памяти
- Непредсказуемое поведение при длительной работе системы

## 2. Проблемы с висящими потоками и серверами

### 2.1. Некорректное завершение потоков при перезагрузке

**Проблема:** В функции `reloader_thread()` при перезагрузке модулей:

```python
# Остановка API сервера
if server:
    server.shutdown()
    if api_thread:
        api_thread.join()  # Нет таймаута!
```

**Последствия:**
- Если `api_thread` не завершится, основной поток будет ждать бесконечно
- Нет таймаута для `api_thread.join()`, в отличие от `loop_thread.join(timeout=5.0)`
- Поток может зависнуть, если сервер не может корректно завершиться

**Местоположение:** `src/main_server_api.py`, строки 274-278

### 2.2. Проблемы с остановкой loop_thread

**Проблема:** При перезагрузке модулей:

```python
if loop_thread and loop_thread.is_alive():
    loop_stop.set()
    loop_thread.join(timeout=5.0)  # Таймаут 5 секунд
    log("[RELOAD] Old loop stopped")
```

**Последствия:**
- Если `loop_thread` не завершится за 5 секунд, он останется работать в фоне
- Старый поток будет использовать старые версии модулей
- Два потока могут работать одновременно (старый и новый), что приводит к race conditions
- Нет механизма принудительного завершения зависшего потока

**Местоположение:** `src/main_server_api.py`, строки 322-325

### 2.3. Daemon потоки и непредсказуемое завершение

**Проблема:** Все потоки создаются с флагом `daemon=True`:

```python
api_thread = threading.Thread(
    target=start_api_server, args=(self_state, event_queue, dev_mode), daemon=True
)
loop_thread = threading.Thread(
    target=run_loop, args=(...), daemon=True
)
```

**Последствия:**
- Daemon потоки могут быть прерваны в любой момент при завершении основного процесса
- Нет гарантии корректного завершения работы (закрытие файлов, сохранение состояния)
- Ресурсы могут не быть освобождены (открытые файлы, сетевые соединения)
- Невозможно гарантировать сохранение последнего состояния перед завершением

**Местоположение:** `src/main_server_api.py`, строки 312-317, 328-339, 386-404

### 2.4. Проблемы с StoppableHTTPServer

**Проблема:** В классе `StoppableHTTPServer`:

```python
def serve_forever(self, poll_interval=0.5):
    self.timeout = poll_interval
    while not self.stopped:
        self.handle_request()
```

**Последствия:**
- Если `handle_request()` блокируется на долгое время, проверка `self.stopped` не выполняется
- Сервер может не реагировать на `shutdown()` сразу
- Нет гарантии, что все активные запросы будут обработаны перед завершением
- Метод `shutdown()` только устанавливает флаг, но не прерывает активные запросы

**Местоположение:** `src/main_server_api.py`, строки 42-45, 47-49

### 2.5. Отсутствие механизма отслеживания потоков

**Проблема:** Нет централизованного механизма для:
- Отслеживания всех созданных потоков
- Проверки их состояния (alive/dead)
- Принудительного завершения зависших потоков
- Логирования проблем с потоками

**Последствия:**
- Невозможно обнаружить висящие потоки
- Невозможно диагностировать проблемы с производительностью
- Невозможно гарантировать чистоту при перезагрузке

## 3. Проблемы с непредсказуемостью

### 3.1. Потеря событий в EventQueue

**Проблема:** В `EventQueue.push()`:

```python
def push(self, event: Event) -> None:
    try:
        self._queue.put_nowait(event)
    except queue.Full:
        pass  # silently drop if full
```

**Последствия:**
- События теряются без уведомления
- Нет механизма для обработки переполнения (backpressure)
- Невозможно отследить, сколько событий было потеряно
- Поведение системы становится непредсказуемым при высокой нагрузке

**Местоположение:** `src/environment/event_queue.py`, строки 10-14

### 3.2. Race condition в EventQueue.pop_all()

**Проблема:** В методе `pop_all()`:

```python
def pop_all(self) -> list[Event]:
    events = []
    while not self._queue.empty():  # Проверка
        try:
            event = self._queue.get_nowait()  # Операция
            events.append(event)
        except queue.Empty:
            break
    return events
```

**Последствия:**
- Между проверкой `empty()` и `get_nowait()` другой поток может извлечь элемент
- Это приводит к race condition: проверка говорит, что очередь не пуста, но `get_nowait()` выбрасывает `Empty`
- Хотя исключение обрабатывается, это создает непредсказуемое поведение
- Может привести к потере событий или дублированию обработки

**Местоположение:** `src/environment/event_queue.py`, строки 28-42

### 3.3. Непредсказуемое поведение при перезагрузке модулей

**Проблема:** Использование `importlib.reload()` в `reloader_thread()`:

```python
importlib.reload(console_module)
importlib.reload(loop_module)
# ...
monitor = console_module.monitor
run_loop = loop_module.run_loop
```

**Последствия:**
- Старые объекты могут продолжать использовать старые версии модулей
- Новые объекты используют новые версии
- Это создает ситуацию, когда разные части системы работают с разными версиями кода
- Невозможно предсказать, какая версия кода будет использована в конкретный момент
- Проблемы с состоянием: старые объекты могут иметь ссылки на старые функции, которые уже не существуют

**Местоположение:** `src/main_server_api.py`, строки 288-305

### 3.4. Глобальные переменные и состояние

**Проблема:** Использование глобальных переменных для состояния:

```python
global server, self_state, event_queue, api_thread, monitor, log, loop_thread, loop_stop, config
```

**Последствия:**
- Любой модуль может изменить глобальное состояние
- Невозможно отследить, кто и когда изменил состояние
- Проблемы с тестированием (глобальное состояние сохраняется между тестами)
- Непредсказуемое поведение при параллельном доступе
- Сложность отладки (неясно, откуда пришло изменение)

**Местоположение:** `src/main_server_api.py`, строка 234

### 3.5. Неопределенное поведение при ошибках

**Проблема:** Во многих местах ошибки обрабатываются молча или с минимальным логированием:

```python
except Exception as e:
    self_state.apply_delta({"integrity": -0.05})
    print(f"Ошибка в цикле: {e}")
    traceback.print_exc()
```

**Последствия:**
- Ошибки могут накапливаться незаметно
- Состояние системы деградирует (integrity уменьшается), но причина не всегда ясна
- Невозможно предсказать, как система поведет себя после ошибки
- Нет механизма восстановления после ошибок

**Местоположение:** `src/runtime/loop.py`, строки 446-449

### 3.6. Непредсказуемое время выполнения операций

**Проблема:** В runtime loop нет гарантий времени выполнения:
- Обработка событий может занять неопределенное время
- Learning и Adaptation выполняются периодически, но время выполнения не ограничено
- Snapshot сохранение может занять долгое время при большом объеме данных

**Последствия:**
- Невозможно гарантировать реальное время выполнения тика
- Система может "зависнуть" на долгое время без видимых причин
- Нет механизма для прерывания долгих операций

**Местоположение:** `src/runtime/loop.py`, весь файл

## 4. Сводная таблица проблем

| Категория | Проблема | Критичность | Местоположение |
|-----------|----------|-------------|----------------|
| Идентичность объектов | Глобальные переменные | Высокая | `main_server_api.py:234, 303-305` |
| Идентичность объектов | Перезагрузка модулей | Высокая | `main_server_api.py:288-293` |
| Идентичность объектов | Отсутствие управления жизненным циклом | Средняя | Весь проект |
| Висящие потоки | Некорректное завершение api_thread | Высокая | `main_server_api.py:274-278` |
| Висящие потоки | Проблемы с остановкой loop_thread | Высокая | `main_server_api.py:322-325` |
| Висящие потоки | Daemon потоки | Средняя | `main_server_api.py:312-317, 386-404` |
| Висящие потоки | Проблемы с StoppableHTTPServer | Средняя | `main_server_api.py:42-49` |
| Висящие потоки | Отсутствие отслеживания потоков | Средняя | Весь проект |
| Непредсказуемость | Потеря событий | Высокая | `event_queue.py:10-14` |
| Непредсказуемость | Race condition в pop_all | Средняя | `event_queue.py:28-42` |
| Непредсказуемость | Перезагрузка модулей | Высокая | `main_server_api.py:288-305` |
| Непредсказуемость | Глобальные переменные | Высокая | `main_server_api.py:234` |
| Непредсказуемость | Неопределенное поведение при ошибках | Средняя | `loop.py:446-449` |
| Непредсказуемость | Непредсказуемое время выполнения | Средняя | `loop.py` (весь файл) |

## 5. Рекомендации по приоритетам исправления

### Критичные (требуют немедленного исправления):
1. Добавить таймаут для `api_thread.join()` при перезагрузке
2. Реализовать механизм принудительного завершения зависших потоков
3. Исправить потерю событий в EventQueue (добавить backpressure или уведомления)
4. Устранить race condition в `EventQueue.pop_all()`

### Важные (требуют исправления в ближайшее время):
1. Убрать глобальные переменные, использовать dependency injection
2. Реализовать корректный механизм перезагрузки модулей без проблем с идентичностью
3. Добавить механизм отслеживания всех потоков
4. Улучшить обработку ошибок с логированием и восстановлением

### Желательные (можно исправить позже):
1. Реализовать управление жизненным циклом объектов
2. Добавить ограничения времени выполнения для операций
3. Улучшить механизм остановки StoppableHTTPServer

## 6. Заключение

Текущий подход имеет серьезные проблемы с:
- **Идентичностью объектов**: глобальные переменные и перезагрузка модулей создают ситуации, когда старые и новые объекты сосуществуют
- **Висящими потоками/серверами**: отсутствие корректного механизма завершения потоков приводит к их накоплению и утечкам ресурсов
- **Непредсказуемостью**: потеря событий, race conditions, глобальное состояние делают поведение системы непредсказуемым

Эти проблемы требуют системного подхода к рефакторингу архитектуры для обеспечения надежности и предсказуемости системы.

Отчет завершен!
