# План: Добавить тесты для субъективного времени (монотонность, диапазоны, влияние интенсивности/стабильности)

> **Дата:** 2026-01-20  
> **Задача:** “Добавить тесты: монотонность subjective time, диапазоны, влияние интенсивности/стабильности”  
> **Контекст:** задача #3 “Subjective Time как сквозная ось” (`docs/planning/task_3_20260120_094041.md`)

## 0. Что уже известно из документации (инварианты)

Источник: `docs/planning/task_3_20260120_094041.md`

- **Монотонность:** при любом \(dt \ge 0\) приращение \(dS \ge 0\), а накопленное `subjective_time` не убывает.
- **Ограничение скорости:** \(rate \in [r_{min}, r_{max}]\).
- **Рекомендуемая форма:** \(dS = dt \cdot rate\), где \(rate = clamp(r_{min}, r_{max}, base + \Delta_{state} + \Delta_{events})\).
- **Факторы:**
  - \(\Delta_{state}\) зависит от `energy`/`stability` (и возможно `fatigue`/`tension`, если будет подтверждено в реализации).
  - \(\Delta_{events}\) зависит от “интенсивности последних событий”: предпочтительно `meaning.significance`, fallback на `event.intensity`.

## 1. Текущий статус кода (важно для тест-плана)

На момент планирования в `src/` **нет** реализации/упоминаний `subjective_time`, `subjective_rate`, `subjective_timestamp`.

Следствие: чтобы написать устойчивые unit-тесты, потребуется **явная точка вычисления** (функция/модуль), а для integration-тестов — появление поля в `SelfState` и обновление в `src/runtime/loop.py`.

## 2. Стратегия тестирования (уровни)

### 2.1. Unit-тесты (быстрые, детерминированные)

Цель: проверить математические инварианты модели, не завися от потоков, `time.sleep()` и очередей.

**Предпосылка к коду:** выделить вычисление в небольшую чистую функцию (или класс-политику), например:

- `src/runtime/subjective_time.py`:
  - `compute_subjective_rate(state: SelfState, event_signal: float) -> float`
  - `compute_subjective_delta(dt: float, rate: float) -> float`

> Примечание: это не “оптимизационный контур”, а только выделение логики для тестируемости; соответствует ADR 002, т.к. вызов остается в Runtime Loop.

**Набор unit-инвариантов:**

- **U1 — монотонность при dt=0:** если `dt == 0`, то `dS == 0`, `subjective_time` не меняется.
- **U2 — монотонность при dt>0:** если `dt > 0`, то `dS >= 0`.
- **U3 — диапазон rate:** `rate` всегда в \([r_{min}, r_{max}]\) при любых допустимых `energy/stability` и любом допустимом сигнале события.
- **U4 — диапазон dS:** \(dS \in [dt \cdot r_{min}, dt \cdot r_{max}]\) при `dt >= 0`.
- **U5 — влияние интенсивности/значимости:** при фиксированном состоянии, увеличение “сигнала события” (например `event_intensity_max` или `meaning_significance_max`) **монотонно** изменяет `rate` в сторону, выбранную в реализации.
  - Важное уточнение: знак влияния (ускоряет/замедляет) должен быть **зафиксирован в реализации** (docstring/комментарий), после чего тест проверяет именно этот контракт.
- **U6 — влияние stability/energy:** при фиксированном `dt` и event_signal, изменение `stability` (и/или `energy`) влияет на `rate` предсказуемо (монотонно) согласно выбранной \(\Delta_{state}\).

**Файл тестов:** `src/test/test_subjective_time.py` (новый).

### 2.2. Интеграционные тесты (через runtime loop)

Цель: убедиться, что Runtime Loop:

- обновляет `subjective_time` на каждом тике;
- использует ожидаемый event-signal (significance/intensity) и state (`energy/stability`);
- сохраняет инварианты при реальном жизненном цикле.

**Проблема детерминизма:** `run_loop()` использует `time.time()` и `time.sleep()`. Для надежных тестов нужно:

- замонкейпатчить `time.time()` на управляемый счетчик;
- замонкейпатчить `time.sleep()` в no-op (или короткий сон), чтобы тест не зависел от реального времени.

**Интеграционные кейсы:**

- **I1 — субъективное время растет:** запустить loop на N тиков, проверить `state.subjective_time` увеличилось и не убывало (можно проверять snapshot до/после).
- **I2 — скорость в диапазоне:** если loop логирует/хранит `subjective_rate` (опционально), проверить, что rate в clamp-диапазоне на каждом тике (или на нескольких выборках).
- **I3 — влияние события:** при двух запусках с одинаковым `dt`-профилем, но разным событием (низкая vs высокая intensity/significance), итоговое `subjective_time` отличается в ожидаемую сторону.

**Где разместить/обновить:** расширить `src/test/test_runtime_integration.py` или добавить отдельный `src/test/test_runtime_subjective_time_integration.py`.

## 3. Минимальные требования к реализации (чтобы тесты были возможны)

Чтобы тесты были стабильными и прозрачными, в коде нужно иметь:

- `SelfState.subjective_time: float` (default 0.0).
- Явные параметры clamp:
  - `subjective_time_min_rate: float`
  - `subjective_time_max_rate: float`
  - (опционально) коэффициенты влияния состояния/событий.
- В loop — расчёт `rate` и \(dS\) **до** применения к `SelfState`:
  - `dS = max(0.0, dt * rate)` (как минимум защита от отрицательных значений).

## 4. План выполнения (пошагово)

1) **Зафиксировать контракт влияний в реализации**  
   - В коде (docstring) определить: “больше intensity/significance → быстрее или медленнее субъективное время”, аналогично для `stability`/`energy`.

2) **Добавить точку тестирования (выделение функции вычисления)**  
   - Вынести расчёт `rate`/`dS` в отдельную функцию/модуль (см. 2.1).

3) **Написать unit-тесты**  
   - Реализовать U1–U6.
   - Добавить тесты на граничные значения: `dt=0`, `dt>0`, `event_signal=0`, min/max `stability`, min/max `energy`.

4) **Написать интеграционные тесты runtime loop**  
   - Реализовать I1–I3 с monkeypatch `time.time`/`time.sleep`.

5) **Запуск всего тестового набора и стабилизация**  
   - `pytest -q` (или pipeline CI) без флаков.

## 5. Критерии готовности (Definition of Done)

- Добавлен новый тестовый файл(ы) с покрытием:
  - монотонность `subjective_time`;
  - диапазоны `rate` и производного `dS`;
  - влияние интенсивности/значимости;
  - влияние `stability`/`energy`.
- Тесты **детерминированны** (не зависят от реального времени).
- Тесты проходят локально и в CI.

