# План выполнения задачи: "Добавить адаптивные веса для типов событий на основе статистики"

## Задача ME.3 из ROADMAP_2026.md

**Описание:** Реализовать адаптивные веса для типов событий на основе внутренней статистики системы, без оптимизации и целей.

**Архитектурные требования:**
- Весы должны изменяться медленно (максимум 0.01 за раз)
- Изменения основаны только на внутренней статистике (event_type_counts из LearningEngine)
- Без оценки эффективности, целей или намерений
- Соответствует концепциям Learning/Adaptation (этапы 14-15)

## Анализ текущей архитектуры

### EventGenerator (src/environment/generator.py)
- Имеет фиксированные веса: `[0.33, 0.23, 0.17, 0.038, 0.038, ...]`
- Типы событий: `noise`, `decay`, `recovery`, `shock`, `idle`, `memory_echo`, социальные, когнитивные, экзистенциальные
- Использует `random.choices(types, weights=weights)`

### LearningEngine (src/learning/learning.py)
- Собирает статистику: `event_type_counts`, `event_type_total_significance`
- Имеет ограничения: максимум 0.01 изменения за раз, без оптимизации
- Работает с `learning_params` в SelfState

### Runtime Loop (src/runtime/loop.py)
- Learning вызывается раз в 75 тиков
- Adaptation вызывается раз в 100 тиков
- Есть механизм инициализации параметров по умолчанию

## План реализации

### 1. Анализ требований и текущей имплементации
**Статус:** Выполнено ✅
- Изучена структура EventGenerator и фиксированные веса
- Поняты ограничения Learning/Adaptation (без оптимизации)
- Определена интеграционная точка в runtime loop

### 2. Расширение LearningEngine для расчета адаптивных весов
**Файл:** `src/learning/learning.py`

Добавить метод `adjust_event_weights()`:
- Принимает `statistics` (event_type_counts)
- Вычисляет новые веса на основе частоты событий
- Ограничивает изменения максимум 0.01 за раз
- Возвращает словарь `event_type -> weight`

Логика изменения:
- Если событие частое (>20% всех событий): слегка увеличить вес
- Если событие редкое (<10% всех событий): слегка уменьшить вес
- Иначе: оставить без изменений

### 3. Добавление поля event_weights в SelfState
**Файл:** `src/state/self_state.py`

Добавить:
- Поле `event_weights: Dict[str, float]` в dataclass
- Метод `_get_default_event_weights()` для инициализации
- Валидация в `__post_init__`

### 4. Модификация EventGenerator
**Файл:** `src/environment/generator.py`

Изменить метод `generate()`:
- Принимать `self_state` как параметр
- Использовать `self_state.event_weights` если доступны
- Fallback на фиксированные веса при отсутствии адаптивных
- Поддерживать обратную совместимость

### 5. Интеграция в runtime loop
**Файл:** `src/runtime/loop.py`

Добавить после Learning (каждые 75 тиков):
- Вызов `learning_engine.adjust_event_weights(statistics)`
- Обновление `self_state.event_weights`
- Логирование изменений

### 6. Написание тестов
**Файлы:** `src/test/test_learning.py`, `src/test/test_environment.py`

- Тесты для `adjust_event_weights()` в LearningEngine
- Тесты для использования адаптивных весов в EventGenerator
- Интеграционные тесты с SelfState
- Проверка ограничений изменения (макс 0.01)

### 7. Валидация интеграции
- Запуск системы с адаптивными весами
- Проверка изменения весов на основе искусственной статистики
- Мониторинг через логи runtime loop
- Проверка обратной совместимости

## Ограничения и требования

### Архитектурные ограничения
- **Без оптимизации:** Весы изменяются только на основе частоты, без оценки "полезности"
- **Медленное изменение:** Максимум 0.01 изменения веса за раз
- **Без целей:** Изменения происходят автоматически, без намерений

### Технические требования
- **Обратная совместимость:** Система работает без адаптивных весов
- **Валидация:** Все изменения валидируются на границы [0.0, 1.0]
- **Логирование:** Все изменения логируются для отладки
- **Thread-safe:** Работа в многопоточной среде

## Риски и mitigation

### Риски
1. **Производительность:** Дополнительные вычисления каждый 75 тиков
2. **Сложность:** Увеличение связанности компонентов
3. **Тестирование:** Сложность тестирования адаптивного поведения

### Mitigation
1. **Профилирование:** Измерение накладных расходов
2. **Архитектура:** Четкое разделение ответственности
3. **Тесты:** Комплексное покрытие edge cases

## Критерии успеха

### Функциональные
- ✅ EventGenerator использует адаптивные веса из SelfState
- ✅ Весы изменяются на основе статистики event_type_counts
- ✅ Изменения ограничены 0.01 за раз
- ✅ Обратная совместимость с фиксированными весами

### Нефункциональные
- ✅ Архитектурные ограничения соблюдены (без оптимизации)
- ✅ Производительность не ухудшилась (>80 ticks/sec)
- ✅ Полное покрытие тестами (>95%)
- ✅ Логирование изменений для отладки

## Следующие шаги после реализации

1. **ME.4:** Анализ паттернов событий
2. **ME.5:** Улучшение impact_model на основе статистики
3. **Интеграционное тестирование** всей системы Learning/Adaptation/Event Generation

---
*План создан: 2026-01-21*
*Следующий шаг: Изучить текущую имплементацию EventGenerator*</contents>
</xai:function_call">### 8. Провести интеграционное тестирование и проверить, что адаптивные веса корректно изменяются на основе статистики (id: validate_integration)
