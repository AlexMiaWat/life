# План выполнения: Разгрузить `src/runtime/loop.py` (менеджеры + политика + hot-path)

> **Задача:** Разгрузить `src/runtime/loop.py`: выделить менеджеры и убрать "скрытые" расходы
> **Источник требований:** `docs/planning/task_2_20260120_094041.md`
> **Дата создания:** 2026-01-20
> **ID:** task_1768899028

## 1. Контекст и цель

`src/runtime/loop.py` сейчас совмещает оркестрацию runtime, обработку событий, Learning/Adaptation, memory-архивацию/decay, политику “слабости”, снапшоты и логирование. В hot-path присутствуют:

- `print()` при обработке событий/архивации/слабости (шум + задержки).
- `self_state._flush_log_buffer()` в `finally` **на каждом тике** (регулярный I/O и нестабильный tick interval).

Цель: оставить `run_loop` координатором, а I/O и политики вынести в отдельные компоненты (без изменения контрактов и базовой семантики).

## 2. Ограничения (важно сохранить)

- Сигнатура `run_loop(...)` и базовая семантика работы цикла сохраняются.
- Формат снапшотов не меняем (используем существующий `save_snapshot(self_state)`).
- Принцип проекта: “смерти нет — только слабость”; поведение `active` при `<=0` не ломаем.
- Новые компоненты не тянут внешние зависимости (только stdlib + текущие сущности проекта).

## 3. План работ (по шагам)

### Этап 0: Инвентаризация hot-path и точек делегирования (подготовка)

- Зафиксировать текущие места в `src/runtime/loop.py`, где:
  - дергается снапшот (ticks-based),
  - выполняется flush логов (сейчас в `finally` каждый тик),
  - применяется “weakness penalty” (порог/коэффициенты),
  - делаются `print()`.
- Определить минимальные seam-точки, чтобы перенос был “код-в-код” без изменения логики.

### Этап 1: `SnapshotManager` (изоляция снапшотов и ошибок)

- Создать `src/runtime/snapshot_manager.py`:
  - хранит `period_ticks`,
  - знает `should_snapshot(ticks)`,
  - `maybe_snapshot(self_state)` вызывает `save_snapshot(self_state)` и **логирует** ошибки без падения loop.
- В `run_loop` заменить inline-блок снапшота на вызов менеджера.

### Этап 2: `LogManager` (политика flush вместо flush на каждом тике)

- Создать `src/runtime/log_manager.py`:
  - инкапсулирует `flush_fn` (обертка над `self_state._flush_log_buffer()`),
  - реализует политику `maybe_flush(self_state, *, phase=...)`:
    - **tick**: редкий flush (например, раз в N тиков / при снапшоте),
    - **exception**: принудительный flush перед логированием/после,
    - **shutdown**: обязательный flush.
- В `run_loop` убрать `finally: self_state._flush_log_buffer()` на каждый тик.
  - Заменить на `log_manager.maybe_flush(..., phase="tick")` (по политике),
  - и `log_manager.maybe_flush(..., phase="shutdown")` при выходе из цикла.

### Этап 3: `LifePolicy` (единая, тестируемая “weakness/penalties”)

- Создать `src/runtime/life_policy.py`:
  - параметры (как минимум): `weakness_threshold`, коэффициенты штрафов (с дефолтами из текущего кода),
  - `is_weak(self_state) -> bool`,
  - `weakness_penalty(dt) -> dict[str, float]` (чистая логика: возвращает deltas).
- В `run_loop` заменить inline-штрафы на вызов `policy`.

### Этап 4: Убрать `print()` из hot-path (замена на `logger`)

- В `src/runtime/loop.py`:
  - заменить `print()` на `logger.debug/info/warning/error`,
  - убедиться, что подробные сообщения уходят в `debug` и по умолчанию не шумят.
- Проверить, что сообщения с высокой частотой (например “After interpret…”) не попадают в `info` по умолчанию.

### Этап 5: Тесты (делегирование + отсутствие регрессий)

- Добавить unit-тесты (например `src/test/test_runtime_loop_managers.py`):
  - `SnapshotManager` вызывает snapshot строго по периоду.
  - `LogManager` **не** flush-ит каждый тик; flush на shutdown обязателен.
  - `LifePolicy` корректно определяет слабость и возвращает ожидаемые deltas.
  - “Интеграционный unit”: `run_loop` делегирует вызовы менеджерам (spy/stub).

### Этап 6: Прогон качества

- Прогнать `pytest` (минимум `src/test/`).
- Проверить отсутствие `print()` в `src/runtime/loop.py`.
- Убедиться, что поведение снапшотов/штрафов не изменилось относительно формул/порогов (дефолты совпадают).

## 4. Критерии приемки (чеклист)

- ✅ В `src/runtime/loop.py` нет inline-логики снапшотов — используется `SnapshotManager`.
- ✅ В `src/runtime/loop.py` нет flush лог-буфера на каждом тике — используется `LogManager` с политикой.
- ✅ Логика “weakness/penalties” вынесена в `LifePolicy` и тестируется отдельно.
- ✅ В hot-path нет `print()` — только `logger` с корректными уровнями.
- ✅ Добавлены unit-тесты на делегирование и ключевые инварианты; существующие тесты проходят.

## 5. Риски и митигация (кратко)

- **Потеря логов при падении**: обязательный flush на shutdown + flush при exception/перед snapshot.
- **Регрессии поведения**: перенос “код-в-код” + тесты на формулы/порог/периодичность.

---

**Автор плана:** AI Agent (Project Executor)
