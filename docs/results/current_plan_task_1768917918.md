# План выполнения задачи: Вынести логирование/буферизацию в `LogManager`

**Задача:** Вынести логирование/буферизацию в `LogManager` (и перестать вызывать `_flush_log_buffer()` на каждом тике)

**Дата создания:** 2026-01-20  
**ID задачи:** 1768917918  
**Источник:** [todo/GENERATED_20260120_20260120_094041.md](../../todo/GENERATED_20260120_20260120_094041.md)

## Анализ текущей ситуации

### Текущее состояние

#### ✅ Уже выполнено

1. **`LogManager` создан и интегрирован в `runtime/loop.py`:**
   - Класс `LogManager` существует в `src/runtime/log_manager.py`
   - Класс `FlushPolicy` определяет политику flush
   - В `runtime/loop.py` создается экземпляр `LogManager` и используется для управления flush

2. **Убран flush на каждом тике из hot-path:**
   - В `runtime/loop.py` больше нет `finally: self_state._flush_log_buffer()` на каждом тике
   - Flush управляется через `log_manager.maybe_flush()` с политикой:
     - Периодический flush (раз в N тиков)
     - Flush перед снапшотом
     - Flush после снапшота (если был сделан)
     - Flush при исключениях
     - Flush при завершении (shutdown)

3. **Добавлены unit-тесты:**
   - Тесты для `LogManager` в `src/test/test_runtime_loop_managers.py`
   - Проверка отсутствия flush на каждом тике

#### ⚠️ Требует анализа

**Прямые вызовы `_flush_log_buffer()` в `SelfState`:**

1. **`_log_change()` (строка 195):**
   ```python
   if len(self._log_buffer) >= self._log_buffer_size:
       self._flush_log_buffer()
   ```
   - **Назначение:** Защита от переполнения буфера
   - **Оценка:** Оправдано - это защитный механизм, предотвращающий потерю данных

2. **`enable_logging()` (строка 417):**
   ```python
   self._flush_log_buffer()
   ```
   - **Назначение:** Сброс буфера при включении логирования
   - **Оценка:** Требует анализа - возможно, нужно оставить для консистентности

3. **`disable_logging()` (строка 422):**
   ```python
   self._flush_log_buffer()
   ```
   - **Назначение:** Сброс буфера перед отключением логирования
   - **Оценка:** Оправдано - нужно сохранить накопленные логи перед отключением

4. **`set_log_buffer_size()` (строка 448):**
   ```python
   if len(self._log_buffer) >= size:
       self._flush_log_buffer()
   ```
   - **Назначение:** Защита от потери данных при уменьшении размера буфера
   - **Оценка:** Оправдано - это защитный механизм

## Цели задачи

### Основная цель (уже выполнена)
✅ Убрать flush на каждом тике из hot-path runtime loop

### Дополнительные цели (требуют уточнения)

1. **Централизация управления flush:**
   - Определить, должны ли прямые вызовы `_flush_log_buffer()` в `SelfState` остаться или быть заменены на использование `LogManager`
   - Оценить необходимость интеграции `LogManager` в методы `SelfState`

2. **Документирование архитектуры:**
   - Задокументировать разделение ответственности между `SelfState` и `LogManager`
   - Уточнить, когда допустимы прямые вызовы `_flush_log_buffer()`

## Архитектурные решения

### Разделение ответственности

**`SelfState`:**
- Хранение буфера логов (`_log_buffer`)
- Добавление записей в буфер (`_log_change()`)
- Защитный flush при переполнении буфера
- Защитный flush при изменении конфигурации (размер буфера, включение/отключение логирования)

**`LogManager`:**
- Управление политикой flush (когда делать flush)
- Координация flush в runtime loop
- Flush по расписанию (периодически, перед/после снапшота, при исключениях, при завершении)

### Принцип работы

1. **Защитные flush в `SelfState`:**
   - Автоматический flush при переполнении буфера (предотвращает потерю данных)
   - Flush при изменении размера буфера (предотвращает потерю данных)
   - Flush при отключении логирования (сохранение накопленных логов)

2. **Политические flush через `LogManager`:**
   - Периодический flush (раз в N тиков)
   - Flush перед/после снапшота (точки консистентности)
   - Flush при исключениях (сохранение логов при ошибках)
   - Flush при завершении (обязательный финальный flush)

## План реализации

### Этап 1: Анализ и документирование текущего состояния ✅

**Цель:** Зафиксировать текущее состояние и определить, что уже выполнено

**Задачи:**
1. ✅ Проверить наличие `LogManager` в `src/runtime/log_manager.py`
2. ✅ Проверить интеграцию `LogManager` в `src/runtime/loop.py`
3. ✅ Проверить отсутствие flush на каждом тике в hot-path
4. ✅ Найти все прямые вызовы `_flush_log_buffer()` в коде
5. ✅ Оценить необходимость каждого прямого вызова

**Результат:** Этот документ (план выполнения)

### Этап 2: Анализ прямых вызовов в `SelfState`

**Цель:** Определить, какие прямые вызовы `_flush_log_buffer()` оправданы

**Задачи:**
1. Проанализировать каждый прямой вызов `_flush_log_buffer()` в `SelfState`:
   - `_log_change()` - защита от переполнения
   - `enable_logging()` - сброс при включении
   - `disable_logging()` - сохранение перед отключением
   - `set_log_buffer_size()` - защита при изменении размера

2. Определить критерии оправданности:
   - Защита от потери данных (критично)
   - Консистентность состояния (желательно)
   - Производительность (не критично для редких операций)

3. Принять решение:
   - Оставить защитные flush в `SelfState`
   - Или интегрировать `LogManager` в методы `SelfState`

**Результат:** Решение о необходимости изменений в `SelfState`

### Этап 3: Документирование архитектуры

**Цель:** Задокументировать разделение ответственности между `SelfState` и `LogManager`

**Задачи:**
1. Обновить документацию `docs/components/self-state.md`:
   - Описать защитные flush в `SelfState`
   - Уточнить, когда допустимы прямые вызовы `_flush_log_buffer()`

2. Обновить документацию `docs/components/runtime-loop.md`:
   - Уточнить роль `LogManager` в управлении flush
   - Описать взаимодействие между `SelfState` и `LogManager`

3. Обновить ADR `docs/adr/005-runtime-loop-managers.md`:
   - Добавить раздел о разделении ответственности для логирования

**Результат:** Обновленная документация

### Этап 4: Проверка тестов

**Цель:** Убедиться, что все тесты проходят и покрывают новую архитектуру

**Задачи:**
1. Запустить существующие тесты:
   ```bash
   pytest src/test/test_runtime_loop_managers.py -v
   pytest src/test/ -v
   ```

2. Проверить покрытие тестами:
   - `LogManager` покрыт тестами
   - Отсутствие flush на каждом тике проверяется тестами
   - Защитные flush в `SelfState` работают корректно

**Результат:** Все тесты проходят

### Этап 5: Создание отчета

**Цель:** Задокументировать выполнение задачи

**Задачи:**
1. Создать отчет в `docs/results/last_result.md`:
   - Описать текущее состояние
   - Перечислить выполненные изменения
   - Указать оставшиеся вопросы (если есть)

**Результат:** Отчет о выполнении задачи

## Критерии приемки

### Функциональные критерии

✅ **FC1:** В `src/runtime/loop.py` больше нет flush на каждом тике в `finally`
✅ **FC2:** Flush управляется через `LogManager` с политикой flush
✅ **FC3:** Защитные flush в `SelfState` работают корректно (при переполнении буфера, при изменении конфигурации)

### Нефункциональные критерии

✅ **NFC1:** Hot-path не выполняет регулярный дисковый I/O на каждом тике
✅ **NFC2:** Разделение ответственности между `SelfState` и `LogManager` задокументировано
✅ **NFC3:** Все существующие тесты проходят

## Риски и митигация

### Риск 1: Потеря логов из-за менее частого flush

**Вероятность:** Низкая  
**Влияние:** Среднее

**Митигация:**
- Защитный flush при переполнении буфера предотвращает потерю данных
- Flush при завершении обязателен
- Flush перед снапшотом обеспечивает консистентность

### Риск 2: Дублирование логики flush

**Вероятность:** Средняя  
**Влияние:** Низкое

**Митигация:**
- Защитные flush в `SelfState` - это защитные механизмы, не политика
- Политические flush через `LogManager` - это управление производительностью
- Разделение ответственности четко задокументировано

## Выводы

Основная цель задачи **уже выполнена**:
- ✅ `LogManager` создан и интегрирован
- ✅ Flush на каждом тике убран из hot-path
- ✅ Flush управляется через политику `LogManager`

**Оставшиеся вопросы:**
- Защитные flush в `SelfState` оправданы и должны остаться
- Необходимо задокументировать разделение ответственности
- Все тесты должны проходить

**Рекомендация:** Задача выполнена, требуется только документирование и проверка тестов.
