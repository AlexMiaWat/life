# План выполнения задачи: "Добавить внутренние ритмы жизни (день/ночь) независимо от внешнего мира"

## Контекст задачи

В проекте Life уже реализована базовая система субъективного времени и начальная версия циркадного ритма. Задача требует расширения внутренних ритмов жизни, которые работают независимо от внешнего времени, создавая ощущение "биологической жизни" системы.

## Анализ текущего состояния

### Уже реализовано:
- **Субъективное время** (`src/runtime/subjective_time.py`) - система внутреннего восприятия времени
- **Базовый циркадный ритм** (`SelfState.update_circadian_rhythm()`) - 24-часовой цикл с влиянием на:
  - `recovery_efficiency` (эффективность восстановления)
  - `stability_modifier` (модификатор стабильности)

### Текущие ограничения:
- Циркадный ритм влияет только на восстановление и стабильность
- Нет других биологических ритмов
- Ритмы не влияют на принятие решений и поведение
- Отсутствует мониторинг состояния ритмов

## План реализации

### Этап 1: Проектирование системы ритмов
**Цель:** Создать архитектуру для внутренних биологических ритмов

**Задачи:**
1. Анализ требований к системе ритмов
2. Проектирование классов и интерфейсов
3. Определение влияния ритмов на поведение системы

### Этап 2: Расширение циркадного ритма
**Цель:** Улучшить существующий 24-часовой цикл

**Задачи:**
1. Добавить влияние на активность и бодрость
2. Реализовать переходы день/ночь с плавными изменениями
3. Добавить влияние на восприимчивость к событиям

### Этап 3: Добавление дополнительных ритмов
**Цель:** Реализовать другие биологические ритмы

**Задачи:**
1. **Ультрадианный ритм** (90-120 минут) - циклы внимания и отдыха
2. **Циркасемидианный ритм** (12 часов) - дополнительный цикл активности
3. **Циркадианный ритм** (24 часа) - основной цикл день/ночь

### Этап 4: Интеграция в поведение системы
**Цель:** Сделать ритмы частью принятия решений

**Задачи:**
1. Влияние на Decision (предпочтение определенных паттернов в разное время)
2. Влияние на Action (энергия для действий в зависимости от ритма)
3. Влияние на Meaning (интерпретация событий в контексте ритма)

### Этап 5: Мониторинг и отладка
**Цель:** Добавить визуализацию состояния ритмов

**Задачи:**
1. Обновить консольный мониторинг
2. Добавить метрики ритмов в API
3. Создать инструменты для анализа ритмов

### Этап 6: Тестирование
**Цель:** Обеспечить надежность системы ритмов

**Задачи:**
1. Unit-тесты для каждого ритма
2. Интеграционные тесты с runtime loop
3. Тесты на независимость от внешнего времени

### Этап 7: Документация
**Цель:** Документировать систему внутренних ритмов

**Задачи:**
1. Обновить ADR по субъективному времени
2. Создать документацию по ритмам
3. Добавить примеры использования

## Технические решения

### Архитектура
```
src/rhythms/
├── __init__.py
├── circadian_rhythm.py      # Циркадный ритм (24ч)
├── ultradian_rhythm.py      # Ультрадианный ритм (90-120мин)
├── rhythm_manager.py        # Менеджер всех ритмов
└── rhythm_types.py          # Типы и интерфейсы ритмов
```

### Интеграция в SelfState
- Добавить поле `rhythm_manager: RhythmManager`
- Метод `update_internal_rhythms(dt: float)` для обновления всех ритмов
- Свойства для доступа к текущему состоянию ритмов

### Влияние на компоненты
- **MeaningEngine**: Учет ритма при оценке значимости
- **Decision**: Предпочтение паттернов в зависимости от ритма
- **Action**: Доступность действий в зависимости от ритма
- **Learning/Adaptation**: Обучение паттернам поведения по ритмам

## Критерии успеха

1. **Функциональность:** Система ритмов работает независимо от системного времени
2. **Влияние:** Ритмы влияют на поведение системы (активность днем, отдых ночью)
3. **Мониторинг:** Состояние ритмов отображается в интерфейсе
4. **Тестируемость:** Полное покрытие тестами
5. **Документация:** Полная документация архитектуры

## Риски и mitigation

1. **Производительность:** Ритмы обновляются каждый тик
   - Mitigation: Оптимизация вычислений, кэширование значений

2. **Сложность:** Увеличение сложности системы
   - Mitigation: Четкое разделение ответственности, хорошая документация

3. **Тестирование:** Сложность тестирования временных зависимостей
   - Mitigation: Mock объектов для времени, property-based тесты

## Следующие шаги

1. Начать с проектирования архитектуры (этап 1)
2. Реализовать расширенный циркадный ритм (этап 2)
3. Добавить интеграцию в runtime loop
4. Протестировать базовую функциональность
5. Добавить дополнительные ритмы и влияние на поведение

## Оценка трудоемкости

- **Этап 1:** 2-3 дня (проектирование)
- **Этап 2:** 3-4 дня (расширение циркадного ритма)
- **Этап 3:** 4-5 дней (дополнительные ритмы)
- **Этап 4:** 3-4 дня (интеграция в поведение)
- **Этапы 5-7:** 4-5 дней (мониторинг, тесты, документация)

**Итого:** 16-24 дней разработки
