# План выполнения: Добавить в `SelfState` поля субъективного времени и коэффициенты модуляции

> **Задача:** “Добавить в `SelfState` поля субъективного времени (например `subjective_age`/`subjective_time`) и коэффициенты модуляции”
> **Контекст:** задача #3 “Субъективное время (Subjective Time) как сквозная ось” из `todo/GENERATED_20260120_20260120_094041.md`
> **Источник требований/модели:** `docs/planning/task_3_20260120_094041.md`
> **Дата создания:** 2026-01-20
> **ID:** task_1768899532

## 1. Контекст и границы текущего шага

Текущий шаг покрывает **только изменения структуры `SelfState`**:

- добавление накопленного субъективного времени (минимум: `subjective_time`);
- добавление **параметров (коэффициентов) модуляции** для расчёта субъективного хода времени в runtime loop;
- сохранение обратной совместимости snapshots (старые файлы должны загружаться).

В этом шаге **не** реализуем:

- сам расчёт `subjective_time` в `src/runtime/loop.py` (это следующий пункт TODO);
- протяжку `subjective_timestamp` в `MemoryEntry`;
- изменения мониторинга.

## 2. Что говорит документация проекта (обязательные инварианты)

Из `docs/planning/task_3_20260120_094041.md`:

- **Субъективное время — метрика, не управление** (не вводить оптимизационные контуры, ADR 001).
- **Единая точка движения времени**: обновление времени происходит в Runtime Loop (ADR 002).
- **Инварианты модели** (для будущей реализации расчёта):
  - монотонность: \(dS \ge 0\);
  - ограничение скорости: \(rate \in [r_{min}, r_{max}]\);
  - прозрачность и детерминированность формулы.

## 3. Предлагаемые поля `SelfState` (минимально достаточный набор)

### 3.1. Новые поля данных

- `subjective_time: float = 0.0`
  - накопленное субъективное время (секунды по внутренней шкале).

Опционально (если нужно отдельное “читаемое имя” без дублирования данных):

- `subjective_age` как **property/alias** к `subjective_time` (предпочтительно, чтобы не хранить два числа).

### 3.2. Коэффициенты модуляции (параметры будущей модели)

С учётом документации (rate clamp + прозрачность) зафиксировать в `SelfState`:

- `subjective_time_base_rate: float = 1.0`
- `subjective_time_min_rate: float = 0.5`
- `subjective_time_max_rate: float = 2.0`
- `subjective_time_alpha: float = 0.2`
  - коэффициент “мягкости/сглаживания” (если в следующем шаге будет вводиться EMA/инерция для rate; иначе может быть зарезервирован).

Примечание: точные дефолты допустимо скорректировать на этапе интеграции в loop, но **поля и их семантика** должны быть определены сейчас.

## 4. Где и как вносить изменения в код

### 4.1. Основной файл

- `src/state/self_state.py`
  - добавить новые поля в dataclass `SelfState`;
  - убедиться, что `apply_delta()` сможет обновлять `subjective_time` (это числовое поле, ограничений по дельтам нет);
  - решить вопрос валидации:
    - минимум: добавить `subjective_time` в ветку неотрицательных полей (`>= 0.0`);
    - для коэффициентов: можно оставить без clamp на этом шаге, но лучше защитить от очевидных некорректных значений (например, `min_rate >= 0`, `max_rate >= min_rate`, `alpha` в \([0,1]\)).

### 4.2. Snapshot-совместимость

- `save_snapshot()`:
  - убедиться, что новые поля попадут в `asdict(state)` и сохранятся (по умолчанию да);
  - проверить, что сериализация `memory` не “срежет” новые поля (она отдельно перезаписывает только `snapshot["memory"]`).
- `load_snapshot()` и `SelfState.load_latest_snapshot()`:
  - текущая логика уже игнорирует неизвестные поля и использует `SelfState.__dataclass_fields__`;
  - убедиться, что при загрузке старого snapshot без новых полей `SelfState(**data)` корректно выставит дефолты.

## 5. Тесты (что добавить именно под этот шаг)

Рекомендуемые проверки в `src/test/test_state.py` (или отдельным маленьким тест-файлом):

- **Дефолты**: `SelfState().subjective_time == 0.0` и присутствуют коэффициенты модуляции.
- **Валидация/границы** (если добавляется):
  - `subjective_time` не становится отрицательным при прямом присваивании/дельтах;
  - некорректные коэффициенты либо приводятся к допустимым (clamp), либо вызывают `ValueError` (выбрать поведение и закрепить тестом).
- **Snapshot roundtrip**:
  - `save_snapshot` → `load_snapshot` сохраняет значения новых полей;
  - загрузка “старого” snapshot без этих полей выставляет дефолты (можно сгенерировать dict без ключей и пройти через `SelfState(**data)`/`load_snapshot` с подготовленным файлом).

## 6. Критерии приемки для текущего шага

- ✅ В `SelfState` добавлены `subjective_time` и коэффициенты модуляции (поля существуют и имеют дефолты).
- ✅ Snapshot-сохранение/загрузка совместимы назад: старые snapshots загружаются без ошибок, новые сохраняют поля.
- ✅ Добавлены/обновлены тесты, фиксирующие дефолты и (если введена) валидацию новых полей.

---

**Автор плана:** AI Agent (Project Executor)
