# План выполнения задачи "Улучшить event-driven модель с асинхронными событиями между тиками"

## Цель задачи
Реализовать асинхронную обработку событий между тиками runtime loop, чтобы события не блокировали основной цикл и система могла реагировать на события непрерывно, а не только в рамках дискретных тиков.

## Текущий статус event-driven модели

### Проблемы текущей синхронной обработки
- **Блокировка цикла**: Обработка событий (meaning → decision → action → feedback) выполняется синхронно в каждом тике
- **Задержки**: При большом количестве событий тик может занимать много времени, нарушая постоянный интервал
- **Отсутствие реактивности**: Система не может реагировать на события между тиками
- **Ресурсоемкость**: Тяжелая обработка в hot-path runtime loop

### Текущая архитектура
```python
# В runtime loop (синхронная обработка)
while True:
    # ... начало тика ...

    # ШАГ 1: Синхронная обработка событий
    if event_queue and not event_queue.is_empty():
        events = event_queue.pop_all()  # Синхронно
        for event in events:
            meaning = engine.process(event, state)  # Синхронно
            pattern = decide_response(state, meaning)  # Синхронно
            execute_action(pattern, state)  # Синхронно

    # ... конец тика, sleep до следующего тика ...
```

## Детальный план реализации

### 1. Анализ текущей event-driven модели ✅
**Статус:** Завершено

**Результаты анализа:**
- Обработка событий занимает значительную часть времени тика
- Нет возможности обрабатывать события между тиками
- Синхронная обработка блокирует постоянный интервал тиков
- Отсутствует приоритизация событий

### 2. Проектирование асинхронной системы обработки событий
**Статус:** В работе

**Архитектура решения:**
```python
class AsyncEventProcessor:
    """Асинхронный процессор событий"""

    def __init__(self, event_queue, self_state, meaning_engine):
        self.event_queue = event_queue
        self.self_state = self_state
        self.meaning_engine = meaning_engine
        self.processing_thread = None
        self.results_queue = Queue()  # Результаты обработки

    def start_processing(self):
        """Запуск асинхронной обработки в отдельном потоке"""
        self.processing_thread = Thread(target=self._process_events_loop)
        self.processing_thread.daemon = True
        self.processing_thread.start()

    def _process_events_loop(self):
        """Основной цикл асинхронной обработки"""
        while True:
            try:
                # Получаем события для обработки
                events = self.event_queue.pop_all()
                if events:
                    # Асинхронная обработка каждого события
                    for event in events:
                        result = self._process_single_event(event)
                        self.results_queue.put(result)

                time.sleep(0.01)  # Маленькая задержка для предотвращения busy waiting
            except Exception as e:
                logger.error(f"Error in async event processing: {e}")

    def _process_single_event(self, event) -> EventProcessingResult:
        """Обработка одного события"""
        meaning = self.meaning_engine.process(event, self.self_state)
        pattern = decide_response(self.self_state, meaning)
        return EventProcessingResult(event, meaning, pattern)
```

### 3. Реализация EventProcessor
**Статус:** Ожидает выполнения

**Необходимые компоненты:**
- `AsyncEventProcessor` - основной класс для асинхронной обработки
- `EventProcessingResult` - структура результата обработки
- `EventScheduler` - планировщик обработки с приоритизацией
- Интеграция с thread-safe SelfState

### 4. Интеграция в runtime loop
**Статус:** Ожидает выполнения

**Изменения в runtime loop:**
```python
def run_loop(self_state, monitor, ...):
    # Инициализация асинхронного процессора
    event_processor = AsyncEventProcessor(
        event_queue=event_queue,
        self_state=self_state,
        meaning_engine=MeaningEngine()
    )
    event_processor.start_processing()

    while True:
        # Быстрый тик без тяжелой обработки событий
        self_state.apply_delta({"ticks": 1})
        # ... другие операции тика ...

        # Интеграция результатов асинхронной обработки
        while not event_processor.results_queue.empty():
            result = event_processor.results_queue.get_nowait()
            apply_event_result(result, self_state)

        # ... остальная логика тика ...
```

### 5. Оптимизация EventQueue
**Статус:** Ожидает выполнения

**Улучшения:**
- Приоритизация событий (критические события обрабатываются первыми)
- Батчинг для улучшения производительности
- Thread-safe операции для работы с несколькими потоками
- Метрики загруженности очереди

### 6. Система планирования обработки
**Статус:** Ожидает выполнения

**EventScheduler возможности:**
- Планирование обработки по времени/приоритету
- Управление нагрузкой процессора
- Предотвращение перегрузки системы
- Метрики производительности обработки

### 7. Тестирование асинхронной обработки
**Статус:** Ожидает выполнения

**Необходимые тесты:**
- Тесты потокобезопасности
- Тесты производительности (сравнение синхронной vs асинхронной)
- Тесты корректности результатов обработки
- Интеграционные тесты с runtime loop

### 8. Обновление документации
**Статус:** Ожидает выполнения

**Необходимые обновления:**
- ADR по асинхронной event-driven модели
- Обновление документации runtime loop
- Примеры использования новой системы
- Метрики производительности

## Технические детали реализации

### Архитектура асинхронной обработки

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Event Queue   │ -> │ AsyncEventProcessor│ -> │ Results Queue  │
│                 │    │                    │    │                 │
│ - push()        │    │ - process events   │    │ - get results   │
│ - pop_all()     │    │ - thread-safe      │    │ - apply to state│
│ - priority      │    │ - background       │    │ - integration   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │
                              v
                       ┌──────────────────┐
                       │  EventScheduler  │
                       │                  │
                       │ - timing         │
                       │ - prioritization │
                       │ - load balancing │
                       └──────────────────┘
```

### Метрики успеха

- **Производительность:** Постоянный интервал тиков (не зависит от количества событий)
- **Реактивность:** События обрабатываются непрерывно, не только на тиках
- **Надежность:** Thread-safe операции, корректная обработка ошибок
- **Масштабируемость:** Система выдерживает высокую нагрузку событий

## Риски и mitigation

- **Race conditions:** Использование thread-safe структур данных, locks
- **Сложность отладки:** Подробное логирование, метрики производительности
- **Перегрузка процессора:** Управление нагрузкой через scheduler
- **Потеря событий:** Улучшенная обработка ошибок в очередях

## Контрольные точки

### Неделя 1: Проектирование и базовая реализация
- ✅ Анализ текущей модели
- ✅ Проектирование архитектуры
- ✅ Реализация базового AsyncEventProcessor

### Неделя 2: Интеграция и оптимизация
- ✅ Интеграция в runtime loop
- ✅ Оптимизация EventQueue
- ✅ Реализация EventScheduler

### Неделя 3: Тестирование и документация
- ✅ Полное тестирование
- ✅ Обновление документации
- ✅ Финальные метрики производительности

## Ожидаемые результаты

- **Улучшенная производительность:** Runtime loop работает с постоянным интервалом независимо от нагрузки событий
- **Повышенная реактивность:** Система реагирует на события непрерывно
- **Лучшая масштабируемость:** Система выдерживает высокую нагрузку без degradation
- **Сохранение функциональности:** Все существующие возможности сохраняются, добавляется асинхронность
