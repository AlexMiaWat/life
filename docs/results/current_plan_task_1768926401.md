# План выполнения задачи: Субъективное время как сквозная ось жизни

## Обзор задачи
Внедрение субъективного времени как метрики, которая дополняет физическое время и становится "сквозной осью" в системе Life. Субъективное время должно быть монотонным, детерминированным и влиять на различные подсистемы без нарушения архитектурных принципов.

## Текущий статус реализации
Анализ показал, что значительная часть функциональности уже реализована:

✅ **Уже реализовано:**
- Поля субъективного времени в SelfState (`subjective_time`, параметры модуляции)
- Модуль `src/runtime/subjective_time.py` с моделями расчета
- Интеграция расчета субъективного времени в runtime loop
- Полные unit-тесты для модели субъективного времени

❌ **Требует реализации:**
- Поле `subjective_timestamp` в MemoryEntry
- Запись субъективного времени при создании записей памяти
- Обновление мониторинга для отображения physical vs subjective time
- Интеграционные тесты для проверки работы с памятью

## План реализации

### Этап 1: Расширение MemoryEntry (1-2 часа)
**Цель:** Добавить субъективную временную метку в структуру памяти

- Добавить поле `subjective_timestamp: Optional[float] = None` в `MemoryEntry`
- Обеспечить обратную совместимость сериализации (старые записи без поля должны загружаться)
- Обновить методы `ArchiveMemory` для работы с новым полем

### Этап 2: Интеграция в Runtime Loop (2-3 часа)
**Цель:** Записывать субъективное время при создании всех записей памяти

- Обновить создание обычных MemoryEntry в loop (строка ~338 в `loop.py`)
- Обновить создание Feedback-записей (строки ~256-270 в `loop.py`)
- Убедиться, что `subjective_timestamp` записывается после обновления `subjective_time`

### Этап 3: Обновление мониторинга (1-2 часа)
**Цель:** Показывать физическое и субъективное время в интерфейсе

- Обновить консольный вывод в `src/monitor/console.py` для показа обоих времен
- Добавить `subjective_time` в логирование `tick_log.jsonl`
- Опционально добавить расчет и показ `subjective_rate`

### Этап 4: Тестирование и валидация (2-3 часа)
**Цель:** Убедиться в корректной работе всей системы

- Добавить интеграционные тесты для проверки создания MemoryEntry с subjective_timestamp
- Проверить обратную совместимость загрузки старых snapshot/memory файлов
- Протестировать мониторинг с новыми полями
- Запустить полный набор тестов

### Этап 5: Документация и финализация (1 час)
**Цель:** Завершить задачу с полной документацией

- Обновить документацию в коде (docstrings)
- Проверить соответствие всем критериям приемки из технического задания
- Создать отчет о выполнении

## Риски и меры mitigации

### Риск: Нарушение обратной совместимости
**Вероятность:** Средняя
**Митигация:**
- Использовать `Optional[float] = None` для новых полей
- Добавить валидацию при загрузке snapshot/memory
- Тесты на загрузку старых данных

### Риск: Несоответствие архитектурным принципам
**Вероятность:** Низкая
**Митигация:**
- Субъективное время остается только метрикой, не используется для управления
- Все обновления следуют слоям: Runtime → Memory → Monitor

### Риск: Проблемы с производительностью
**Вероятность:** Низкая
**Митигация:**
- Субъективное время рассчитывается только в runtime loop (не в hot-path)
- Новые поля добавляются только в память, не в критические структуры

## Критерии приемки
- ✅ MemoryEntry содержит subjective_timestamp
- ✅ Runtime loop записывает субъективное время в новые записи
- ✅ Мониторинг показывает physical и subjective time
- ✅ Сохранена обратная совместимость
- ✅ Проходят все существующие тесты
- ✅ Добавлены интеграционные тесты

## Оценка трудоемкости
- **Общая оценка:** 7-11 часов
- **Приоритет:** Высокий (важная сквозная функциональность)
- **Блокеры:** Нет (независимая задача)

## Следующие шаги
1. Начать с Этапа 1: расширение MemoryEntry
2. Провести промежуточное тестирование после каждого этапа
3. Завершить интеграционными тестами и документацией