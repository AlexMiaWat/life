# План выполнения: Убрать `print()` из hot-path runtime (заменить на `logger` + уровни, выключаемые по умолчанию)

> **Задача:** Убрать `print()` из hot-path runtime (заменить на `logger` + уровни, выключаемые по умолчанию)
> **Контекст:** Runtime Loop (`src/runtime/loop.py`) — горячий путь обработки событий и тиков
> **Дата создания:** 2026-01-20
> **ID:** task_1768899278

## 1. Контекст (что есть сейчас)

- **Runtime loop**: `src/runtime/loop.py` уже использует `logging.getLogger(__name__)` (есть `logger.warning/error`), но в горячем пути остались `print()`.
- **Документация по Runtime Loop**: `docs/components/runtime-loop.md` фиксирует, что loop “бесконечный”, ошибки не должны останавливать жизнь и должны логироваться.
- **Документация по диагностике**: `docs/development/debugging.md` разделяет мониторинг (реалтайм) и логирование (история/ошибки) и показывает базовый паттерн `logging.basicConfig(level=logging.DEBUG)` как опциональный режим отладки.

## 2. Цель и ограничения

### Цель

- Убрать прямые `print()` из hot-path runtime, заменив их на структурированное логирование через `logger` с корректными уровнями.

### Ограничения (важно сохранить)

- **По умолчанию “лишний шум” выключен**: сообщения отладочного характера должны уходить в `DEBUG` (и быть отключены при стандартном уровне `INFO`/`WARNING`).
- **Ошибки должны оставаться видимыми**: исключения логируем через `logger.exception(...)`/`logger.error(..., exc_info=True)`.
- **Нельзя ухудшить производительность**: избегать дорогого форматирования строк, когда уровень лога выключен (использовать параметризованное логирование или `logger.isEnabledFor(...)` вокруг тяжелых вычислений/`len()` больших структур).
- **Мониторинг не ломаем**: консольный “heartbeat” (monitor) — отдельный канал; задача про runtime hot-path и `print()` именно в нем.

## 3. Инвентаризация `print()` в hot-path (что заменить)

Кандидаты в `src/runtime/loop.py`:

- `"[LOOP] Queue not empty, size=..."` — отладка очереди событий.
- `"[LOOP] POPPED ... events"` — отладка батча событий.
- `"[LOOP] Interpreting event: type=..., intensity=..."` — отладка обработки конкретного события.
- `"[LOOP] Activated ... memories ..."` — отладка активации памяти.
- `"[LOOP] After interpret: energy=..., stability=..."` — отладка результата интерпретации.
- `"[LOOP] Заархивировано ... записей памяти"` — технический лог периодической архивации.
- `"[LOOP] Слабость: штрафы ..."` — диагностический лог метаболизма/penalty.
- `print(f"Ошибка в цикле: {e}")` + `traceback.print_exc()` — обработка ошибок тика.

## 4. План работ (по шагам)

### Шаг 1: Определить карту уровней логирования

- **DEBUG** (выключено по умолчанию): все “шумные” сообщения из горячего пути (очередь, popped, interpreting, activated, after interpret, penalty).
- **INFO** (по необходимости): редкие, действительно полезные операционные события (например, “архивировано N” — если это важно видеть без включения DEBUG; иначе тоже DEBUG).
- **WARNING/ERROR**: некорректные/неожиданные состояния, деградация и ошибки.
- **EXCEPTION**: для `except Exception` в тике — использовать `logger.exception("Ошибка в цикле")` вместо `print + traceback`.

### Шаг 2: Заменить `print()` на `logger.*` в `src/runtime/loop.py`

- Для каждого `print()` выбрать уровень из карты выше.
- Использовать параметризованные сообщения:
  - `logger.debug("[LOOP] Queue not empty, size=%s", event_queue.size())`
  - `logger.debug("[LOOP] Interpreting event: type=%s, intensity=%s", event.type, event.intensity)`
- Для потенциально “дорогих” вычислений:
  - `if logger.isEnabledFor(logging.DEBUG): ...`

### Шаг 3: Проверить “уровни по умолчанию”

- Найти, где задается `logging.basicConfig(...)`/конфигурация логирования в точке входа (`src/main_server_api.py`).
- Убедиться, что по умолчанию уровень не `DEBUG` (иначе горячий путь начнет шуметь), и что включение DEBUG остаётся явным (например, через флаг/настройку).

### Шаг 4: Тесты/инварианты

- Обновить/добавить тест(ы), если в репозитории есть проверки на вывод (или если текущие тесты используют `-s` и завязаны на `print()`).
- Минимально: убедиться, что замена не влияет на бизнес-логику (тесты runtime/интеграции должны проходить).

### Шаг 5: Документация (при необходимости)

- Если появится новый флаг/настройка для уровня логов — отразить его в `docs/development/debugging.md` (коротко: как включить DEBUG, не трогая мониторинг).

## 5. Критерии приемки

- ✅ В `src/runtime/loop.py` больше нет `print()` в горячем пути.
- ✅ Ошибки тика логируются через `logger.exception(...)` или `logger.error(..., exc_info=True)`, без `traceback.print_exc()`.
- ✅ Отладочные сообщения находятся на уровне `DEBUG` и не видны при дефолтном уровне логирования.
- ✅ Тесты проходят, поведение runtime не меняется (кроме вывода).

---

**Автор плана:** AI Agent (Project Executor)
