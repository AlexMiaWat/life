# План реализации: Механизм эха памяти с спонтанными всплытиями воспоминаний

## Дата создания: 2026-01-21

## Цель задачи
Реализовать механизм, который позволит воспоминаниям "оживать" не только по внешним триггерам (событиям), но и спонтанно, создавая эффект "эха памяти" - повторных или отложенных всплытий воспоминаний.

## Архитектурный анализ

### Текущая система памяти
- **Memory**: Хранит эпизодическую память в виде MemoryEntry с event_type, significance, timestamp
- **Activation**: Активирует воспоминания только по совпадению event_type с текущим событием
- **Runtime Loop**: Вызывает активацию только при обработке событий (meaning.significance > 0)

### Проблематика
- Воспоминания активируются только реактивно (по событиям)
- Нет механизма спонтанной активации
- Нет "эха" - повторных всплытий уже активированных воспоминаний
- Нет учета внутренних состояний системы для активации

## Дизайн механизма эха памяти

### Основные компоненты

#### 1. Спонтанная активация (Spontaneous Activation)
- Периодическая активация воспоминаний без внешнего триггера
- Интервал: каждые 20-50 тиков (настраивается)
- Критерии выбора: высокая значимость + недавние воспоминания + разнообразие типов

#### 2. Эхо-активация (Echo Activation)
- Повторная активация уже активированных воспоминаний через время
- Задержка: 10-30 тиков после первичной активации
- Ослабление: каждая последующая активация слабее предыдущей
- Ограничение: максимум 2-3 эхо-активации на воспоминание

#### 3. Активация по внутренним состояниям (Internal State Activation)
- Активация на основе энергии, стабильности, субъективного времени
- Высокая энергия → более частые спонтанные активации
- Низкая стабильность → активация "старых" воспоминаний для контекста
- Ускоренное субъективное время → более интенсивные активации

### Параметры управления

#### Новые поля в SelfState
```python
# Параметры механизма эха
echo_memory_enabled: bool = True
echo_activation_interval: int = 30  # тиков между спонтанными активациями
echo_max_simultaneous: int = 2      # максимум одновременно активированных эхо
echo_decay_factor: float = 0.7     # ослабление при эхо-активации
echo_energy_threshold: float = 0.3 # минимум энергии для спонтанной активации

# Состояние механизма эха
last_echo_activation_tick: int = 0
echo_activation_count: int = 0
active_echo_memories: List[Dict] = []  # отслеживание активных эхо
```

#### Расширенная activated_memory
```python
activated_memory: List[MemoryEntry]  # существующие + новые эхо-воспоминания
echo_metadata: Dict = {              # метаданные активации
    "activation_type": "event|spontaneous|echo|internal",
    "activation_time": timestamp,
    "echo_level": 0,                 # уровень эха (0=первичная, 1+=эхо)
    "source_event_type": str         # тип события-триггера
}
```

## План реализации

### Этап 1: Расширение модуля activation.py
**Файл:** `src/activation/activation.py`

#### Новые функции:
- `spontaneous_memory_activation(memory, self_state) -> List[MemoryEntry]`
  - Выбирает воспоминания для спонтанной активации
  - Критерии: значимость > 0.5, недавние (последние 100 записей), разнообразие типов

- `echo_memory_activation(current_activated, self_state) -> List[MemoryEntry]`
  - Создает эхо-активацию из текущих activated_memory
  - Ослабляет значимость на echo_decay_factor
  - Ограничивает количество эхо

- `internal_state_activation(memory, self_state) -> List[MemoryEntry]`
  - Активация на основе внутренних состояний
  - Энергия > threshold → спонтанная активация
  - Стабильность < 0.5 → активация старых воспоминаний

#### Модификация существующей функции:
- `activate_memory()` получает параметр activation_type для логирования

### Этап 2: Интеграция в SelfState
**Файл:** `src/state/self_state.py`

- Добавить новые поля для параметров эха
- Расширить activated_memory метаданными
- Добавить методы для управления эхо-состоянием

### Этап 3: Интеграция в Runtime Loop
**Файл:** `src/runtime/loop.py`

#### Новые вызовы в основном цикле:
```python
# Спонтанная активация (периодически)
if self_state.ticks % self_state.echo_activation_interval == 0:
    if self_state.energy > self_state.echo_energy_threshold:
        spontaneous = spontaneous_memory_activation(self_state.memory, self_state)
        if spontaneous:
            self_state.activated_memory.extend(spontaneous)
            # Логирование спонтанной активации

# Эхо-активация (для существующих activated_memory)
if self_state.activated_memory and self_state.ticks % 15 == 0:  # каждые 15 тиков
    echo_memories = echo_memory_activation(self_state.activated_memory, self_state)
    if echo_memories:
        self_state.activated_memory.extend(echo_memories)
        # Логирование эхо-активации

# Активация по внутренним состояниям (при низкой стабильности)
if self_state.stability < 0.4 and self_state.ticks % 25 == 0:
    internal_activated = internal_state_activation(self_state.memory, self_state)
    if internal_activated:
        self_state.activated_memory.extend(internal_activated)
        # Логирование внутренней активации
```

### Этап 4: Механизм очистки activated_memory
- Очистка устаревших activated_memory (старше N тиков)
- Ограничение общего количества активированных воспоминаний
- Сохранение наиболее значимых

### Этап 5: Тестирование
**Файлы:** `src/test/test_echo_memory.py`

- Unit-тесты для новых функций активации
- Integration-тесты с runtime loop
- Тесты на корректность эхо-эффекта
- Тесты на влияние внутренних состояний

### Этап 6: Мониторинг и логирование
**Файл:** `src/monitor/console.py`

- Отображение количества спонтанно активированных воспоминаний
- Логирование эхо-активаций
- Статистика эффективности механизма эха

## Архитектурные ограничения

### Соблюдение принципов Life
- **Не влияет на поведение**: Эхо-активация только добавляет контекст, не изменяет решения
- **Transient**: activated_memory не сохраняется в snapshot
- **Минимализм**: Простые критерии активации без сложного анализа

### Производительность
- Ограничение количества одновременных активаций
- Эффективные алгоритмы поиска в памяти
- Минимальный overhead в hot-path runtime loop

## Критерии успеха

### Функциональные
- ✅ Спонтанная активация происходит периодически
- ✅ Эхо-активация следует за первичной активацией
- ✅ Активация учитывает внутренние состояния
- ✅ Общее количество activated_memory не превышает лимиты

### Архитектурные
- ✅ Соблюдены принципы минимализма
- ✅ Интеграция не ломает существующий функционал
- ✅ Код соответствует архитектурным ограничениям

### Качественные
- ✅ Реалистичный эффект "эха памяти"
- ✅ Плавная интеграция с субъективным временем
- ✅ Понятное логирование и мониторинг

## Риски и mitigation

### Риск: Перегрузка activated_memory
**Mitigation:** Строгие лимиты и механизм очистки устаревших записей

### Риск: Производительность
**Mitigation:** Оптимизация алгоритмов, ограничение частоты вызовов

### Риск: Нарушение архитектурных принципов
**Mitigation:** Код-ревью на соответствие ограничениям, статические тесты

## Следующие шаги после реализации
1. Тестирование в runtime с различными сценариями
2. Настройка параметров на основе эмпирических данных
3. Мониторинг влияния на общую производительность системы
4. Возможное расширение: более сложные критерии эха-активации

---
*План создан на основе анализа архитектуры Life и требований к механизму эха памяти*