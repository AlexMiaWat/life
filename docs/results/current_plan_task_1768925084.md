# План выполнения: Добавить unit-тесты на корректность делегирования и отсутствие регрессий поведения

**Задача:** Добавить unit-тесты на корректность делегирования и отсутствие регрессий поведения  
**ID задачи:** 1768925084  
**Дата создания:** 2026-01-20  
**Источник:** [todo/GENERATED_20260120_20260120_094041.md](../../todo/GENERATED_20260120_20260120_094041.md)

## Контекст

После рефакторинга `src/runtime/loop.py` (задача 1768916097) были выделены три менеджера:
- `SnapshotManager` - управление снапшотами
- `LogManager` - управление логированием
- `LifePolicy` - политика слабости

Существующие тесты в `test_runtime_loop_managers.py` проверяют:
- Изолированное поведение менеджеров (unit-тесты)
- Интеграцию менеджеров между собой (координация)

**Что отсутствует:**
- Тесты, проверяющие, что `run_loop` действительно делегирует вызовы менеджерам
- Тесты, использующие моки/spy для проверки факта делегирования
- Тесты на отсутствие регрессий поведения после рефакторинга

## Цели задачи

1. **Добавить тесты делегирования из `run_loop`:**
   - Проверить, что `run_loop` вызывает `SnapshotManager.maybe_snapshot()` в нужных местах
   - Проверить, что `run_loop` вызывает `LogManager.maybe_flush()` в нужных фазах
   - Проверить, что `run_loop` использует `LifePolicy.is_weak()` и `weakness_penalty()`

2. **Добавить тесты на отсутствие регрессий:**
   - Проверить, что снапшоты создаются с той же периодичностью
   - Проверить, что flush происходит по расписанию (не на каждом тике)
   - Проверить, что weakness penalties применяются с теми же значениями
   - Проверить ключевые инварианты поведения

## Анализ текущего состояния

### Существующие тесты

**Файл:** `src/test/test_runtime_loop_managers.py`

**Покрытие:**
- ✅ `TestSnapshotManager` (4 теста) - изолированное поведение
- ✅ `TestLogManager` (11 тестов) - изолированное поведение и интеграция
- ✅ `TestLifePolicy` (6 тестов) - изолированное поведение
- ✅ `TestRuntimeLoopDelegation` (4 теста) - интеграция менеджеров, но **не проверяет делегирование из `run_loop`**

**Проблема:** Тесты в `TestRuntimeLoopDelegation` симулируют поведение менеджеров напрямую, но не проверяют, что `run_loop` действительно делегирует менеджерам.

### Что нужно добавить

1. **Тесты делегирования с моками:**
   - Использовать `unittest.mock.Mock` или `unittest.mock.patch` для создания spy-объектов менеджеров
   - Запустить `run_loop` на несколько тиков
   - Проверить, что менеджеры были вызваны с правильными параметрами

2. **Тесты отсутствия регрессий:**
   - Сравнить поведение до и после рефакторинга
   - Проверить ключевые инварианты (периодичность снапшотов, flush, penalties)

## План реализации

### Этап 1: Анализ точек делегирования в `run_loop`

**Цель:** Определить все места, где `run_loop` должен делегировать менеджерам

**Задачи:**
1. Изучить `src/runtime/loop.py` и найти все вызовы менеджеров:
   - `snapshot_manager.maybe_snapshot(self_state)` - строка ~563
   - `log_manager.maybe_flush(self_state, phase="...")` - строки ~560, 567, 572, 584, 588
   - `life_policy.is_weak(self_state)` - строка ~545
   - `life_policy.weakness_penalty(dt)` - строка ~546

2. Определить условия вызова:
   - SnapshotManager: вызывается на каждом тике, но делает снапшот только по периоду
   - LogManager: вызывается в разных фазах (before_snapshot, after_snapshot, tick, exception, shutdown)
   - LifePolicy: вызывается на каждом тике для проверки слабости

**Результат:** Список точек делегирования с условиями вызова

### Этап 2: Добавить тесты делегирования с моками

**Цель:** Проверить, что `run_loop` действительно вызывает менеджеры

**Файл:** `src/test/test_runtime_loop_managers.py`

**Задачи:**

1. **Тест делегирования SnapshotManager:**
   ```python
   def test_run_loop_delegates_to_snapshot_manager(self):
       """Тест: run_loop делегирует вызовы SnapshotManager"""
       # Создать spy для SnapshotManager
       # Запустить run_loop на несколько тиков
       # Проверить, что maybe_snapshot был вызван нужное количество раз
   ```

2. **Тест делегирования LogManager:**
   ```python
   def test_run_loop_delegates_to_log_manager(self):
       """Тест: run_loop делегирует вызовы LogManager в правильных фазах"""
       # Создать spy для LogManager
       # Запустить run_loop на несколько тиков
       # Проверить, что maybe_flush был вызван в правильных фазах
   ```

3. **Тест делегирования LifePolicy:**
   ```python
   def test_run_loop_delegates_to_life_policy(self):
       """Тест: run_loop делегирует проверку слабости LifePolicy"""
       # Создать spy для LifePolicy
       # Запустить run_loop с состоянием слабости
       # Проверить, что is_weak и weakness_penalty были вызваны
   ```

**Результат:** 3 новых теста делегирования

### Этап 3: Добавить тесты отсутствия регрессий

**Цель:** Проверить, что поведение не изменилось после рефакторинга

**Файл:** `src/test/test_runtime_loop_managers.py`

**Задачи:**

1. **Тест периодичности снапшотов:**
   ```python
   def test_snapshot_periodicity_no_regression(self):
       """Тест: снапшоты создаются с той же периодичностью"""
       # Запустить run_loop на N тиков
       # Проверить, что снапшоты создаются каждые snapshot_period тиков
   ```

2. **Тест flush по расписанию:**
   ```python
   def test_flush_schedule_no_regression(self):
       """Тест: flush происходит по расписанию, не на каждом тике"""
       # Запустить run_loop на N тиков
       # Проверить, что flush вызывается реже, чем тики
   ```

3. **Тест weakness penalties:**
   ```python
   def test_weakness_penalties_no_regression(self):
       """Тест: weakness penalties применяются с теми же значениями"""
       # Запустить run_loop с состоянием слабости
       # Проверить, что penalties применяются с правильными значениями
   ```

**Результат:** 3 новых теста отсутствия регрессий

### Этап 4: Добавить интеграционные тесты координации

**Цель:** Проверить координацию между менеджерами в реальном `run_loop`

**Файл:** `src/test/test_runtime_loop_managers.py`

**Задачи:**

1. **Тест координации SnapshotManager и LogManager:**
   ```python
   def test_run_loop_coordinates_snapshot_and_log_managers(self):
       """Тест: run_loop координирует SnapshotManager и LogManager"""
       # Запустить run_loop на несколько тиков
       # Проверить, что flush перед снапшотом происходит перед snapshot
       # Проверить, что flush после снапшота происходит после snapshot
   ```

**Результат:** 1 новый интеграционный тест

### Этап 5: Проверка и запуск тестов

**Цель:** Убедиться, что все тесты проходят

**Задачи:**
1. Запустить новые тесты: `pytest src/test/test_runtime_loop_managers.py -v`
2. Проверить покрытие: убедиться, что тесты покрывают делегирование
3. Проверить существующие тесты: убедиться, что они все еще проходят

**Результат:** Все тесты проходят успешно

## Критерии приемки

### Функциональные критерии

✅ **FC1:** Добавлены тесты делегирования из `run_loop` в менеджеры (минимум 3 теста)

✅ **FC2:** Добавлены тесты отсутствия регрессий поведения (минимум 3 теста)

✅ **FC3:** Тесты используют моки/spy для проверки факта делегирования

✅ **FC4:** Все новые тесты проходят успешно

### Нефункциональные критерии

✅ **NFC1:** Тесты не зависят от деталей реализации менеджеров (используют моки)

✅ **NFC2:** Тесты проверяют поведение, а не реализацию

✅ **NFC3:** Существующие тесты продолжают работать

## Риски и митигация

### Риск 1: Тесты могут быть слишком хрупкими

**Вероятность:** Средняя  
**Влияние:** Среднее

**Митигация:**
- Использовать моки вместо реальных объектов
- Проверять поведение, а не детали реализации
- Тестировать публичный API менеджеров

### Риск 2: Тесты могут быть медленными

**Вероятность:** Низкая  
**Влияние:** Низкое

**Митигация:**
- Использовать короткие интервалы тиков в тестах
- Ограничить количество тиков в тестах
- Использовать `tick_interval=0.01` для быстрого выполнения

### Риск 3: Моки могут не отражать реальное поведение

**Вероятность:** Низкая  
**Влияние:** Среднее

**Митигация:**
- Использовать spy-объекты вместо полных моков где возможно
- Комбинировать unit-тесты с моками и интеграционные тесты без моков
- Проверять ключевые инварианты в интеграционных тестах

## Выводы

Добавление unit-тестов на делегирование и отсутствие регрессий обеспечит:

1. **Уверенность в корректности делегирования:** Тесты докажут, что `run_loop` правильно использует менеджеры
2. **Защиту от регрессий:** Тесты предотвратят случайные изменения поведения
3. **Документацию поведения:** Тесты служат документацией того, как `run_loop` должен работать с менеджерами

Это соответствует принципам проекта:
- **Тестируемость:** Компоненты должны быть легко тестируемыми
- **Надежность:** Изменения не должны ломать существующее поведение
- **Документация как код:** Тесты документируют ожидаемое поведение
