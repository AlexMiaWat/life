# План выполнения задачи: Улучшить индексацию памяти для быстрого поиска

**Дата создания:** 2026-01-21
**ID задачи:** 1768958445
**Приоритет:** Высокий
**Срок выполнения:** 1-2 недели

## Анализ текущей ситуации

### Проблема
Текущая реализация памяти Life не имеет индексации для быстрого поиска. Поиск по типу события (`event_type`) происходит линейным перебором всех записей в памяти, что приводит к:

- **O(N) сложность поиска** - время поиска пропорционально размеру памяти
- **Производительность деградирует** при росте количества записей (текущее ограничение 50, но архив может расти)
- **Блокировка основного потока** при активации памяти в runtime loop

### Текущая реализация поиска
```python
# src/activation/activation.py
def activate_memory(current_event_type: str, memory: List[MemoryEntry], limit: int = 3):
    matching = [entry for entry in memory if entry.event_type == current_event_type]
    matching.sort(key=lambda e: e.meaning_significance, reverse=True)
    return matching[:limit]
```

## Цели улучшения

### Функциональные требования
1. **Быстрый поиск по event_type** - O(1) доступ к записям по типу события
2. **Поддержка сложных запросов** - поиск по нескольким критериям (тип + значимость + временной диапазон)
3. **Индексация архивной памяти** - быстрый поиск в архиве для эхо-всплываний
4. **Автоматическое обновление индекса** - поддержка актуальности при добавлении/удалении записей

### Нефункциональные требования
1. **Производительность** - улучшение времени поиска минимум в 10-100 раз
2. **Память** - разумное потребление памяти индексом (не более 2x от данных)
3. **Надежность** - корректность индекса при всех операциях изменения памяти
4. **Обратная совместимость** - сохранение существующего API

## Архитектура решения

### Структура индекса
```python
class MemoryIndex:
    # Инвертированный индекс: event_type -> список записей
    event_index: Dict[str, List[MemoryEntry]]

    # Индекс по значимости: event_type -> отсортированный список по significance
    significance_index: Dict[str, List[MemoryEntry]]

    # Временной индекс: timestamp -> список записей (для диапазонных запросов)
    time_index: SortedDict[float, List[MemoryEntry]]

    # LRU кэш для частых запросов
    query_cache: OrderedDict[str, List[MemoryEntry]]
```

### Интеграция в Memory класс
```python
class Memory(list):
    def __init__(self, ...):
        super().__init__()
        self._index = MemoryIndex()

    def append(self, item):
        super().append(item)
        self._index.add_entry(item)  # Обновление индекса

    def remove(self, item):
        super().remove(item)
        self._index.remove_entry(item)  # Обновление индекса

    def search_by_event_type(self, event_type: str, limit: int = None) -> List[MemoryEntry]:
        return self._index.get_by_event_type(event_type, limit)
```

## План реализации

### Этап 1: Анализ и проектирование (1-2 дня)
- [ ] Изучить текущий код поиска в activation.py
- [ ] Проанализировать паттерны использования памяти в runtime loop
- [ ] Спроектировать структуру индекса с учетом ограничений памяти
- [ ] Определить API новых методов поиска

### Этап 2: Реализация базового индекса (2-3 дня)
- [ ] Создать класс MemoryIndex с базовыми методами
- [ ] Реализовать индексацию по event_type (инвертированный индекс)
- [ ] Интегрировать индекс в класс Memory
- [ ] Обеспечить автоматическое обновление индекса при изменениях

### Этап 3: Расширенные возможности поиска (2-3 дня)
- [ ] Добавить поиск по нескольким критериям (тип + значимость + время)
- [ ] Реализовать индексацию архивной памяти
- [ ] Добавить LRU кэш для частых запросов
- [ ] Оптимизировать потребление памяти индексом

### Этап 4: Обновление зависимых модулей (1-2 дня)
- [ ] Обновить activate_memory для использования индекса
- [ ] Проверить интеграцию с runtime loop
- [ ] Обеспечить обратную совместимость API

### Этап 5: Тестирование и оптимизация (2-3 дня)
- [ ] Написать unit-тесты для индексации
- [ ] Написать интеграционные тесты с activation
- [ ] Провести нагрузочное тестирование с большим объемом данных
- [ ] Измерить и оптимизировать производительность

### Этап 6: Документация и релиз (1 день)
- [ ] Обновить docs/components/memory.md
- [ ] Добавить примеры использования индексации
- [ ] Провести финальное тестирование
- [ ] Создать отчет об улучшениях производительности

## Ожидаемые результаты

### Производительность
- **Улучшение времени поиска:** 10-100x быстрее для типичных запросов
- **Масштабируемость:** поддержка памяти до 1000+ записей без деградации
- **CPU overhead:** минимальные накладные расходы на поддержание индекса

### Качество кода
- **Тестируемость:** >95% покрытие новыми тестами
- **Надежность:** автоматическое тестирование корректности индекса
- **Поддерживаемость:** четкое разделение ответственности

### Влияние на систему
- **Runtime loop:** ускорение фазы активации памяти
- **Memory модуль:** новые возможности поиска без нарушения архитектуры
- **Архитектура:** сохранение принципов Life (пассивная память, только хранение опыта)

## Риски и mitigation

### Риски
1. **Переполнение памяти индексом** - mitigation: ограничение размера, оптимизация структур
2. **Несогласованность индекса** - mitigation: автоматическое обновление, тесты корректности
3. **Регрессия производительности** - mitigation: бенчмарки, постепенное внедрение

### Тестирование
- **Unit тесты:** корректность индексации, обновления, поиска
- **Integration тесты:** работа с activation, runtime loop
- **Performance тесты:** сравнение производительности до/после
- **Stress тесты:** работа с большими объемами данных

## Контрольные точки

### День 3: Завершение анализа и проектирования
- Структура индекса определена
- API методов поиска спроектирован
- План интеграции готов

### День 7: Базовый индекс реализован
- MemoryIndex класс работает
- Интеграция в Memory завершена
- Базовые тесты проходят

### День 12: Полная реализация готова
- Все методы поиска реализованы
- Activation обновлен
- Производительность улучшена

### День 14: Релиз
- Документация обновлена
- Все тесты проходят
- Отчет о производительности готов

## Связанные документы

- [Memory компонент](docs/components/memory.md)
- [Activation модуль](docs/components/activation.md)
- [ADR 008: MCP index architecture](docs/adr/008-mcp-index-architecture.md)
- [Runtime Loop документация](docs/components/runtime-loop.md)

---

**Ответственный:** AI Assistant
**Дата последнего обновления:** 2026-01-21
