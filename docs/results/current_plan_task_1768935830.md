# План выполнения задачи: "Ввести immutable snapshot для API"

## Задача
Ввести "immutable snapshot для API": API читает только сериализованный snapshot состояния, а не живой объект

## Контекст проблемы
Согласно todo/DEBT.md (Этап 06 — API Server, пункт 9), текущая архитектура имеет проблему:
- Loop пишет в живой объект self_state
- API читает напрямую из живого объекта
- Отсутствует синхронизация между записью и чтением

## Текущая архитектура
- API получает доступ к живому объекту `self_state` через глобальную переменную
- Использует `get_safe_status_dict()` для сериализации, но все равно работает с живым объектом
- В main_server_api.py: `server.self_state = self_state`
- В api.py: `life_state = None` (глобальная переменная)

## Решение: Immutable Snapshot для API
API должен читать только сериализованные snapshots из файлов, а не работать с живым объектом состояния.

## План реализации

### Этап 1: Анализ текущей архитектуры ✅
- Изучить интеграцию API с SelfState
- Понять точки доступа к живому объекту
- Определить все места, где API читает состояние

### Этап 2: Создание новой архитектуры API
- Создать SnapshotReader класс для чтения snapshots из файлов
- Убрать глобальную переменную life_state из api.py
- Изменить архитектуру так, чтобы API не имел прямого доступа к self_state

### Этап 3: Реализация SnapshotReader
- Класс для чтения последнего snapshot из директории data/snapshots/
- Кэширование последнего прочитанного snapshot
- Thread-safe доступ к snapshots
- Обработка ошибок при отсутствии snapshots

### Этап 4: Обновление API эндпоинтов
- Модифицировать /status endpoint для чтения из snapshot
- Обновить логику получения данных состояния
- Сохранить совместимость с существующими query-параметрами (memory_limit, events_limit и т.д.)

### Этап 5: Удаление прямого доступа к self_state
- Убрать установку life_state в api.py
- Изменить main_server_api.py чтобы не передавать self_state в API
- Убедиться, что API полностью изолирован от runtime loop

### Этап 6: Обновление тестов
- Модифицировать API тесты для работы без живого объекта
- Создать mock snapshots для тестирования
- Проверить работу API с различными состояниями snapshots

### Этап 7: Интеграционное тестирование
- Запустить систему и проверить работу API
- Убедиться, что API корректно читает snapshots
- Проверить производительность и надежность

## Риски и mitigation
1. **Производительность**: Чтение с диска может быть медленнее
   - Mitigation: кэширование последнего snapshot в памяти

2. **Синхронизация**: API может читать устаревший snapshot
   - Mitigation: API всегда читает последний доступный snapshot

3. **Отсутствие snapshots**: При первом запуске snapshots нет
   - Mitigation: fallback на дефолтное состояние или сообщение об ошибке

## Критерии успеха
- API не имеет прямого доступа к живому объекту self_state
- Все эндпоинты работают корректно, читая данные из snapshot файлов
- Тесты проходят
- Производительность не ухудшилась значительно
- Архитектура стала thread-safe

## Временная оценка
- Этап 1: 2 часа (анализ)
- Этап 2: 3 часа (дизайн архитектуры)
- Этап 3: 4 часа (реализация SnapshotReader)
- Этап 4: 3 часа (обновление API)
- Этап 5: 2 часа (удаление прямого доступа)
- Этап 6: 4 часа (тесты)
- Этап 7: 2 часа (интеграционное тестирование)

**Итого: ~20 часов**

## Следующие шаги
1. Начать с анализа текущей архитектуры
2. Создать SnapshotReader
3. Обновить API endpoints
4. Тестирование