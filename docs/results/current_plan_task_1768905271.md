# План выполнения задачи: Добавить синхронизацию доступа (lock/RW-lock) или модель "один писатель — много читателей" через атомарную замену snapshot

**Задача:** Добавить синхронизацию доступа к SelfState между runtime loop thread (писатель) и API server thread (читатели) через lock/RW-lock или модель "один писатель — много читателей" через атомарную замену snapshot.

**Дата создания:** 2026-01-20

## Анализ текущей ситуации

### Текущая архитектура доступа к состоянию:

1. **Runtime Loop Thread** (`src/runtime/loop.py`):
   - Пишет в `self_state` (изменяет состояние)
   - Вызывает `save_snapshot()` периодически
   - Использует `apply_delta()`, `__setattr__()` для изменения состояния

2. **API Server Thread** (`src/main_server_api.py`):
   - Читает `self_state` через `get_safe_status_dict()`
   - Доступ к состоянию происходит в `LifeHandler.do_GET()` при запросе `/status`
   - Может быть несколько одновременных запросов (много читателей)

3. **Проблема отсутствия синхронизации:**
   - Нет блокировок между потоками
   - Runtime loop может изменять состояние во время чтения API
   - Возможны race conditions при доступе к сложным структурам (memory, dict)
   - В документации (`docs/components/api-server.md`) указано: "Благодаря GIL в Python, чтение атомарных значений безопасно, но для сложных структур может потребоваться блокировка (пока не реализована)"

### Текущие точки доступа к состоянию:

**Запись (Runtime Loop):**
- `self_state.apply_delta()` - изменение числовых полей
- `self_state.energy = ...` - прямое присваивание
- `self_state.memory.append()` - добавление в память
- `save_snapshot()` - сериализация состояния

**Чтение (API Server):**
- `self_state.get_safe_status_dict()` - получение безопасного словаря для API
- `asdict(self_state)` - используется в некоторых местах (deprecated)

## Варианты решения

### Вариант 1: Read-Write Lock (RW-Lock)

**Преимущества:**
- Позволяет множественное чтение одновременно
- Блокирует запись только во время чтения
- Хорошая производительность для read-heavy нагрузки

**Недостатки:**
- Требует модификации всех точек доступа к состоянию
- Может привести к блокировкам при длительных операциях чтения
- Сложнее в реализации и отладке

**Реализация:**
- Использовать `threading.RLock` или `threading.Lock` для простого варианта
- Или использовать библиотеку `readerwriterlock` для полноценного RW-lock
- Обернуть все операции чтения/записи в контекстные менеджеры

### Вариант 2: Атомарная замена snapshot (Copy-on-Read)

**Преимущества:**
- Не требует блокировок для чтения
- Читатели получают моментальный снимок состояния
- Проще в реализации и понимании
- Избегает race conditions через изоляцию

**Недостатки:**
- Требует копирования состояния при каждом чтении (overhead)
- Может быть медленнее для больших состояний
- Нужно синхронизировать только операции записи

**Реализация:**
- Runtime loop периодически создает snapshot состояния
- API читает из snapshot, а не из живого состояния
- Snapshot обновляется атомарно через замену ссылки

### Вариант 3: Гибридный подход (Snapshot + Lock для записи)

**Преимущества:**
- Комбинирует преимущества обоих подходов
- Snapshot для чтения (быстро, без блокировок)
- Lock только для записи (защита от одновременных изменений)

**Недостатки:**
- Более сложная реализация
- Требует управления двумя механизмами

## Рекомендуемое решение: Вариант 2 (Атомарная замена snapshot)

### Обоснование:

1. **Простота реализации:** Минимальные изменения в существующем коде
2. **Производительность:** Для read-heavy нагрузки (API) snapshot подход эффективен
3. **Безопасность:** Полностью исключает race conditions для читателей
4. **Соответствие архитектуре:** Snapshot уже используется в системе для сохранения состояния

### Архитектура решения:

```
Runtime Loop Thread (Writer):
  - Изменяет self_state напрямую
  - Периодически создает snapshot через save_snapshot()
  - Атомарно обновляет shared_snapshot через lock

API Server Thread (Readers):
  - Читает из shared_snapshot (без блокировок)
  - Получает моментальный снимок состояния
  - Не блокирует writer
```

## План реализации

### Шаг 1: Создать StateSnapshotManager

**Файл:** `src/state/snapshot_manager.py`

**Функциональность:**
- Хранит текущий snapshot состояния (словарь)
- Метод `update_snapshot(state: SelfState)` - атомарно обновляет snapshot
- Метод `get_snapshot() -> dict` - возвращает текущий snapshot (без блокировок)
- Использует `threading.Lock` только для записи

**Интерфейс:**
```python
class StateSnapshotManager:
    def __init__(self):
        self._snapshot: dict = {}
        self._lock = threading.Lock()
    
    def update_snapshot(self, state: SelfState) -> None:
        """Атомарно обновляет snapshot из состояния"""
        with self._lock:
            self._snapshot = state.get_safe_status_dict(...)
    
    def get_snapshot(self) -> dict:
        """Возвращает текущий snapshot (без блокировок)"""
        return self._snapshot.copy()  # Защита от изменений
```

### Шаг 2: Интеграция в Runtime Loop

**Файл:** `src/runtime/loop.py`

**Изменения:**
- Добавить параметр `snapshot_manager: StateSnapshotManager` в `run_loop()`
- После каждого изменения состояния вызывать `snapshot_manager.update_snapshot(self_state)`
- Оптимизация: обновлять snapshot не на каждом тике, а периодически (например, каждые N тиков или при значимых изменениях)

**Оптимизация частоты обновления:**
- Обновлять snapshot при каждом изменении vital параметров
- Обновлять snapshot периодически (например, каждые 5 тиков)
- Обновлять snapshot перед `save_snapshot()` (уже есть периодичность)

### Шаг 3: Интеграция в API Server

**Файл:** `src/main_server_api.py`

**Изменения:**
- Создать `StateSnapshotManager` при инициализации
- Передать `snapshot_manager` в runtime loop thread
- В `LifeHandler.do_GET()` использовать `snapshot_manager.get_snapshot()` вместо `self_state.get_safe_status_dict()`

**Текущий код:**
```python
safe_status = self.server.self_state.get_safe_status_dict(...)
```

**Новый код:**
```python
safe_status = self.server.snapshot_manager.get_snapshot()
```

### Шаг 4: Инициализация и передача snapshot_manager

**Файл:** `src/main_server_api.py`

**Изменения:**
- Создать `snapshot_manager` в `__main__`
- Передать в `start_api_server()` и сохранить в `server.snapshot_manager`
- Передать в `run_loop()` как параметр
- Инициализировать начальный snapshot при старте

### Шаг 5: Тестирование

**Файлы:**
- `src/test/test_state_snapshot_manager.py` - unit тесты для StateSnapshotManager
- `src/test/test_concurrent_access.py` - тесты на concurrent доступ
- Обновить существующие тесты для работы с snapshot_manager

**Тестовые сценарии:**
1. Множественное чтение snapshot одновременно (без блокировок)
2. Обновление snapshot во время чтения (атомарность)
3. Проверка консистентности snapshot (все поля присутствуют)
4. Производительность: сравнение с прямым доступом к состоянию

### Шаг 6: Документация

**Файлы:**
- `docs/components/self-state.md` - добавить раздел о синхронизации доступа
- `docs/components/api-server.md` - обновить раздел об архитектуре доступа к состоянию
- `docs/development/concurrent-access.md` - новый документ о механизме синхронизации

**Содержание документации:**
- Описание архитектуры синхронизации
- Объяснение выбора подхода (snapshot вместо RW-lock)
- Примеры использования
- Рекомендации по производительности

## Детальный план реализации

### Этап 1: Базовая реализация StateSnapshotManager

1. Создать файл `src/state/snapshot_manager.py`
2. Реализовать класс `StateSnapshotManager` с базовым функционалом
3. Добавить unit тесты
4. Проверить работу в изоляции

### Этап 2: Интеграция в Runtime Loop

1. Добавить параметр `snapshot_manager` в `run_loop()`
2. Добавить вызовы `update_snapshot()` в критических точках:
   - После обработки событий
   - После изменения vital параметров
   - Перед `save_snapshot()`
3. Оптимизировать частоту обновления (не на каждом тике)
4. Обновить тесты runtime loop

### Этап 3: Интеграция в API Server

1. Создать `snapshot_manager` в `__main__`
2. Передать в `start_api_server()` и сохранить в `server`
3. Изменить `LifeHandler.do_GET()` для использования snapshot
4. Обновить тесты API server

### Этап 4: Тестирование и оптимизация

1. Написать тесты на concurrent доступ
2. Провести нагрузочное тестирование
3. Измерить производительность
4. Оптимизировать частоту обновления snapshot

### Этап 5: Документация

1. Обновить документацию компонентов
2. Создать документацию по concurrent access
3. Добавить примеры использования
4. Обновить README при необходимости

## Критерии успеха

1. ✅ API server читает состояние без блокировок
2. ✅ Runtime loop обновляет snapshot атомарно
3. ✅ Нет race conditions при одновременном доступе
4. ✅ Производительность чтения не ухудшилась значительно
5. ✅ Все существующие тесты проходят
6. ✅ Добавлены новые тесты на concurrent access
7. ✅ Документация обновлена

## Риски и митигация

### Риск 1: Overhead от копирования snapshot
**Митигация:** 
- Оптимизировать частоту обновления snapshot
- Использовать shallow copy где возможно
- Профилировать производительность

### Риск 2: Задержка обновления snapshot
**Митигация:**
- Обновлять snapshot при критических изменениях (vital параметры)
- Обновлять snapshot периодически (каждые N тиков)
- Документировать возможную задержку

### Риск 3: Несовместимость с существующим кодом
**Митигация:**
- Сохранить обратную совместимость (self_state доступен напрямую для внутреннего использования)
- Постепенная миграция
- Тщательное тестирование

## Альтернативные подходы (если основной не подойдет)

### Альтернатива 1: Использовать threading.RLock
- Проще в реализации
- Но блокирует читателей во время записи

### Альтернатива 2: Использовать библиотеку readerwriterlock
- Полноценный RW-lock
- Но добавляет зависимость

### Альтернатива 3: Immutable State Pattern
- Полная изоляция через неизменяемые объекты
- Но требует значительной рефакторинга

## Следующие шаги

1. Реализовать `StateSnapshotManager`
2. Интегрировать в runtime loop
3. Интегрировать в API server
4. Протестировать
5. Оптимизировать
6. Задокументировать
