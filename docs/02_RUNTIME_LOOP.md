# 02_RUNTIME_LOOP.md

## Назначение

Runtime Loop — это сердце системы **life**. Это не «обработка запроса», не «диалог», не «сессия». Это непрерывный процесс, который:

* существует во времени,
* изменяет внутреннее состояние,
* взаимодействует с миром,
* может деградировать и завершиться.

Главная идея: **если loop остановился — жизнь закончилась**.

---

## Базовая формула

Каждый тик — это атом жизни.

```
while alive:
    perceive()
    update_self_state()
    decide()
    act()
    decay()
    sleep(dt)
```

Важно: ни один шаг не является опциональным.

---

## Время (Time Model)

* Loop работает с реальным временем (wall clock).
* Используется `tick_interval` — фиксированный интервал между тиками.
* tick_interval по умолчанию 1.0 секунда, но может быть настроен.

Последствия:

* пропуски тиков = потерянная жизнь
* лаги = искажённое восприятие мира

---

## Шаги тика

### 1. perceive() (этап 07: Environment)

Получение событий из среды (Environment).

**Реализация:**
* Извлечение всех событий из `EventQueue` через `pop_all()`
* Интерпретация каждого события через `_interpret_event()`
* Изменение `self_state` согласно типу и интенсивности события

**Типы событий:**
* `noise` - случайное воздействие (влияет на stability)
* `decay` - естественный износ (снижает energy)
* `recovery` - восстановление (повышает energy)
* `shock` - резкое воздействие (влияет на integrity и stability)
* `idle` - отсутствие событий (не изменяет состояние)

**Источники:**
* `EventGenerator` генерирует события в фоновом потоке
* События помещаются в `EventQueue` асинхронно
* Life обрабатывает все накопленные события за тик

**Результат:**
* Изменение `self_state` (energy, stability, integrity)
* События интерпретируются субъективно Life

---

### 2. update_self_state()

Обновление внутреннего состояния **Я**.

**Принципы:**
* состояние изменяется **всегда**
* изменения происходят как от событий среды, так и от времени
* изменения логируются append-only

**Изменения на каждом тике:**
* `ticks` увеличивается на 1
* `age` увеличивается на `dt` (время с последнего тика)
* Параметры `energy`, `stability`, `integrity` изменяются под влиянием событий из Environment

**Примеры изменений от событий:**
* `noise` → небольшое изменение stability
* `decay` → снижение energy
* `recovery` → повышение energy
* `shock` → значительное влияние на integrity и stability

**Важно:** На этапе 07 состояние изменяется только под влиянием событий среды. Жестко закодированные изменения (например, `energy -= 0.1`) удалены.

---

### 3. decide()

Выбор следующего действия.

Важно:

* decision ≠ интеллект
* это может быть примитивная эвристика
* или даже случайность

Результат:

* `Action` или `None`

---

### 4. act()

Попытка воздействия на мир.

Особенности:

* действие может провалиться
* действие может иметь отложенный эффект
* действие всегда имеет цену

---

### 5. decay()

Деградация — обязательный шаг.

Если его убрать — система бессмертна.

Примеры:

* забывание
* рост энтропии
* потеря точности

---

### 6. snapshot()

Периодическое сохранение состояния.

* каждые `snapshot_period` тиков сохраняется полный Self-State
* файлы snapshot_{tick:06d}.json в data/snapshots/
* позволяет анализировать историю жизни

---

### 7. sleep(tick_interval)

Пауза до следующего тика.

Важно:

* sleep(tick_interval) поддерживает постоянный интервал
* реальное время всегда первично

---

## Ошибки и сбои

* Любое исключение внутри тика:

  * логируется
  * увеличивает внутренний «ущерб»
* Критический порог → `alive = False`

**Нет автоматического перезапуска.**

---

## Завершение жизни

Жизнь завершается если:

* превышен порог деградации
* повреждено Self-State
* внешний kill-сигнал

После завершения:

* loop останавливается
* состояние сохраняется
* продолжение возможно только как *новая жизнь*

---

## Архитектурный инвариант

> Runtime Loop — единственное место, где течёт время.

Ни один модуль не имеет права:

* запускать собственный loop
* хранить скрытое время
* принимать решения вне тика

---

## Минимальная реализация

На первом этапе:

* tick_interval = 1.0 сек (по умолчанию)
* snapshot_period = 10 тиков (по умолчанию)
* fake sensors
* примитивный decide()
* лог в JSONL файл
* snapshot в data/snapshots/

Этого достаточно, чтобы жизнь **начала течь**.

---

## Инструкции по настройке

### Параметры Runtime Loop

* `tick_interval` — интервал между тиками (сек), по умолчанию 1.0
* `snapshot_period` — тиков между snapshot, по умолчанию 10

### Настройка через командную строку

```
python [`main_server_api.py`](../src/main_server_api.py) --tick-interval 0.5 --snapshot-period 5
```

### Мониторинг работы

* Консольный вывод показывает heartbeat и параметры
* JSON логи в data/tick_log.jsonl
* Snapshot в data/snapshots/

### Остановка

Loop останавливается при достижении порогов деградации или внешнем сигнале.
