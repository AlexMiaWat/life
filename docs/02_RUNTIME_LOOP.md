# 02_RUNTIME_LOOP.md

## Назначение

Runtime Loop — это сердце системы **life**. Это не «обработка запроса», не «диалог», не «сессия». Это непрерывный процесс, который:

* существует во времени,
* изменяет внутреннее состояние,
* взаимодействует с миром,
* может деградировать и завершиться.

Главная идея: **если loop остановился — жизнь закончилась**.

---

## Базовая формула

Каждый тик — это атом жизни.

```
while alive:
    perceive()
    update_self_state()
    decide()
    act()
    decay()
    sleep(dt)
```

Важно: ни один шаг не является опциональным.

---

## Время (Time Model)

* Loop работает с реальным временем (wall clock).
* Используется `dt` — прошедшее время с предыдущего тика.
* dt **не фиксирован**, допускаются джиттер и дрейф.

Последствия:

* пропуски тиков = потерянная жизнь
* лаги = искажённое восприятие мира

---

## Шаги тика

### 1. perceive()

Получение входных сигналов.

Источники:

* синтетические события (таймеры, шум)
* внутренние сигналы (боль, усталость, конфликт)
* позже: реальные сенсоры

Результат:

* список `Percept` объектов

---

### 2. update_self_state()

Обновление внутреннего состояния **Я**.

Принципы:

* состояние изменяется **всегда**
* даже при отсутствии внешних сигналов
* изменения логируются append-only

Примеры изменений:

* накопление напряжения
* затухание памяти
* рост внутреннего шума

---

### 3. decide()

Выбор следующего действия.

Важно:

* decision ≠ интеллект
* это может быть примитивная эвристика
* или даже случайность

Результат:

* `Action` или `None`

---

### 4. act()

Попытка воздействия на мир.

Особенности:

* действие может провалиться
* действие может иметь отложенный эффект
* действие всегда имеет цену

---

### 5. decay()

Деградация — обязательный шаг.

Если его убрать — система бессмертна.

Примеры:

* забывание
* рост энтропии
* потеря точности

---

### 6. sleep(dt)

Пауза до следующего тика.

Важно:

* sleep не гарантирует точность
* реальное время всегда первично

---

## Ошибки и сбои

* Любое исключение внутри тика:

  * логируется
  * увеличивает внутренний «ущерб»
* Критический порог → `alive = False`

**Нет автоматического перезапуска.**

---

## Завершение жизни

Жизнь завершается если:

* превышен порог деградации
* повреждено Self-State
* внешний kill-сигнал

После завершения:

* loop останавливается
* состояние сохраняется
* продолжение возможно только как *новая жизнь*

---

## Архитектурный инвариант

> Runtime Loop — единственное место, где течёт время.

Ни один модуль не имеет права:

* запускать собственный loop
* хранить скрытое время
* принимать решения вне тика

---

## Минимальная реализация

На первом этапе:

* dt = 0.5–1.0 сек
* fake sensors
* примитивный decide()
* лог в файл

Этого достаточно, чтобы жизнь **начала течь**.
