# 02_RUNTIME_LOOP.md

## Статус на 11.01.2026
Текущая реализация (src/runtime/loop.py) — монолитный цикл с прямой интерпретацией событий.
Это **временная** реализация.
Переход к модульной структуре обязателен перед интеграцией MeaningEngine и высших слоёв.

## Назначение

Runtime Loop — это сердце системы **life**. Это не «обработка запроса», не «диалог», не «сессия». Это непрерывный процесс, который:

* существует во времени,
* изменяет внутреннее состояние,
* взаимодействует с миром,
* может деградировать и ослабеть (немощность).

Главная идея: **если loop остановился — жизнь закончилась**.

---

## Базовая формула

Каждый тик — это атом жизни.

```
while alive:
    perceive()
    update_self_state()
    process_meaning()
    decide()
    act()
    decay()
    snapshot_and_log()
    sleep_until_next_tick()
```

Важно: ни один шаг не является опциональным.

---

## Целевая структура Runtime Loop (этап 02–03)

Каждый тик выполняется строго последовательно:

1. perceive()           # собрать события из среды (EventQueue)
2. update_self_state()  # базовое течение времени (age, ticks, fatigue + tension)
3. process_meaning()    # интерпретация событий через MeaningEngine
4. decide()             # пока заглушка (позже DecisionMaker)
5. act()                # пока заглушка (позже ActionExecutor)
6. decay()              # медленная деградация (если нет стимулов)
7. snapshot_and_log()   # сохранение состояния и логов
8. sleep_until_next_tick()

---

## Время (Time Model)

* Loop работает с реальным временем (wall clock).
* Используется `tick_interval` — фиксированный интервал между тиками.
* tick_interval по умолчанию 1.0 секунда, но может быть настроен.

Последствия:

* пропуски тиков = потерянная жизнь
* лаги = искажённое восприятие мира

---

## Шаги тика

### 1. perceive() (этап 07: Environment)

Собрать события из среды (EventQueue).

**Реализация:**
* Извлечение всех событий из `EventQueue` через `pop_all()`
* Подготовка событий для дальнейшей обработки

**Результат:**
* Список сырых событий для интерпретации

---

### 2. update_self_state()

Базовое течение времени (age, ticks, fatigue + tension).

**Изменения на каждом тике:**
* `ticks` увеличивается на 1
* `age` увеличивается на `dt` (время с последнего тика)
* Обновление базовых параметров (fatigue, tension)

---

### 3. process_meaning()

Интерпретация событий через MeaningEngine.

**Реализация:**
* Передача событий в MeaningEngine
* Получение интерпретированных значений
* Изменение `self_state` на основе интерпретации

**Результат:**
* Обновлённое `self_state` с субъективной интерпретацией событий

---

### 4. decide()

Пока заглушка (позже DecisionMaker).

**Результат:**
* `Action` или `None`

---

### 5. act()

Пока заглушка (позже ActionExecutor).

**Результат:**
* Попытка выполнения действия

---

### 6. decay()

Медленная деградация (если нет стимулов).

Примеры:
* забывание
* рост энтропии
* потеря точности

---

### 7. snapshot_and_log()

Сохранение состояния и логов.

* Сохранение полного Self-State каждые `snapshot_period` тиков
* Логирование тика в JSONL файл
* Файлы snapshot_{tick:06d}.json в data/snapshots/

---

### 8. sleep_until_next_tick()

Пауза до следующего тика.

* Поддерживает постоянный интервал `tick_interval`
* Реальное время всегда первично

---

## Требования к модульной реализации

- Каждый шаг — отдельная функция в src/runtime/steps.py
- Функции принимают self_state и/или event_queue/meaning_engine как аргументы
- Нет глобальных переменных и side-effects внутри функций
- Порядок шагов фиксирован и не должен меняться без обновления документации
- Если шаг возвращает False или raise — цикл прерывается (alive = False)

---

## Ошибки и сбои

* Любое исключение внутри тика:

  * логируется
  * увеличивает внутренний «ущерб»
* Критический порог → `alive = False`

**Нет автоматического перезапуска.**

---

## Завершение жизни

Жизнь завершается если:

* превышен порог деградации
* повреждено Self-State
* внешний kill-сигнал

После завершения:

* loop останавливается
* состояние сохраняется
* продолжение возможно только как *новая жизнь*

---

## Архитектурный инвариант

> Runtime Loop — единственное место, где течёт время.

Ни один модуль не имеет права:

* запускать собственный loop
* хранить скрытое время
* принимать решения вне тика

---

## Минимальная реализация

На первом этапе:

* tick_interval = 1.0 сек (по умолчанию)
* snapshot_period = 10 тиков (по умолчанию)
* fake sensors
* примитивный decide()
* лог в JSONL файл
* snapshot в data/snapshots/

Этого достаточно, чтобы жизнь **начала течь**.

---

## Инструкции по настройке

### Параметры Runtime Loop

* `tick_interval` — интервал между тиками (сек), по умолчанию 1.0
* `snapshot_period` — тиков между snapshot, по умолчанию 10

### Настройка через командную строку

```
python [`main_server_api.py`](../src/main_server_api.py) --tick-interval 0.5 --snapshot-period 5
```

### Мониторинг работы

* Консольный вывод показывает heartbeat и параметры
* JSON логи в data/tick_log.jsonl
* Snapshot в data/snapshots/

### Остановка

Loop останавливается при достижении порогов деградации или внешнем сигнале.

---

## Следующие шаги после модульного цикла

1. Реализовать src/runtime/steps.py с функциями perceive/decide/act
2. Заменить _interpret_event на process_meaning с MeaningEngine
3. Добавить минимальные заглушки decide() и act() (возвращают None)
4. Переписать run_loop в src/runtime/loop.py под новый порядок
