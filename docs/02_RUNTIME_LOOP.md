# 02_RUNTIME_LOOP.md

## Назначение

Runtime Loop — это сердце системы **life**. Это не «обработка запроса», не «диалог», не «сессия». Это непрерывный процесс, который:

* существует во времени,
* изменяет внутреннее состояние,
* взаимодействует с миром,
* может деградировать и завершиться.

Главная идея: **если loop остановился — жизнь закончилась**.

---

## Базовая формула

Каждый тик — это атом жизни.

```
while alive:
    perceive()
    update_self_state()
    decide()
    act()
    decay()
    sleep(dt)
```

Важно: ни один шаг не является опциональным.

---

## Время (Time Model)

* Loop работает с реальным временем (wall clock).
* Используется `tick_interval` — фиксированный интервал между тиками.
* tick_interval по умолчанию 1.0 секунда, но может быть настроен.

Последствия:

* пропуски тиков = потерянная жизнь
* лаги = искажённое восприятие мира

---

## Шаги тика

### 1. perceive()

Получение входных сигналов.

Источники:

* синтетические события (таймеры, шум)
* внутренние сигналы (боль, усталость, конфликт)
* позже: реальные сенсоры

Результат:

* список `Percept` объектов

---

### 2. update_self_state()

Обновление внутреннего состояния **Я**.

Принципы:

* состояние изменяется **всегда**
* даже при отсутствии внешних сигналов
* изменения логируются append-only

Примеры изменений:

* накопление напряжения
* затухание памяти
* рост внутреннего шума

---

### 3. decide()

Выбор следующего действия.

Важно:

* decision ≠ интеллект
* это может быть примитивная эвристика
* или даже случайность

Результат:

* `Action` или `None`

---

### 4. act()

Попытка воздействия на мир.

Особенности:

* действие может провалиться
* действие может иметь отложенный эффект
* действие всегда имеет цену

---

### 5. decay()

Деградация — обязательный шаг.

Если его убрать — система бессмертна.

Примеры:

* забывание
* рост энтропии
* потеря точности

---

### 6. snapshot()

Периодическое сохранение состояния.

* каждые `snapshot_period` тиков сохраняется полный Self-State
* файлы snapshot_{tick:06d}.json в data/snapshots/
* позволяет анализировать историю жизни

---

### 7. sleep(tick_interval)

Пауза до следующего тика.

Важно:

* sleep(tick_interval) поддерживает постоянный интервал
* реальное время всегда первично

---

## Ошибки и сбои

* Любое исключение внутри тика:

  * логируется
  * увеличивает внутренний «ущерб»
* Критический порог → `alive = False`

**Нет автоматического перезапуска.**

---

## Завершение жизни

Жизнь завершается если:

* превышен порог деградации
* повреждено Self-State
* внешний kill-сигнал

После завершения:

* loop останавливается
* состояние сохраняется
* продолжение возможно только как *новая жизнь*

---

## Архитектурный инвариант

> Runtime Loop — единственное место, где течёт время.

Ни один модуль не имеет права:

* запускать собственный loop
* хранить скрытое время
* принимать решения вне тика

---

## Минимальная реализация

На первом этапе:

* tick_interval = 1.0 сек (по умолчанию)
* snapshot_period = 10 тиков (по умолчанию)
* fake sensors
* примитивный decide()
* лог в JSONL файл
* snapshot в data/snapshots/

Этого достаточно, чтобы жизнь **начала течь**.

---

## Инструкции по настройке

### Параметры Runtime Loop

* `tick_interval` — интервал между тиками (сек), по умолчанию 1.0
* `snapshot_period` — тиков между snapshot, по умолчанию 10

### Настройка через командную строку

```
python src/main_server_api.py --tick-interval 0.5 --snapshot-period 5
```

### Мониторинг работы

* Консольный вывод показывает heartbeat и параметры
* JSON логи в data/tick_log.jsonl
* Snapshot в data/snapshots/

### Остановка

Loop останавливается при достижении порогов деградации или внешнем сигнале.
