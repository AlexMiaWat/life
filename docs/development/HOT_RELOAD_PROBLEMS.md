# Проблемы Hot Reload в Dev-режиме

**Дата создания:** 2026-01-20  
**Статус:** Документировано  
**Связано с:** DEBT.md #10

## Обзор

В dev-режиме (`--dev`) система использует механизм hot reload через `importlib.reload()` для автоматической перезагрузки модулей при изменении файлов. Этот подход создает несколько серьезных проблем, которые делают систему непредсказуемой и сложной в отладке.

## Проблема 1: Идентичность объектов

### Описание

При использовании `importlib.reload()` создаются новые объекты классов, но старые ссылки на объекты остаются в других частях системы. Это приводит к ситуации, когда разные компоненты работают с разными версиями одного и того же объекта.

### Местоположение проблемы

**Файл:** `src/main_server_api.py`  
**Функция:** `reloader_thread()`  
**Строки:** 229-341

### Примеры проблемного кода

```python
# Строка 234: Глобальные переменные, которые могут содержать старые ссылки
global self_state, server, api_thread, monitor, log, loop_thread, loop_stop, config, event_queue

# Строки 288-293: Перезагрузка модулей создает новые классы
importlib.reload(console_module)
importlib.reload(loop_module)
importlib.reload(state_module)
importlib.reload(event_module)
importlib.reload(event_queue_module)
importlib.reload(generator_module)

# Строки 303-309: Обновление ссылок на функции
monitor = console_module.monitor
log = console_module.log
run_loop = loop_module.run_loop
try:
    self_state = state_module.SelfState().load_latest_snapshot()
except FileNotFoundError:
    self_state = state_module.SelfState()
```

### Проблемы

1. **Старые ссылки остаются:**
   - `server.self_state` может указывать на старый объект
   - `loop_thread` может использовать старую версию `run_loop`
   - Другие компоненты могут иметь кэшированные ссылки на старые объекты

2. **Неконсистентное состояние:**
   - Runtime loop работает с одним экземпляром `self_state`
   - API server читает из другого экземпляра `self_state`
   - Логирование может использовать старые функции

3. **Проблемы с dataclass:**
   - При перезагрузке модуля создается новый класс `SelfState`
   - Старые экземпляры остаются экземплярами старого класса
   - `isinstance()` проверки могут работать некорректно

### Последствия

- Runtime loop может работать со старым объектом `self_state`, не видя изменений
- API server может читать из старого состояния, показывая устаревшие данные
- Логирование может идти в старые файлы или использовать старую логику
- Неконсистентное состояние между компонентами системы
- Сложно отлаживать, так как непонятно, какая версия объекта используется

### Пример сценария проблемы

1. Изменяется `src/state/self_state.py`
2. `reloader_thread()` обнаруживает изменение и перезагружает модуль
3. Создается новый класс `SelfState`
4. Создается новый экземпляр `self_state = SelfState().load_latest_snapshot()`
5. Но `server.self_state` все еще указывает на старый экземпляр
6. API server читает из старого состояния
7. Runtime loop работает с новым состоянием
8. Результат: неконсистентное состояние системы

## Проблема 2: Висящие потоки и серверы

### Описание

При перезагрузке модулей старые потоки и серверы могут не завершиться корректно, оставаясь активными и продолжая работать со старым кодом.

### Местоположение проблемы

**Файл:** `src/main_server_api.py`  
**Функции:** `reloader_thread()`, `start_api_server()`  
**Строки:** 274-278, 322-324, 219-226

### Примеры проблемного кода

```python
# Строки 274-278: Остановка API сервера
if server:
    server.shutdown()
    if api_thread:
        api_thread.join()  # Может зависнуть, если поток не завершился

# Строки 322-324: Остановка loop thread
if loop_thread and loop_thread.is_alive():
    loop_stop.set()
    loop_thread.join(timeout=5.0)  # Может не завершиться за 5 секунд
    log("[RELOAD] Old loop stopped")

# Строки 312-317: Создание нового API потока без проверки
api_thread = threading.Thread(
    target=start_api_server,
    args=(self_state, event_queue, True),
    daemon=True,
)
api_thread.start()
```

### Проблемы

1. **API сервер может не завершиться:**
   - `server.shutdown()` устанавливает флаг `stopped = True`
   - Но если сервер обрабатывает запрос, он может не завершиться сразу
   - `api_thread.join()` может зависнуть навсегда

2. **Loop thread может не завершиться:**
   - `loop_stop.set()` устанавливает событие остановки
   - Но если loop находится в длительной операции (например, `time.sleep()`), он может не проверить событие вовремя
   - `timeout=5.0` может быть недостаточным

3. **Daemon потоки продолжают работать:**
   - Daemon потоки не блокируют завершение программы
   - Но они могут продолжать работать со старым кодом
   - Старые потоки могут создавать новые объекты из старых модулей

4. **Множественные экземпляры:**
   - Если старый поток не завершился, создается новый
   - В результате может быть несколько потоков, работающих одновременно
   - Особенно проблематично для API сервера (порт уже занят)

### Последствия

- Множественные экземпляры API сервера пытаются использовать один порт
- Старые потоки продолжают работать со старым кодом, создавая баги
- Утечки ресурсов (память, файловые дескрипторы, сетевые соединения)
- Невозможность корректного перезапуска системы
- Система становится нестабильной после нескольких перезагрузок

### Пример сценария проблемы

1. Изменяется `src/runtime/loop.py`
2. `reloader_thread()` пытается остановить старый loop thread
3. Старый loop thread находится в `time.sleep(1.0)` и не проверяет `loop_stop`
4. `loop_thread.join(timeout=5.0)` завершается по таймауту
5. Создается новый loop thread
6. Теперь работают два loop thread одновременно
7. Оба изменяют `self_state`, создавая race conditions
8. Результат: неконсистентное состояние и баги

## Проблема 3: Непредсказуемость поведения

### Описание

Отсутствие синхронизации между перезагрузкой модулей и их использованием создает race conditions и делает поведение системы непредсказуемым.

### Местоположение проблемы

**Файл:** `src/main_server_api.py`  
**Функция:** `reloader_thread()`  
**Строки:** 258-341

### Примеры проблемного кода

```python
# Строка 258: Бесконечный цикл без синхронизации
while True:
    time.sleep(1)
    changed = False
    
    # Проверка изменений
    for f in files_to_watch:
        try:
            if os.stat(f).st_mtime != mtime_dict[f]:
                changed = True
                # ...
    
    if changed:
        # Перезагрузка модулей
        # Но другие потоки могут использовать объекты во время перезагрузки
        importlib.reload(...)
```

### Проблемы

1. **Отсутствие атомарности:**
   - Перезагрузка модулей не атомарна
   - Между перезагрузкой разных модулей другие потоки могут использовать объекты
   - Нет гарантии, что все модули перезагружены консистентно

2. **Race conditions:**
   - Runtime loop может читать `self_state` во время его замены
   - API server может читать состояние во время перезагрузки модулей
   - Нет механизма синхронизации между перезагрузкой и использованием

3. **Глобальные переменные:**
   - Использование глобальных переменных создает проблемы с синхронизацией
   - Изменение глобальных переменных не синхронизировано между потоками
   - Нет гарантии видимости изменений для других потоков

4. **Нет механизма отката:**
   - Если перезагрузка частично завершилась с ошибкой, система остается в неконсистентном состоянии
   - Нет способа откатить изменения
   - Система может остаться в поломанном состоянии

### Последствия

- Неконсистентное поведение системы
- Сложно отлаживать проблемы (непонятно, когда и как произошла ошибка)
- Непредсказуемые ошибки при работе в dev-режиме
- Невозможность гарантировать корректное состояние системы
- Пользователи теряют доверие к системе из-за непредсказуемости

### Пример сценария проблемы

1. Изменяются несколько файлов одновременно
2. `reloader_thread()` обнаруживает изменения и начинает перезагрузку
3. Перезагружается `console_module`, обновляется `monitor`
4. Runtime loop вызывает `monitor(self_state)` - использует новую версию
5. Перезагружается `state_module`, создается новый `SelfState`
6. Но `self_state` в runtime loop еще старый
7. API server читает `self_state` - получает старый объект
8. Результат: разные компоненты используют разные версии объектов

## Связь с техническим долгом

Эти проблемы задокументированы в `todo/DEBT.md` как проблема #10:

> **10. Hot reload через importlib — технический долг**
>
> Проблема:
> - ломает идентичность объектов
> - создаёт висящие серверы
> - сложно контролируется
>
> Позже:
> - Dev-mode = перезапуск процесса
> - Чёткое разделение: Life ≠ tooling

## Рекомендации по решению

### Краткосрочное решение (митигация)

1. **Добавить таймауты и проверки:**
   - Увеличить таймаут для `loop_thread.join()` до 10 секунд
   - Добавить проверку `api_thread.is_alive()` перед созданием нового
   - Добавить механизм принудительного завершения потоков

2. **Улучшить синхронизацию:**
   - Использовать `threading.Lock` для защиты критических секций
   - Добавить механизм блокировки во время перезагрузки
   - Использовать `threading.Event` для координации потоков

3. **Добавить логирование:**
   - Логировать все операции перезагрузки
   - Логировать создание и завершение потоков
   - Логировать проблемы с синхронизацией

### Долгосрочное решение (рефакторинг)

1. **Перезапуск процесса вместо hot reload:**
   - Dev-mode должен перезапускать весь процесс при изменении файлов
   - Использовать инструменты типа `watchdog` или `nodemon`
   - Чёткое разделение: Life (основной процесс) ≠ tooling (dev-инструменты)

2. **Архитектурные изменения:**
   - Убрать глобальные переменные
   - Использовать dependency injection
   - Создать четкий lifecycle для компонентов

3. **Тестирование:**
   - Добавить тесты на корректность перезагрузки
   - Добавить тесты на завершение потоков
   - Добавить интеграционные тесты dev-режима

## Приоритет и критичность

**Приоритет:** Средний  
**Критичность:** Высокая для dev-режима, низкая для production

**Обоснование:**
- Проблемы критичны только в dev-режиме
- Production режим не использует hot reload
- Но проблемы усложняют разработку и отладку
- Могут привести к потере времени разработчиков

## Ссылки

- `src/main_server_api.py` - основной файл с проблемами
- `todo/DEBT.md` - технический долг #10
- `docs/components/api-server.md` - документация API сервера
- `docs/components/runtime-loop.md` - документация runtime loop
