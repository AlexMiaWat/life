# План реализации Auto-reloader'а для Python сервера

## 1. Обзор задачи

Необходимо добавить функциональность автоматической перезагрузки модулей HTTP сервера при изменении его исходных файлов. Это позволит ускорить разработку, автоматически применяя изменения без ручного перезапуска сервера. Реализация должна использовать только стандартную библиотеку Python.

## 2. Архитектура решения

Решение будет состоять из двух основных компонентов:

1.  **Основной поток (Main Thread):** Отвечает за запуск HTTP сервера и основного цикла (`run_loop`).
2.  **Поток мониторинга (Monitor Daemon Thread):** Отдельный поток, который будет периодически проверять изменения в указанных файлах.

### Диаграмма рабочего процесса

```mermaid
graph TD
    A[Старт приложения] --> B{Аргумент --dev установлен?};
    B -- Да --> C[Запуск Монитор-Потока];
    C --> D[Запуск Основного Цикла и HTTP Сервера];
    B -- Нет --> D;
    D --> E{Изменения в файлах?};
    E -- Да --> F[Graceful Shutdown HTTP Server];
    F --> G[Перезагрузка Модулей (importlib.reload)];
    G --> H[Перезапуск HTTP Server];
    H --> D;
    E -- Нет --> I[Ожидание];
    I --> J[Повторная проверка];
    J --> E;
```

## 3. Детальный план реализации

### Шаг 3.1: Добавление аргумента `--dev`

1.  **Файл:** [`src/main_server_api.py`](src/main_server_api.py)
2.  **Изменения:**
    *   Использовать [`argparse`](python.argparse) для добавления опционального аргумента `--dev`.
    *   По умолчанию `--dev` будет `False`. Если аргумент передан, значение станет `True`.

    ```python
    # src/main_server_api.py
    # ...
    parser.add_argument("--dev", action="store_true", help="Enable development mode with auto-reload")
    args = parser.parse_args()
    # ...
    if args.dev:
        # Запуск монитора
        pass
    ```

### Шаг 3.2: Определение файлов для мониторинга

1.  **Файлы для мониторинга:**
    *   [`src/main_server_api.py`](src/main_server_api.py)
    *   [`src/monitor/console.py`](src/monitor/console.py)
    *   [`src/runtime/loop.py`](src/runtime/loop.py)
    *   [`src/state/self_state.py`](src/state/self_state.py)
2.  **Изменения:** Создать список этих файлов в `main_server_api.py` или в отдельном конфигурационном файле (предпочтительно в `main_server_api.py` для простоты).

### Шаг 3.3: Реализация мониторинга изменений файлов

1.  **Файл:** [`src/main_server_api.py`](src/main_server_api.py) (или новый файл, например, `src/reloader.py` для лучшей модульности)
2.  **Изменения:**
    *   **Функция `_check_for_changes()`:**
        *   Получать время последней модификации (mtime) для каждого файла в списке с помощью [`os.stat(filepath).st_mtime`](python.os.stat().st_mtime).
        *   Хранить эти значения в словаре `{'filepath': mtime}`.
        *   При каждом вызове сравнивать текущее `mtime` с сохраненным. Если есть разница, значит, файл изменился.
    *   **Daemon-thread `monitor_thread()`:**
        *   Запускаться только если `args.dev` имеет значение `True`.
        *   В бесконечном цикле каждые `N` секунд (например, 1 секунда) вызывать `_check_for_changes()`.
        *   При обнаружении изменения:
            *   Логировать сообщение об обнаружении изменения и запуске перезагрузки.
            *   Устанавливать флаг, указывающий на необходимость перезагрузки.
            *   Оповещать основной поток о необходимости перезагрузки (например, с помощью [`threading.Event`](python.threading.Event)).

### Шаг 3.4: Graceful Shutdown HTTP Server

1.  **Файл:** [`src/main_server_api.py`](src/main_server_api.py)
2.  **Изменения:**
    *   В функции `start_api_server`:
        *   Добавить механизм, позволяющий дождаться завершения потока сервера. `HTTPServer` не имеет встроенного метода `shutdown()` для потока. Можно использовать флаг или [`Event`](python.threading.Event) для сигнализации потоку о необходимости завершения работы.
        *   Альтернативно, если сервер запущен в отдельном `daemon=True` потоке, можно просто остановить основной цикл и запустить его заново, позволив старому потоку сервера завершиться по необходимости или убить его.
        *   Но для "graceful shutdown" лучше использовать `server.shutdown()` и `server.server_close()`, если сервер запущен в основном потоке. Если же он в отдельном потоке, то необходимо передать объект сервера для его корректного завершения.

    ```python
    # src/main_server_api.py
    class StoppableHTTPServer(HTTPServer):
        def serve_forever(self, poll_interval=0.5):
            self.stopped = False
            while not self.stopped:
                self.handle_request()

        def shutdown(self):
            self.stopped = True
            # Можно добавить заглушку для выхода из handle_request()
            # threading.Thread(target=self.serve_close).start() # Для выхода из handle_request
            self.server_close() # В реальной реализации serve_forever()
    ```

    *   Если сервер запущен в отдельном потоке, необходимо иметь ссылку на объект `server`, чтобы вызвать `server.shutdown()`.

### Шаг 3.5: Перезагрузка модулей (`importlib.reload`)

1.  **Файл:** [`src/main_server_api.py`](src/main_server_api.py)
2.  **Изменения:**
    *   При обнаружении изменения, когда флаг перезагрузки установлен:
    *   Использовать `importlib.reload()` для каждого измененного модуля.
    *   Важно: порядок перезагрузки может быть важен. Перезагружать сначала зависимые модули (например, `console.py`, `loop.py`, `self_state.py`), а затем основной модуль (`main_server_api.py`).

    ```python
    import importlib
    # ...
    # Перед перезагрузкой
    # Логика graceful shutdown сервера

    # Перезагрузка
    modules_to_reload = [
        monitor.console, # или 'monitor.console' если динамически
        runtime.loop,
        state.self_state,
        main_server_api # Сам текущий модуль
    ]
    for module in modules_to_reload:
        importlib.reload(module)
    ```

### Шаг 3.6: Перезапуск сервера

1.  **Файл:** [`src/main_server_api.py`](src/main_server_api.py)
2.  **Изменения:**
    *   После перезагрузки модулей, необходимо заново запустить HTTP сервер в новом потоке.
    *   Метод `start_api_server` должен быть адаптирован для того, чтобы им можно было воспользоваться несколько раз.

### Шаг 3.7: Обеспечение reload без полной перезагрузки процесса

1.  **Ключевые аспекты:**
    *   Использование `daemon-thread` для монитора позволяет основному процессу не зависеть от него при завершении.
    *   `importlib.reload()` перезагружает модуль *в текущем процессе*, а не запускает новый процесс Python. Это критично.
    *   Сохранение состояния `self_state` между перезагрузками: `self_state` передается как аргумент в `run_loop` и `start_api_server`. Убедиться, что `self_state` не сбрасывается при перезагрузке (он должен быть инициализирован один раз).

### Шаг 3.8: Логирование

1.  **Файл:** [`src/monitor/console.py`](src/monitor/console.py) или добавить в `main_server_api.py` простой `print`.
2.  **Изменения:** Добавить логирование на ключевых этапах:
    *   `--dev` режим включен.
    *   Монитор запущен.
    *   Обнаружено изменение в файле `<filename>`.
    *   Начало перезагрузки.
    *   Сервер остановлен.
    *   Модули перезагружены.
    *   Сервер перезапущен.

### Шаг 3.9: Тестирование

1.  **Сценарий:**
    *   Запустить сервер с аргументом `--dev`.
    *   Открыть консоль и убедиться, что монитор запущен (если есть логи).
    *   Изменить содержимое одного из отслеживаемых файлов (например, добавить `print("Hello Reload!")` в [`src/monitor/console.py`](src/monitor/console.py)).
    *   Сохранить файл.
    *   В консоли должны появиться логи о перезагрузке.
    *   При следующем запросе к `/status` (или любом другом взаимодействии, которое использует измененный модуль) должны быть видны изменения (например, "Hello Reload!" в логах).

## 4. Необходимые изменения в коде (высокоуровнево)

### [`src/main_server_api.py`](src/main_server_api.py)

*   Добавление `--dev` аргумента в [`argparse`](python.argparse).
*   Создание функции `start_reloader(files_to_watch, interval, server_instance_ref, event_for_reload)` которая будет запускать `daemon-thread` для мониторинга.
*   Функция `start_api_server` будет возвращать объект `server`, на который можно ссылаться для `shutdown()`.
*   Рефакторинг блока `if __name__ == "__main__":` для управления жизненным циклом сервера и релоадера.

### [`src/runtime/loop.py`](src/runtime/loop.py) / [`src/monitor/console.py`](src/monitor/console.py) / [`src/state/self_state.py`](src/state/self_state.py)

*   Минимальные изменения, в основном связанные с импортированием и, возможно, добавлением логирования для демонстрации перезагрузки.

## 5. Заключение

Предложенный план обеспечивает реализацию автоматической перезагрузки модулей сервера с использованием стандартной библиотеки Python. Он включает в себя мониторинг изменений файлов, graceful shutdown HTTP сервера, перезагрузку модулей и повторный запуск сервера, при этом сохраняя состояние приложения. Это позволит значительно улучшить процесс разработки за счет автоматизации повторных операций.
