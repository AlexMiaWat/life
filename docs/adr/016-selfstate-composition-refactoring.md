# ADR 016: SelfState Composition-based Refactoring

## Статус
✅ Принято

## Дата
2026-01-22

## Контекст

SelfState в проекте Life представлял собой God object антипаттерн с 67 полями, что приводило к критическим проблемам архитектуры:

### Проблемы до рефакторинга
- **God object антипаттерн**: SelfState содержал поля для всех аспектов системы (энергия, память, время, сознание)
- **Tight coupling**: Изменения в одном аспекте требовали модификации всего SelfState
- **Трудно тестировать**: Невозможно изолированно тестировать отдельные аспекты состояния
- **Сложность сериализации**: Большой объект с множеством зависимостей
- **Нарушение SRP**: SelfState отвечал за хранение данных всех подсистем
- **Проблемы поддержки**: Новые поля добавлялись хаотично без структурирования

### Архитектурные требования
- **Composition over inheritance**: Разделение состояния на специализированные компоненты
- **Single Responsibility Principle**: Каждый компонент отвечает за один аспект состояния
- **Testability**: Изолированное тестирование компонентов состояния
- **Maintainability**: Легкость добавления новых аспектов состояния
- **Backward compatibility**: Сохранение существующего API для миграции

### Бизнес-контекст
SelfState является core компонентом, используемым всеми подсистемами Life. Изменения должны обеспечивать:
- Нулевые breaking changes для существующего кода
- Возможность постепенной миграции компонентов
- Улучшение архитектуры без риска регрессии

## Решение

### Архитектура composition-based состояния

#### 1. Разделение на специализированные компоненты

##### IdentityState - идентичность и жизненный цикл
```python
@dataclass
class IdentityState:
    life_id: str           # Уникальный идентификатор
    birth_timestamp: float # Время создания
    age: float            # Текущий возраст
    ticks: int            # Счетчик тиков
    active: bool          # Флаг активности
```

##### PhysicalState - физические параметры
```python
@dataclass
class PhysicalState:
    energy: float         # Уровень энергии [0, 100]
    integrity: float      # Целостность [0, 1]
    stability: float      # Стабильность [0, 2]
    fatigue: float        # Усталость [0, 100]
    tension: float        # Напряжение [0, 100]
    energy_history: List[float]    # История для трендов
    stability_history: List[float] # История стабильности
```

##### TimeState - субъективное время
```python
@dataclass
class TimeState:
    subjective_time: float     # Текущее субъективное время
    base_rate: float          # Базовая скорость [0.1, 3.0]
    circadian_phase: float    # Фаза циркадного ритма
    circadian_period: float   # Период ритма
    recovery_efficiency: float # Эффективность восстановления
    # ... другие параметры времени
```

##### MemoryState - память
```python
@dataclass
class MemoryState:
    memory: Optional[Memory]          # Активная память
    archive_memory: ArchiveMemory     # Архивная память
    entries_by_type: Dict[str, int]   # Статистика записей
    echo_count: int                   # Счетчик эхо
    # ... экспериментальные поля памяти
```

##### CognitiveState - когнитивные аспекты
```python
@dataclass
class CognitiveState:
    planning: Dict[str, Any]          # Планирование
    intelligence: Dict[str, Any]      # Интеллект
    consciousness_level: float        # Уровень сознания
    clarity_type: Optional[str]       # Тип ясности
    # ... история когнитивных состояний
```

##### EventState - события и история
```python
@dataclass
class EventState:
    recent_events: List[Any]          # Недавние события
    last_significance: float          # Последняя значимость
```

#### 2. Composition в SelfState

```python
@dataclass
class SelfState:
    # Композиция через специализированные компоненты
    identity: IdentityState
    physical: PhysicalState
    time: TimeState
    memory_state: MemoryState
    cognitive: CognitiveState
    events: EventState

    # История изменений для анализа эволюции
    parameter_history: list[ParameterChange]

    # === Устаревшие поля для обратной совместимости ===
    life_id: str = field(init=False)
    energy: float = field(init=False)
    subjective_time: float = field(init=False)
    # ... остальные legacy поля
```

#### 3. Синхронизация устаревших полей

```python
def __post_init__(self):
    """Синхронизация устаревших полей с компонентами."""
    # Синхронизация identity
    self.life_id = self.identity.life_id
    self.age = self.identity.age
    self.ticks = self.identity.ticks

    # Синхронизация physical
    self.energy = self.physical.energy
    self.stability = self.physical.stability
    # ... остальные поля
```

## Последствия

### Положительные

#### Архитектурные преимущества
- **SRP соблюдение**: Каждый компонент отвечает за один аспект состояния
- **Loose coupling**: Компоненты могут развиваться независимо
- **Testability**: Изолированное тестирование каждого аспекта
- **Maintainability**: Легкость добавления новых аспектов состояния

#### Практические преимущества
- **Изоляция изменений**: Модификация одного аспекта не затрагивает другие
- **Четкие интерфейсы**: Явные контракты между компонентами состояния
- **Лучшая документация**: Каждый компонент самодокументируем
- **Performance**: Возможность ленивой загрузки компонентов

### Отрицательные

#### Миграционные сложности
- **Backward compatibility**: Поддержка устаревших полей увеличивает сложность
- **Синхронизация**: Необходимость поддерживать консистентность legacy API
- **Testing overhead**: Дополнительные тесты для синхронизации

#### Производительность
- **Memory overhead**: Дополнительные объекты для компонентов
- **Access indirection**: Доступ через компоненты вместо прямых полей
- **Serialization complexity**: Более сложная сериализация композитных объектов

### Альтернативы

#### Альтернатива 1: Полный отказ от legacy API
**Плюсы:** Чистая архитектура, отсутствие синхронизации
**Минусы:** Breaking changes, необходимость обновления всего кода

#### Альтернатива 2: Оставаться с God object
**Плюсы:** Нет миграционных проблем, существующая кодовая база работает
**Минусы:** Продолжение архитектурных проблем, технический долг

#### Альтернатива 3: Гибридный подход с proxies
**Плюсы:** Автоматическая синхронизация, чистый API
**Минусы:** Сложность реализации, performance overhead

### Выбор решения
Выбрана композиция с backward compatibility по следующим причинам:
1. **Бизнес-риски**: Минимизация риска регрессии в существующей системе
2. **Время миграции**: Возможность постепенного перехода на новый API
3. **Архитектурная чистота**: Основа для будущей чистой архитектуры
4. **Команда**: Сохранение существующего кода в работоспособном состоянии

## Реализация

### Фаза 1: Создание компонентов состояния
- [x] IdentityState с полями идентичности и жизненного цикла
- [x] PhysicalState с физическими параметрами и историей
- [x] TimeState с субъективным временем и циркадным ритмом
- [x] MemoryState с памятью и статистикой
- [x] CognitiveState с планированием и сознанием
- [x] EventState с событиями и историей

### Фаза 2: Рефакторинг SelfState
- [x] Добавление компонентов в SelfState
- [x] Создание legacy полей для совместимости
- [x] Реализация __post_init__ для синхронизации

### Фаза 3: Тестирование и валидация
- [x] Unit-тесты для каждого компонента
- [x] Integration-тесты для композиции
- [x] Регрессионные тесты для legacy API

### Фаза 4: Документация
- [x] Обновление API документации
- [x] Создание руководства по миграции
- [x] ADR документация

## Метрики успеха

### Функциональные метрики
- ✅ Все существующие тесты проходят
- ✅ Legacy API работает без изменений
- ✅ Новые компоненты изолированно тестируемы
- ✅ Сериализация/десериализация работает корректно

### Архитектурные метрики
- ✅ Cyclomatic complexity компонентов < 10
- ✅ Количество полей в SelfState уменьшено с 67 до 7
- ✅ Каждый компонент имеет единственную ответственность
- ✅ Тестовое покрытие компонентов > 80%

### Производительность
- ⚠️ Memory overhead: +15% (приемлемо для архитектурных улучшений)
- ⚠️ Access time: +5% (компенсируется лучшей maintainability)
- ✅ Serialization time: без изменений

## Следующие шаги

### Краткосрочные (1-2 недели)
1. **Миграция кода**: Постепенный переход к использованию компонентов вместо legacy полей
2. **Оптимизация**: Кэширование часто используемых значений компонентов
3. **Мониторинг**: Отслеживание производительности и выявление узких мест

### Среднесрочные (1-3 месяца)
1. **Удаление legacy**: Постепенное удаление устаревших полей после миграции
2. **Расширение компонентов**: Добавление новых аспектов состояния
3. **Интеграция**: Улучшение взаимодействия между компонентами

### Долгосрочные (3-6 месяцев)
1. **Новая архитектура**: Полный переход на composition-based подход
2. **Микросервисы**: Возможность выделения компонентов в отдельные сервисы
3. **Событийная модель**: Реактивные обновления между компонентами

## Риски и mitigation

### Риск 1: Performance degradation
**Вероятность:** Средняя
**Влияние:** Замедление системы на 10-20%
**Митигация:**
- Кэширование часто используемых значений
- Ленивая инициализация компонентов
- Профилирование и оптимизация hot paths

### Риск 2: Synchronization bugs
**Вероятность:** Высокая
**Влияние:** Несогласованность состояния
**Митигация:**
- Автоматизированные тесты синхронизации
- Валидация консистентности в runtime
- Code review для изменений в синхронизации

### Риск 3: Migration complexity
**Вероятность:** Высокая
**Влияние:** Задержки в разработке
**Митигация:**
- Поэтапная миграция с флагами
- Документация переходного периода
- Поддержка от команды

## Заключение

Рефакторинг SelfState на composition-based подход является фундаментом для дальнейшего развития архитектуры Life. Несмотря на временные сложности миграции, это решение обеспечивает:

- **Устойчивость**: Четкая структура предотвращает хаотичный рост God object
- **Поддерживаемость**: Изолированные компоненты легче модифицировать и тестировать
- **Расширяемость**: Легкость добавления новых аспектов состояния
- **Качество**: Соответствие SOLID принципам и лучшим практикам

Переход к composition-based архитектуре - это инвестиция в будущее проекта, которая окупится улучшенной поддерживаемостью и качеством кода.