# ADR 008: MCP index architecture

## Статус
✅ Принято

## Дата
2026-01-20

## Контекст

MCP (Model Context Protocol) сервер для проекта Life должен предоставлять быстрый доступ к документации. Требования:

- **Масштабируемость**: обработка тысяч файлов документации
- **Производительность**: поиск за миллисекунды, не секунды
- **Расширяемость**: поддержка разных провайдеров поиска (индекс, LLM, etc.)
- **Надежность**: graceful degradation при проблемах с индексом
- **Эффективность**: минимальное использование памяти и CPU

Проблема: как организовать поиск по большой базе документации с поддержкой разных стратегий поиска?

## Решение

### Архитектура IndexEngine

#### Кэш содержимого файлов

```python
# LRU кэш для содержимого файлов
self.content_cache: OrderedDict[str, str] = OrderedDict()
```

- **LRU eviction**: автоматическое удаление редко используемых файлов
- **Ограничение размера**: `cache_size_limit` (по умолчанию 10000 файлов)
- **Отслеживание изменений**: проверка `mtime` файлов для инвалидации

#### Инвертированный индекс

```python
# Инвертированный индекс: токен -> множество файлов
self.inverted_index: dict[str, set[str]] = {}
```

- **Быстрый поиск**: O(1) доступ к списку файлов по токену
- **Токенизация**: извлечение значимых токенов из содержимого
- **Фильтрация**: исключение стоп-слов и нормализация

#### Автоматическое индексирование

```python
def index_directory(self, directory: Path, pattern: str):
    """Рекурсивное индексирование директории с файлами."""
```

- **Глоб patterns**: поддержка `*.md`, `docs/**/*.md` и т.д.
- **Ограничение размера**: файлы > 10MB пропускаются
- **Инкрементальное обновление**: только измененные файлы переиндексируются

### Multi-provider архитектура поиска

#### Абстракция SearchProvider

```python
class SearchProvider(ABC):
    @abstractmethod
    def search(self, directory: Path, query: str, mode: str, limit: int) -> list[dict]:
        """Выполняет поиск в директории."""

    @abstractmethod
    def is_available(self) -> bool:
        """Проверяет доступность провайдера."""
```

#### SearchManager

```python
class SearchManager:
    """Менеджер провайдеров поиска с fallback стратегией."""

    def add_provider(self, provider: SearchProvider):
        """Добавляет провайдера в цепочку поиска."""

    def search(self, directory: Path, query: str, mode: str, limit: int) -> list[dict]:
        """Выполняет поиск через доступные провайдеры."""
```

#### Реализации провайдеров

- **IndexSearchProvider**: поиск через инвертированный индекс
- **LLMSearchProvider**: поиск через LLM (опционально, для fallback)

### Режимы поиска

#### AND режим
```
query: "runtime loop"
tokens: ["runtime", "loop"]
result: файлы, содержащие И "runtime" И "loop"
```

#### OR режим
```
query: "runtime OR loop"
tokens: ["runtime", "loop"]
result: файлы, содержащие ИЛИ "runtime" ИЛИ "loop"
```

#### PHRASE режим
```
query: '"runtime loop"'
phrase: "runtime loop"
result: файлы, содержащие точную фразу "runtime loop"
```

### Оптимизации производительности

#### LRU кэш с ограничением размера

```python
def _ensure_cache_size_limit(self):
    """Обеспечивает ограничение размера кэша."""
    while len(self.content_cache) > self.cache_size_limit:
        # Удаляем самый старый элемент
        self.content_cache.popitem(last=False)
```

#### Проверка изменений файлов

```python
def _is_file_changed(self, file_path: str) -> bool:
    """Проверяет, изменился ли файл с момента последней индексации."""
    current_mtime = os.path.getmtime(file_path)
    return current_mtime != self.file_mtimes.get(file_path)
```

#### Ограничение размера индексируемых файлов

```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB
```

#### Батчинг операций

- Ленивая инициализация индекса
- Инкрементальное обновление только измененных файлов
- Отложенная токенизация при первом поиске

### Fallback стратегия

```python
def search(self, directory: Path, query: str, mode: str, limit: int) -> list[dict]:
    """Поиск с fallback: IndexSearch -> LLMSearch (если настроен)."""
    for provider in self.providers:
        if provider.is_available():
            try:
                results = provider.search(directory, query, mode, limit)
                if results:  # Возвращаем результаты первого успешного провайдера
                    return results
            except Exception as e:
                logger.warning(f"Provider {provider.get_name()} failed: {e}")
                continue
    return []  # Если все провайдеры недоступны
```

## Обоснование

### За выбранное решение

- **Производительность**: инвертированный индекс обеспечивает поиск O(1) по токенам
- **Масштабируемость**: LRU кэш и ограничения размера позволяют работать с тысячами файлов
- **Расширяемость**: абстракция SearchProvider позволяет добавлять новые провайдеры
- **Надежность**: fallback стратегия обеспечивает работоспособность при проблемах
- **Эффективность**: минимальное использование ресурсов через оптимизации

### Против альтернатив

#### Альтернатива 1: Полнотекстовый поиск без индекса
- **Против**: O(N) сканирование всех файлов на каждый поиск
- **Против**: неприемлемая производительность для больших баз

#### Альтернатива 2: Внешние поисковые движки (Elasticsearch)
- **Против**: дополнительная зависимость и сложность развертывания
- **Против**: overkill для документации проекта

#### Альтернатива 3: Только LLM поиск
- **Против**: дорогой (API calls) и медленный
- **Против**: зависит от качества модели и доступности API
- **Против**: не подходит для точного поиска фактов

## Последствия

### Положительные

- ✅ **Высокая производительность**: поиск за миллисекунды через индекс
- ✅ **Масштабируемость**: эффективная работа с тысячами файлов
- ✅ **Расширяемость**: легкое добавление новых провайдеров поиска
- ✅ **Надежность**: fallback стратегия и graceful degradation
- ✅ **Эффективность**: оптимизации памяти и CPU через кэширование

### Отрицательные

- ⚠️ **Сложность**: multi-provider архитектура добавляет абстракции
- ⚠️ **Память**: кэш содержимого занимает память
- ⚠️ **Задержки**: начальная индексация больших баз может быть медленной

### Риски

- **Устаревание индекса**: файлы меняются, но индекс не обновляется
  - **Митигация**: проверка mtime при каждом поиске, автоматическое переиндексирование
- **Переполнение памяти**: кэш растет бесконечно
  - **Митигация**: LRU eviction и ограничение размера кэша
- **Сложность отладки**: multi-provider логика может маскировать проблемы
  - **Митигация**: подробное логирование и метрики производительности

## Связанные документы

- [docs/testing/MCP_TESTING_GUIDE.md](../testing/MCP_TESTING_GUIDE.md) — руководство по тестированию MCP
- [mcp_index.py](../../mcp_index.py) — основной MCP сервер
- [mcp_index_engine.py](../../mcp_index_engine.py) — движок индексации
- [mcp_search_provider.py](../../mcp_search_provider.py) — multi-provider архитектура
- [src/test/test_mcp_index.py](../../src/test/test_mcp_index.py) — тесты индексации
