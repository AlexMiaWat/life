# ADR 005: Runtime Loop Managers

## Статус
✅ Принято

## Дата
2026-01-20

## Контекст

Runtime Loop (`src/runtime/loop.py`) содержал слишком много ответственности:
- Управление периодичностью снапшотов
- Буферизация и сброс логов на каждом тике
- Логика определения слабости и расчета штрафов
- Использование `print()` для отладочного вывода

Это создавало проблемы:
- **Производительность**: регулярный I/O на каждом тике замедляет hot-path
- **Тестируемость**: сложно тестировать отдельные аспекты поведения
- **Читаемость**: смешение ответственности усложняет понимание кода
- **Конфигурируемость**: константы разбросаны по коду, сложно менять политики

## Решение

Выделить три специализированных менеджера для инкапсуляции ответственности:

### 1. SnapshotManager

**Файл:** `src/runtime/snapshot_manager.py`

**Ответственность:**
- Управление периодичностью создания снапшотов
- Изоляция I/O операций от основного цикла
- Обработка ошибок снапшотов без падения цикла

**API:**
```python
class SnapshotManager:
    def __init__(self, period_ticks: int, saver: Callable[[SelfState], None])
    def should_snapshot(self, ticks: int) -> bool
    def maybe_snapshot(self, self_state: SelfState) -> bool
```

**Преимущества:**
- Явная периодичность через `period_ticks`
- Ошибки снапшотов не роняют основной цикл
- Легко тестировать отдельно

### 2. LogManager

**Файл:** `src/runtime/log_manager.py`

**Ответственность:**
- Управление буферизацией и сбросом логов
- Убирает регулярный I/O из hot-path runtime loop
- Flush происходит по расписанию, а не на каждом тике

**API:**
```python
class FlushPolicy:
    def __init__(
        self,
        flush_period_ticks: int = 10,
        flush_before_snapshot: bool = True,
        flush_on_exception: bool = True,
        flush_on_shutdown: bool = True,
    )

class LogManager:
    def __init__(self, flush_policy: FlushPolicy, flush_fn: Callable[[], None])
    def maybe_flush(
        self,
        self_state: SelfState,
        *,
        phase: Literal["tick", "before_snapshot", "exception", "shutdown"],
        snapshot_was_made: bool = False,
    ) -> None
```

**Преимущества:**
- Flush только когда нужно (периодически, перед снапшотом, при ошибках, при завершении)
- Конфигурируемая политика через `FlushPolicy`
- Улучшенная производительность (нет I/O на каждом тике)

**Разделение ответственности с SelfState:**

`LogManager` управляет **политическими flush** (когда делать flush по расписанию), в то время как `SelfState` выполняет **защитные flush** (критичные для предотвращения потери данных):

- **LogManager (политические flush):**
  - Периодический flush (раз в N тиков)
  - Flush перед/после снапшота
  - Flush при исключениях
  - Flush при завершении

- **SelfState (защитные flush):**
  - Автоматический flush при переполнении буфера (предотвращает потерю данных)
  - Flush при изменении размера буфера (предотвращает потерю данных)
  - Flush при включении/отключении логирования (консистентность состояния)

Защитные flush в `SelfState` вызываются синхронно при изменении конфигурации или переполнении буфера и не зависят от политики `LogManager`. Это обеспечивает надежность системы и предотвращает потерю данных независимо от настроек политики flush.

### 3. LifePolicy

**Файл:** `src/runtime/life_policy.py`

**Ответственность:**
- Инкапсуляция логики определения слабости и расчета штрафов
- Делает политику явной, конфигурируемой и тестируемой

**API:**
```python
class LifePolicy:
    def __init__(
        self,
        weakness_threshold: float = 0.05,
        penalty_k: float = 0.02,
        stability_multiplier: float = 2.0,
        integrity_multiplier: float = 2.0,
    )
    def is_weak(self, self_state: SelfState) -> bool
    def weakness_penalty(self, dt: float) -> dict[str, float]
```

**Преимущества:**
- Чистая функция без side effects
- Конфигурируемые параметры вместо констант
- Легко тестировать отдельно
- Значения по умолчанию совпадают с предыдущими константами

### Улучшение логирования

**Проблема:** Использование `print()` в hot-path создавало неконтролируемый вывод.

**Решение:** Все `print()` заменены на `logger.debug/info/error` с соответствующими уровнями:
- `logger.debug()` для детальной отладочной информации (выключается по умолчанию)
- `logger.info()` для информационных сообщений
- `logger.error()` для ошибок с полным traceback

## Обоснование

### За выделение менеджеров

- **Разделение ответственности**: каждый менеджер отвечает за одну задачу
- **Тестируемость**: каждый менеджер тестируется отдельно
- **Производительность**: I/O операции вынесены из hot-path
- **Конфигурируемость**: политики явные и настраиваемые
- **Изоляция ошибок**: ошибки менеджеров не роняют основной цикл

### Против выделения менеджеров

- **Дополнительная сложность**: больше классов и файлов
- **Потенциальное over-engineering**: для простых задач может быть избыточно

### Компромисс

Выделение менеджеров оправдано, так как:
1. Runtime Loop — критичный компонент, требующий высокой производительности
2. Менеджеры решают реальные проблемы (производительность, тестируемость)
3. Код стал более читаемым и поддерживаемым
4. Все менеджеры покрыты unit-тестами

## Последствия

### Положительные

- ✅ Улучшенная производительность (I/O операции вынесены из hot-path)
- ✅ Лучшая тестируемость (каждый менеджер тестируется отдельно)
- ✅ Явная политика (конфигурируемые параметры вместо констант)
- ✅ Изоляция ошибок (ошибки менеджеров не роняют основной цикл)
- ✅ Контролируемое логирование (стандартный logging вместо print)
- ✅ Улучшенная читаемость кода (разделение ответственности)

### Отрицательные

- ⚠️ Дополнительная сложность (больше классов и файлов)
- ⚠️ Необходимость обновления документации
- ⚠️ Потенциальная необходимость миграции существующего кода

### Риски

- **Регрессии поведения**: значения по умолчанию должны совпадать с предыдущими константами
  - **Митигация**: unit-тесты проверяют совместимость
- **Производительность менеджеров**: менеджеры должны быть легковесными
  - **Митигация**: менеджеры не выполняют тяжелых операций, только управляют политикой
- **Сложность конфигурации**: слишком много параметров может усложнить использование
  - **Митигация**: все параметры имеют разумные значения по умолчанию

## Реализация

### Измененные файлы

- `src/runtime/loop.py` — интеграция менеджеров
- `src/runtime/snapshot_manager.py` — новый файл
- `src/runtime/log_manager.py` — новый файл
- `src/runtime/life_policy.py` — новый файл
- `src/test/test_runtime_loop_managers.py` — unit-тесты

### Миграция

Все изменения обратно совместимы:
- Значения по умолчанию совпадают с предыдущими константами
- Поведение не изменилось, только структура кода
- Существующие тесты продолжают работать

### Тестирование

Все менеджеры покрыты unit-тестами:
- Делегирование ответственности менеджерам
- Отсутствие регрессий поведения
- Корректность политик и расчетов
- Обработка ошибок

## Связанные документы

- [docs/components/runtime-loop.md](../components/runtime-loop.md) — документация Runtime Loop
- [docs/components/self-state.md](../components/self-state.md) — документация SelfState
- [src/runtime/snapshot_manager.py](../../src/runtime/snapshot_manager.py) — реализация SnapshotManager
- [src/runtime/log_manager.py](../../src/runtime/log_manager.py) — реализация LogManager
- [src/runtime/life_policy.py](../../src/runtime/life_policy.py) — реализация LifePolicy
- [src/test/test_runtime_loop_managers.py](../../src/test/test_runtime_loop_managers.py) — тесты менеджеров
