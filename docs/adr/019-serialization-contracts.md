# ADR 019: Архитектурные контракты сериализации

## Статус
✅ **Принято**

## Контекст
После анализа критических проблем в задаче 1769063179 выявлено отсутствие стандартизированных интерфейсов для сериализации компонентов. Методы `to_dict()` были добавлены без архитектурных гарантий, что привело к проблемам с thread-safety, эффективностью и отказоустойчивостью.

## Решение
Внедрить систему архитектурных контрактов для сериализации, которая обеспечивает:

1. **Стандартизированные интерфейсы** через `SerializationContract` и `Serializable` протокол
2. **Архитектурные гарантии** для всех сериализуемых компонентов
3. **Thread-safety обертки** для компонентов без встроенной защиты
4. **Отказоустойчивость** и graceful degradation при ошибках

## Архитектурные контракты

### 1. Serializable Protocol
```python
class Serializable(Protocol):
    def to_dict(self) -> Dict[str, Any]: ...
```

Базовый протокол для всех сериализуемых компонентов.

### 2. SerializationContract (ABC)
```python
class SerializationContract(ABC):
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]: ...

    @abstractmethod
    def get_serialization_metadata(self) -> Dict[str, Any]: ...
```

Полный контракт с гарантиями:
- **Thread-safety**: Метод безопасен для вызова из разных потоков
- **Атомарность**: Сериализация представляет консистентное состояние
- **Отказоустойчивость**: Исключения не должны повреждать внутреннее состояние
- **Эффективность**: Сериализация должна быть эффективной по ресурсам
- **Детерминированность**: Одинаковое состояние -> одинаковый результат

### 3. ThreadSafeSerializer
Обертка для обеспечения thread-safety компонентов без встроенной защиты.

## Гарантии контрактов

### Thread-safety
- Методы должны быть безопасны для конкурентного доступа
- Для компонентов без встроенной защиты использовать `ThreadSafeSerializer`
- Документировать стратегию синхронизации

### Атомарность
- Сериализация должна захватывать консистентное состояние
- Избегать частичных обновлений во время сериализации
- Использовать snapshot-based подходы при необходимости

### Отказоустойчивость
- Исключения не должны повреждать внутреннее состояние компонента
- Graceful degradation: возвращать частичные данные вместо полного отказа
- Логирование ошибок для отладки

### Эффективность
- Избегать O(n²) алгоритмов для больших коллекций
- Использовать lazy evaluation где возможно
- Кэширование для часто запрашиваемых данных

### Детерминированность
- Одинаковые входные данные дают одинаковый результат
- Исключить влияние внешнего состояния (время, random и т.д.)
- Версионирование форматов для обратной совместимости

## Структура сериализованных данных

### Стандартный формат
```python
{
    "metadata": {
        "version": str,           # Версия формата
        "timestamp": float,       # Время сериализации
        "component_type": str,    # Тип компонента
        "checksum": str,          # Контрольная сумма (опционально)
        "warnings": [str]         # Предупреждения (опционально)
    },
    "data": Any                  # Собственные данные компонента
}
```

### Композитный формат (для сложных компонентов)
```python
{
    "metadata": {...},
    "components": {
        "component_name": serialized_component_data,
        ...
    },
    "legacy_fields": {...}  # Для обратной совместимости
}
```

## Реализация

### Файлы
- `src/contracts/serialization_contract.py` - Определения контрактов
- `src/test/integration_serialization_test.py` - Интеграционные тесты

### Использование
```python
# Простой компонент
class MyComponent(SerializationContract):
    def to_dict(self) -> Dict[str, Any]:
        return {"field": self.field}

# Thread-safe обертка
safe_component = ThreadSafeSerializer(MyComponent(), lock=my_lock)
```

## Преимущества

1. **Стандартизация**: Единые интерфейсы для всех компонентов
2. **Безопасность**: Гарантии thread-safety и отказоустойчивости
3. **Поддерживаемость**: Четкие контракты упрощают поддержку
4. **Тестируемость**: Контракты позволяют автоматизированное тестирование
5. **Расширяемость**: Легко добавлять новые сериализуемые компоненты

## Риски и mitigation

### Производительность
- **Риск**: Дополнительные накладные расходы на синхронизацию
- **Mitigation**: Использовать lock-free структуры где возможно, оптимизировать горячие пути

### Сложность
- **Риск**: Увеличение сложности кода
- **Mitigation**: Четкая документация, примеры использования, автоматизированные тесты

### Миграция
- **Риск**: Сложность миграции существующих компонентов
- **Mitigation**: Постепенная миграция, обратная совместимость, флаги возможностей

## Альтернативы

### 1. Без контрактов
- **Плюсы**: Простота, гибкость
- **Минусы**: Отсутствие гарантий, race conditions, низкая поддерживаемость

### 2. Строгие контракты (только ABC)
- **Плюсы**: Строгая типизация, гарантии
- **Минусы**: Сложность, overhead для простых компонентов

### Выбор: Гибридный подход
Комбинация протоколов (гибкость) и ABC (гарантии) позволяет балансировать между простотой и надежностью.

## Последствия

### Положительные
- Стандартизированная сериализация во всей системе
- Улучшенная надежность и поддерживаемость
- Лучшее покрытие тестами
- Проще добавлять новые компоненты

### Отрицательные
- Увеличение сложности кода
- Дополнительные накладные расходы на runtime
- Необходимость миграции существующих компонентов

## Метрики успеха
- 100% компонентов следуют контрактам
- 0 race conditions в сериализации
- <5% overhead на сериализацию
- Полное покрытие интеграционными тестами