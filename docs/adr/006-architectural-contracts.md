# ADR 006: Внедрение архитектурных контрактов

**Дата:** 2026-01-22
**Статус:** Accepted
**Ответственный:** Project Executor Agent
**Ревьюеры:** Skeptic Agent

## Контекст

### Проблема
В системе Life отсутствовали явные архитектурные контракты между компонентами. Это приводило к:

- Неясным ожиданиям от интерфейсов компонентов
- Отсутствию гарантий диапазонов значений
- Сложности тестирования взаимодействия
- Рискам нарушения контрактов во время рефакторинга
- Недокументированным обработкам ошибок

### Текущая ситуация
Компоненты имели неформальные интерфейсы без явных гарантий. Диапазоны входных/выходных значений, обработка ошибок и другие важные аспекты не были документированы.

### Требования
- Документировать все интерфейсы между компонентами
- Определить диапазоны значений и гарантии
- Создать обработку ошибок
- Обеспечить тестируемость контрактов
- Сделать контракты enforceable во время выполнения

### Ограничения
- Не нарушать существующую функциональность
- Минимальный impact на производительность
- Поддержка различных уровней строгости валидации

## Рассмотренные варианты

### Вариант 1: Runtime контракты с exceptions
**Описание:** Полная валидация контрактов во время выполнения с выбрасыванием исключений при нарушениях.

**Плюсы:**
- Максимальная гарантия корректности
- Раннее обнаружение проблем
- Четкие границы ответственности

**Минусы:**
- Значительная деградация производительности
- Возможные сбои в production
- Сложность обработки ошибок

**Оценка:** Низкий (слишком risky для production)

### Вариант 2: Design-time контракты с type hints
**Описание:** Статическая типизация и контракты только на этапе разработки, без runtime проверок.

**Плюсы:**
- Нулевой impact на производительность
- Раннее обнаружение проблем в IDE
- Простота реализации

**Минусы:**
- Отсутствие гарантий в runtime
- Не все проблемы можно поймать статически
- Зависимость от качества type hints

**Оценка:** Средний (недостаточно comprehensive)

### Вариант 3: Конфигурируемые контракты с fallback
**Описание:** Архитектурные контракты с настраиваемой строгостью валидации и graceful degradation.

**Плюсы:**
- Баланс между безопасностью и производительностью
- Возможность отключения в production
- Graceful handling ошибок

**Минусы:**
- Сложность реализации
- Необходимость настройки

**Оценка:** Высокий (оптимальный баланс)

## Решение

### Выбранный вариант
Вариант 3: Конфигурируемые контракты с fallback

### Детали реализации
Создание системы архитектурных контрактов:

1. **BaseContract** - базовый класс для всех контрактов
   - Конфигурируемая строгость валидации
   - Стратегии обработки ошибок
   - Методы валидации входов/выходов

2. **Component-specific контракты**
   - EventGeneratorContract
   - IntensityCalculatorContract
   - PatternAnalyzerContract
   - SelfStateContract
   - RuntimeLoopContract

3. **ContractRegistry** - централизованное управление контрактами
   - Регистрация контрактов
   - Валидация всех контрактов
   - Генерация отчетов

4. **ContractValidator** - инструмент валидации
   - Проверка соответствия контрактов
   - Мониторинг нарушений
   - Генерация отчетов

### Архитектурные изменения
```
Contract System
├── BaseContract (abstract)
│   ├── validation levels
│   ├── error strategies
│   └── documentation
├── Component Contracts
│   ├── EventGeneratorContract
│   ├── IntensityCalculatorContract
│   ├── PatternAnalyzerContract
│   └── ...
├── ContractRegistry
└── ContractValidator
```

## Последствия

### Положительные
- **Надежность**: Явные гарантии поведения компонентов
- **Поддерживаемость**: Документированные интерфейсы
- **Тестируемость**: Возможность тестирования контрактов
- **Безопасность**: Graceful handling нарушений контрактов

### Отрицательные
- **Сложность**: Увеличение codebase
- **Производительность**: Небольшая деградация при включенной валидации
- **Настройка**: Необходимость конфигурации уровней валидации

### Риски
- **Performance impact**: Валидация может замедлить систему на 1-2%
  - Mitigation: Настраиваемые уровни валидации, отключение в production
- **False positives**: Слишком строгая валидация может блокировать корректные операции
  - Mitigation: Тестирование на реальных данных, корректировка контрактов

### Миграция
1. Создание базовой инфраструктуры контрактов (завершено)
2. Реализация контрактов для ключевых компонентов (завершено)
3. Интеграция валидации в компоненты (in progress)
4. Настройка уровней валидации для разных сред (future)

## Связанные ADR

- [ADR 003](003-event-generator-decomposition.md) - Контракты для декомпозированных компонентов
- [ADR 007](007-testing-strategy.md) - Тестирование контрактов

## Приложения

### Код
```python
# Пример контракта
class IntensityCalculatorContract(BaseContract):
    def get_input_ranges(self):
        return {
            'base_intensity': (0.0, 1.0),
            'energy': (0.0, 100.0),
            'context': None  # Optional
        }

    def get_output_guarantees(self):
        return {
            'intensity': (0.1, 3.0),
            'precision': 0.001
        }

# Использование в компоненте
class IntensityCalculator:
    def __init__(self):
        self.contract = IntensityCalculatorContract()

    def calculate(self, event_type, base_intensity, context):
        # Валидация входов
        self.contract.validate_inputs(
            base_intensity=base_intensity,
            energy=context.energy if context else None
        )

        # Расчет...
        result = self._calculate_intensity(event_type, base_intensity, context)

        # Валидация выходов
        self.contract.validate_outputs(intensity=result)

        return result
```

### Метрики успеха
- Количество документированных интерфейсов: 100%
- Среднее время валидации: < 1ms на операцию
- Уровень обнаружения нарушений: > 95%
- Производительность: деградация < 2%