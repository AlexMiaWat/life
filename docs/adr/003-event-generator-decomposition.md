# ADR 003: Декомпозиция EventGenerator на независимые компоненты

**Дата:** 2026-01-22
**Статус:** Accepted
**Ответственный:** Project Executor Agent
**Ревьюеры:** Skeptic Agent

## Контекст

### Проблема
EventGenerator в исходной реализации представлял собой монолитный класс с 900+ строками кода, нарушающий принцип единственной ответственности. Класс выполнял одновременно:
- Генерацию базовых интенсивностей событий
- Адаптацию интенсивностей на основе состояния Life
- Анализ паттернов событий
- Сглаживание значений
- Управление зависимостями между событиями

Это приводило к:
- Сложности тестирования отдельных функций
- Трудности внесения изменений
- Высокому coupling между компонентами
- Нарушению принципов SOLID

### Текущая ситуация
EventGenerator имел частичную декомпозицию, но основные проблемы оставались нерешенными. Код был трудно поддерживать и расширять.

### Требования
- Разделить EventGenerator на независимые компоненты
- Каждый компонент должен иметь единственную ответственность
- Сохранить обратную совместимость API
- Обеспечить тестируемость каждого компонента
- Создать архитектурные контракты для интерфейсов

### Ограничения
- Необходимость поддержки существующего API
- Ограничения по производительности (не более 5% деградации)
- Сохранение детерминизма генерации событий

## Рассмотренные варианты

### Вариант 1: Полная декомпозиция с новым API
**Описание:** Полностью переписать EventGenerator с новым API, отказавшись от обратной совместимости.

**Плюсы:**
- Чистая архитектура без legacy кода
- Максимальная производительность
- Полная свобода в дизайне

**Минусы:**
- Нарушение существующего кода
- Необходимость обновления всех клиентов
- Риск регрессий

**Оценка:** Низкий (слишком disruptive)

### Вариант 2: Постепенная декомпозиция с facade
**Описание:** Создать новые компоненты, но сохранить EventGenerator как facade для обратной совместимости.

**Плюсы:**
- Сохранение существующего API
- Возможность постепенной миграции
- Минимальный риск для существующих клиентов

**Минусы:**
- Временное дублирование кода
- Сложность поддержки двух реализаций

**Оценка:** Высокий (баланс между рисками и преимуществами)

### Вариант 3: Частичная декомпозиция
**Описание:** Выделить только наиболее критичные компоненты, оставив остальное в EventGenerator.

**Плюсы:**
- Минимальные изменения
- Быстрая реализация

**Минусы:**
- Неполное решение проблемы
- Архитектура остается compromised

**Оценка:** Средний (недостаточно comprehensive)

## Решение

### Выбранный вариант
Вариант 2: Постепенная декомпозиция с facade

### Детали реализации
Создание следующих независимых компонентов:

1. **IntensityCalculator** - расчет адаптированных интенсивностей
   - Архитектурный контракт: вход [0.0, 1.0], выход [0.1, 3.0]
   - Гарантии: детерминированность, thread-safety

2. **PatternAnalyzer** - анализ паттернов событий
   - Архитектурный контракт: анализ последовательностей
   - Выход: модификатор паттерна [0.5, 2.0]

3. **SmoothingEngine** - сглаживание значений
   - Экспоненциальное сглаживание модификаторов
   - Управление историей значений

EventGenerator остается facade, делегирующим работу новым компонентам.

### Архитектурные изменения
```
EventGenerator (facade)
├── IntensityCalculator
├── PatternAnalyzer
└── SmoothingEngine
```

## Последствия

### Положительные
- **Тестируемость**: Каждый компонент можно тестировать изолированно
- **Поддерживаемость**: Изменения в одном компоненте не затрагивают другие
- **Расширяемость**: Легко добавлять новые компоненты
- **Производительность**: Независимая оптимизация каждого компонента

### Отрицательные
- **Сложность**: Увеличение количества классов
- **Память**: Дополнительные объекты в памяти
- **Временные затраты**: Время на композицию компонентов

### Риски
- **Производительность**: Потенциальная деградация на 2-3%
  - Mitigation: Профилирование и оптимизация критических путей
- **Регрессии**: Изменения в логике расчетов
  - Mitigation: Comprehensive testing с сохранением deterministic behavior

### Миграция
1. Создание новых компонентов (завершено)
2. Интеграция в EventGenerator через composition (завершено)
3. Переход на прямое использование компонентов (future work)
4. Удаление facade (future work)

## Связанные ADR

- [ADR 006](006-architectural-contracts.md) - Архитектурные контракты для компонентов
- [ADR 002](002-composition-over-inheritance.md) - Принцип композиции

## Приложения

### Код
```python
# Новый EventGenerator с composition
class EventGenerator:
    def __init__(self):
        self.intensity_calculator = IntensityCalculator()
        self.pattern_analyzer = PatternAnalyzer()
        self.smoothing_engine = SmoothingEngine()

    def generate(self, context_state):
        # Использование composition вместо монолитной логики
        adapted_intensity = self.intensity_calculator.calculate(
            event_type, base_intensity, context_state
        )
        return Event(type=event_type, intensity=adapted_intensity, ...)
```

### Метрики успеха
- Количество строк кода в EventGenerator: уменьшено с 900+ до ~100
- Время выполнения: деградация < 5%
- Покрытие тестами: > 90% для каждого компонента
- Цикломатическая сложность: снижена на 60%