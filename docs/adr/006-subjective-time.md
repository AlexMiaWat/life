# ADR 006: Subjective Time

## Статус
✅ Принято

## Дата
2026-01-20

## Контекст

Runtime Loop системы Life работает в физическом времени (секундах), но для моделирования восприятия времени системой нужно другое измерение — **субъективное время**. Субъективное время должно:

- **Отражать восприятие** системы: быстрее при высокой интенсивности событий, медленнее при низкой стабильности
- **Быть детерминированным**: одинаковые входные параметры дают одинаковый результат
- **Быть монотонным**: субъективное время всегда увеличивается
- **Интегрироваться** в runtime loop без нарушения производительности

Проблема: как преобразовать физический интервал времени (`dt`) в субъективное восприятие времени системой?

## Решение

### Философия субъективного времени

Субъективное время — это **метрика восприятия**, а не управляющий цикл. Оно отражает, как система "переживает" время:

- **Интенсивность событий** → время течет быстрее (система "занята")
- **Низкая стабильность** → время течет медленнее (система "замедляется")
- **Высокая энергия** → время течет быстрее (система "активна")

### Математическая модель

Субъективное время рассчитывается через **мультипликатор скорости**:

```
rate = base_rate + intensity_coeff * intensity + stability_term + energy_term

subjective_dt = dt * rate
```

Где:
- `intensity` ∈ [0..1]: интенсивность последнего события
- `stability` ∈ [0..1]: стабильность системы
- `energy` ∈ [0..100]: уровень энергии

### Экспоненциальное сглаживание интенсивности

Для предотвращения резких скачков интенсивность сглаживается экспоненциально:

```
smoothed_intensity = alpha * current_intensity + (1 - alpha) * previous_intensity
```

Где `alpha` ∈ [0..1] — коэффициент сглаживания (по умолчанию 0.3).

### API модуля subjective_time

```python
def compute_subjective_time_rate(
    *,
    base_rate: float = 1.0,
    intensity: float,
    stability: float,
    energy: float,
    intensity_coeff: float = 1.0,
    stability_coeff: float = 0.5,
    energy_coeff: float = 0.5,
    rate_min: float = 0.1,
    rate_max: float = 3.0,
) -> float:
    """Вычисляет мультипликатор скорости субъективного времени."""

def compute_subjective_dt(
    *,
    dt: float,
    base_rate: float = 1.0,
    # ... остальные параметры аналогично compute_subjective_time_rate
) -> float:
    """Вычисляет приращение субъективного времени."""
```

### Интеграция в Runtime Loop

На каждом тике runtime loop:

1. **Обновление интенсивности** с экспоненциальным сглаживанием
2. **Расчет субъективного времени** с учетом состояния системы
3. **Обновление состояния**: `self_state.apply_delta({"subjective_time": subjective_dt})`

### Параметры в SelfState

Модуль использует следующие параметры конфигурации:

- `subjective_time`: текущее значение субъективного времени
- `subjective_time_base_rate`: базовая скорость (1.0)
- `subjective_time_rate_min`: минимальная скорость (0.1)
- `subjective_time_rate_max`: максимальная скорость (3.0)
- `subjective_time_intensity_coeff`: коэффициент интенсивности (1.0)
- `subjective_time_stability_coeff`: коэффициент стабильности (0.5)
- `subjective_time_energy_coeff`: коэффициент энергии (0.5)
- `subjective_time_intensity_smoothing`: коэффициент сглаживания (0.3)
- `last_event_intensity`: сглаженная интенсивность [0..1]

## Обоснование

### За выбранное решение

- **Философская обоснованность**: модель отражает реальное восприятие времени живыми системами
- **Математическая простота**: линейная модель легко анализируется и оптимизируется
- **Производительность**: расчет выполняется на каждом тике без тяжелых операций
- **Конфигурируемость**: все коэффициенты можно настраивать через SelfState
- **Тестируемость**: чистые функции без side effects, легко покрываются unit-тестами

### Против альтернатив

#### Альтернатива 1: Нейронная сеть
- **Против**: слишком сложная для такой фундаментальной метрики
- **Против**: требует обучения, снижает детерминированность
- **Против**: замедляет hot-path runtime loop

#### Альтернатива 2: Сложные нелинейные формулы
- **Против**: усложняет анализ и отладку
- **Против**: параметры трудно интерпретировать
- **Против**: может привести к непредсказуемому поведению

#### Альтернатива 3: Прямое использование физического времени
- **Против**: не отражает восприятие времени системой
- **Против**: игнорирует внутреннее состояние и события

## Последствия

### Положительные

- ✅ **Реалистичное моделирование**: субъективное время отражает восприятие системы
- ✅ **Производительность**: минимальные накладные расходы в hot-path
- ✅ **Надежность**: детерминированные, монотонные функции
- ✅ **Гибкость**: легко настраивается через параметры SelfState
- ✅ **Тестируемость**: полное покрытие unit-тестами

### Отрицательные

- ⚠️ **Дополнительная сложность**: еще один слой абстракции времени
- ⚠️ **Конфигурирование**: много параметров для настройки
- ⚠️ **Документация**: требует объяснения философии субъективного времени

### Риски

- **Регрессии поведения**: изменения в формуле могут повлиять на симуляции
  - **Митигация**: unit-тесты проверяют монотонность и диапазоны
- **Производительность**: дополнительные расчеты на каждом тике
  - **Митигация**: простые арифметические операции, измерена производительность
- **Сложность отладки**: субъективное время отличается от физического
  - **Митигация**: логирование обоих времен, понятные названия параметров

## Связанные документы

- [docs/components/subjective-time.md](../components/subjective-time.md) — подробная документация API
- [docs/components/runtime-loop.md](../components/runtime-loop.md) — интеграция в runtime loop
- [docs/components/self-state.md](../components/self-state.md) — параметры состояния
- [src/runtime/subjective_time.py](../../src/runtime/subjective_time.py) — реализация
- [src/test/test_subjective_time.py](../../src/test/test_subjective_time.py) — тесты
