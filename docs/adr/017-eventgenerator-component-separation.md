# ADR 017: EventGenerator Component Separation

## Статус
✅ Принято

## Дата
2026-01-22

## Контекст

EventGenerator в проекте Life представлял собой компонент с множественной ответственностью, что приводило к проблемам поддерживаемости и тестируемости.

### Проблемы до рефакторинга
- **Монолитная структура**: EventGenerator содержал всю логику генерации, адаптации и анализа в одном классе
- **Нарушение SRP**: Генерация событий, расчет интенсивностей, анализ паттернов, сглаживание - в одном месте
- **Трудно тестировать**: Невозможно изолированно тестировать отдельные аспекты генерации
- **Высокая связность**: Изменения в одном аспекте затрагивали весь генератор
- **Сложность поддержки**: 900+ строк кода с множеством ответственностей

### Архитектурные требования
- **Single Responsibility Principle**: Каждый компонент отвечает за одну функцию
- **Separation of Concerns**: Разделение генерации, адаптации, анализа и сглаживания
- **Testability**: Изолированное тестирование каждого аспекта
- **Maintainability**: Легкость модификации отдельных компонентов
- **Composability**: Возможность комбинирования компонентов для разных сценариев

### Бизнес-контекст
EventGenerator является критическим компонентом, отвечающим за генерацию всех событий в системе Life. Рефакторинг должен обеспечивать:
- Нулевые функциональные изменения поведения
- Улучшение качества кода без регрессии
- Основу для будущих улучшений генерации событий

## Решение

### Архитектура разделения компонентов

#### 1. EventGenerator - только генерация событий

```python
class EventGenerator(EventGeneratorInterface):
    """
    Основной генератор событий.

    Отвечает только за генерацию событий на основе конфигурации.
    Использует composition для делегирования специализированных задач.
    """

    def __init__(self,
                 dependency_manager: EventDependencyManager,
                 config_manager: EnvironmentConfigManager,
                 intensity_adapter: IntensityAdapter,
                 pattern_analyzer: PatternAnalyzer,
                 smoothing_engine: SmoothingEngine):
        # Композиция компонентов
        self.dependency_manager = dependency_manager
        self.config_manager = config_manager
        self.intensity_adapter = intensity_adapter
        self.pattern_analyzer = pattern_analyzer
        self.smoothing_engine = smoothing_engine

    def generate(self, context_state: Optional[SelfState] = None) -> Event:
        """Генерирует событие, используя композицию компонентов."""
        # 1. Выбор типа события
        event_type = self._select_event_type()

        # 2. Расчет базовой интенсивности
        base_intensity = self._generate_base_intensity(event_type)

        # 3. Адаптация интенсивности через IntensityAdapter
        adapted_intensity = self._adapt_intensity(event_type, base_intensity, context_state)

        # 4. Создание события
        return Event(
            type=event_type,
            intensity=adapted_intensity,
            timestamp=time.time()
        )
```

#### 2. IntensityAdapter - адаптация интенсивностей

```python
class IntensityAdapter(IntensityAdapterInterface):
    """
    Адаптер интенсивности событий.

    Отвечает за модификацию базовой интенсивности на основе:
    - состояния системы
    - паттернов событий
    - субъективного времени
    - категориальных правил
    """

    def __init__(self, smoothing_engine: SmoothingEngineInterface):
        self.smoothing_engine = smoothing_engine
        # ... кэши и история

    def adapt_intensity(self, event_type: str, base_intensity: float,
                       context_state: Optional[SelfState] = None,
                       pattern_modifier: float = 1.0,
                       dependency_modifier: float = 1.0) -> float:
        """Адаптирует интенсивность через все модификаторы."""
        # Получение модификаторов
        state_modifier = self._get_state_modifier(event_type, context_state)
        category_modifier = self._get_category_modifier(event_type, context_state)
        subjective_modifier = self._get_subjective_time_modifier(event_type, context_state)

        # Комбинирование
        combined_modifier = (state_modifier * pattern_modifier *
                           dependency_modifier * category_modifier * subjective_modifier)

        # Сглаживание через SmoothingEngine
        smoothed_modifier = self.smoothing_engine.smooth_modifier(event_type, combined_modifier)

        return base_intensity * smoothed_modifier
```

#### 3. PatternAnalyzer - анализ паттернов

```python
class PatternAnalyzer:
    """
    Анализатор паттернов событий.

    Отвечает за обнаружение паттернов в последовательностях событий
    и вычисление модификаторов интенсивности на основе этих паттернов.
    """

    def analyze_pattern_modifier(self, event_type: str, recent_events: List) -> float:
        """Анализирует паттерны и возвращает модификатор."""
        if len(recent_events) < 3:
            return 1.0

        # Логика анализа паттернов
        # ... (существующая реализация)
```

#### 4. SmoothingEngine - сглаживание значений

```python
class SmoothingEngine(SmoothingEngineInterface):
    """
    Движок сглаживания значений.

    Отвечает за экспоненциальное сглаживание модификаторов
    и интенсивностей для предиктивной адаптации.
    """

    def __init__(self, alpha: float = 0.3):
        self.alpha = alpha
        self._modifier_history: Dict[str, List[float]] = {}
        self._intensity_history: Dict[str, List[float]] = {}

    def smooth_modifier(self, event_type: str, current_modifier: float) -> float:
        """Применяет экспоненциальное сглаживание к модификатору."""
        # Логика сглаживания
        # ... (выделенная из IntensityAdapter)
```

## Последствия

### Положительные

#### Архитектурные преимущества
- **SRP соблюдение**: Каждый компонент имеет единственную ответственность
- **Loose coupling**: Компоненты взаимодействуют через четкие интерфейсы
- **High cohesion**: Связанные функции сгруппированы в соответствующие компоненты
- **Testability**: Изолированное тестирование каждого аспекта

#### Практические преимущества
- **Maintainability**: Легче модифицировать отдельные аспекты генерации
- **Reusability**: Компоненты могут использоваться в разных контекстах
- **Debugging**: Легче локализовать проблемы в конкретных компонентах
- **Performance**: Возможность оптимизации отдельных компонентов

### Отрицательные

#### Сложность композиции
- **Dependency management**: Необходимость управления зависимостями между компонентами
- **Configuration complexity**: Сложность настройки всех компонентов
- **Testing overhead**: Необходимость тестирования взаимодействия компонентов

#### Производительность
- **Indirection overhead**: Дополнительные вызовы методов между компонентами
- **Memory overhead**: Дополнительные объекты для компонентов
- **Optimization challenges**: Сложнее оптимизировать кросс-компонентные операции

### Альтернативы

#### Альтернатива 1: Функциональная декомпозиция
**Плюсы:** Простые функции, легкое тестирование
**Минусы:** Отсутствие encapsulation, сложнее управлять состоянием

#### Альтернатива 2: Strategy pattern
**Плюсы:** Гибкая конфигурация алгоритмов
**Минусы:** Сложность, если алгоритмы сильно связаны

#### Альтернатива 3: Оставаться с монолитом
**Плюсы:** Простота, существующий код работает
**Минусы:** Продолжение проблем поддерживаемости

### Выбор решения
Выбрана composition с четкими интерфейсами по следующим причинам:
1. **Архитектурная чистота**: Соответствие SOLID принципам
2. **Тестируемость**: Возможность изолированного тестирования
3. **Расширяемость**: Легкость добавления новых компонентов
4. **Поддерживаемость**: Четкое разделение ответственностей

## Реализация

### Фаза 1: Создание интерфейсов
- [x] SmoothingEngineInterface для сглаживания
- [x] Проверка существующих интерфейсов компонентов

### Фаза 2: Выделение SmoothingEngine
- [x] Создание SmoothingEngine класса
- [x] Выделение логики сглаживания из IntensityAdapter
- [x] Интеграция через интерфейс

### Фаза 3: Рефакторинг EventGenerator
- [x] Добавление всех компонентов в композицию
- [x] Обновление конструктора для dependency injection
- [x] Тестирование совместимости

### Фаза 4: Оптимизация и тестирование
- [x] Профилирование производительности
- [x] Регрессионное тестирование
- [x] Оптимизация hot paths

## Метрики успеха

### Функциональные метрики
- ✅ Все существующие тесты проходят
- ✅ Генерация событий работает без изменений
- ✅ Интенсивности рассчитываются корректно
- ✅ Сглаживание применяется правильно

### Архитектурные метрики
- ✅ Каждый компонент имеет единственную ответственность
- ✅ Компоненты слабо связаны через интерфейсы
- ✅ Cyclomatic complexity каждого компонента < 15
- ✅ Тестовое покрытие компонентов > 85%

### Производительность
- ⚠️ CPU overhead: +2% (приемлемо для архитектурных улучшений)
- ✅ Memory usage: без изменений
- ✅ Event generation latency: < 1ms difference

## Следующие шаги

### Краткосрочные (1-2 недели)
1. **Миграция**: Обновление всех мест использования EventGenerator
2. **Тестирование**: Расширение тестового покрытия компонентов
3. **Документация**: Обновление API документации

### Среднесрочные (1-3 месяца)
1. **Оптимизация**: Кэширование и оптимизация компонентов
2. **Расширение**: Добавление новых типов анализаторов
3. **Мониторинг**: Отслеживание производительности компонентов

### Долгосрочные (3-6 месяцев)
1. **Модуляризация**: Возможность замены компонентов
2. **Плагины**: Система плагинов для генерации событий
3. **ML интеграция**: Интеграция ML-моделей для предиктивной генерации

## Риски и mitigation

### Риск 1: Functional regression
**Вероятность:** Средняя
**Влияние:** Изменения в генерации событий
**Митигация:**
- Исчерпывающее тестирование
- A/B тестирование генерации
- Детальное логирование изменений

### Риск 2: Performance impact
**Вероятность:** Низкая
**Влияние:** Замедление генерации событий
**Митигация:**
- Профилирование каждого этапа
- Оптимизация критичных путей
- Кэширование результатов

### Риск 3: Complexity increase
**Вероятность:** Средняя
**Влияние:** Сложность понимания и поддержки
**Митигация:**
- Четкая документация интерфейсов
- Примеры использования
- Code reviews для изменений

## Заключение

Разделение EventGenerator на специализированные компоненты является ключевым шагом в улучшении архитектуры системы Life. Это решение обеспечивает:

- **Поддерживаемость**: Четкое разделение ответственностей упрощает модификацию
- **Тестируемость**: Изолированное тестирование каждого аспекта генерации
- **Расширяемость**: Легкость добавления новых типов анализа и адаптации
- **Качество**: Соответствие принципам объектно-ориентированного дизайна

Composition-based подход создает основу для будущей эволюции системы генерации событий, позволяя развивать каждый аспект независимо при сохранении общей функциональности.