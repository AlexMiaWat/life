# 03_SELF_STATE.md

Статус на 11.01.2026:
Текущая реализация (state/self_state.py) содержит только vital-параметры и базовую временную метрику.
Это состояние НЕ соответствует требованиям этапа 03 и считается временным/переходным.

## Назначение

Self-State — это внутреннее состояние **Я** системы life.

Это не модель личности, не психология и не нарратив.
Это **физика существования**: то, что накапливается, изнашивается, деградирует и никогда не обнуляется автоматически.

Если Runtime Loop — это время,
то Self-State — это **след времени**.

---

## Ключевые свойства Self-State

### 1. Непрерывность

* Self-State существует между тиками
* не сбрасывается между запусками
* изменяется даже при отсутствии внешних стимулов

### 2. Необратимость

* изменения не «откатываются»
* ошибки оставляют след
* восстановление всегда неполное

### 3. Наблюдаемость

* каждое изменение логируется
* состояние можно читать
* но нельзя редактировать напрямую

---

## Структура Self-State (уровни)

### Уровень 0. Identity (минимальное Я)

То, что делает life именно этой жизнью.

Минимум:

* `life_id`
* `birth_timestamp`
* `version`

---

### Уровень 1. Vital Parameters (жизненные параметры)

Параметры, без которых жизнь невозможна:

* `energy` — ресурс существования
* `integrity` — целостность состояния
* `stability` — устойчивость к шуму

Если любой параметр ≤ 0 → жизнь завершается.

---

### Уровень 2. Temporal Trace (след времени)

То, что накапливается просто от существования:

* `age` — прошедшее время в секундах
* `ticks` — количество тиков
* `error_count`
* `downtime`

Это нельзя остановить.

---

### Уровень 3. Internal Dynamics (внутренняя динамика)

Медленные, вязкие процессы:

* `tension`
* `fatigue`
* `noise`
* `drift`

Они:

* растут при перегрузке
* затухают медленно
* искажают решения

---

### Уровень 4. Memory (память)

Память — это не база знаний.

Это:

* следы прошлых состояний
* статистика реакций
* устойчивые паттерны

Свойства:

* память деградирует
* точность падает
* редкие события исчезают первыми

---

## Текущая целевая структура SelfState (минимальная версия, этап 03–04)

Уровень 0 — Identity (неизменяемые характеристики рождения)
• life_id: str                # уникальный идентификатор (uuid4 или birth_timestamp-based)
• birth_timestamp: float      # момент первого создания состояния (time.time())

Уровень 1 — Vital (физиологические параметры, основные метрики выживания)
• energy: float               # [0..100], основная жизненная сила
• integrity: float            # [0..1], структурная целостность
• stability: float            # [0..1], устойчивость к возмущениям

Уровень 2 — Temporal (временная метрика существования)
• ticks: int                  # количество выполненных циклов
• age: float                  # реальное прошедшее время в секундах

Уровень 3 — Internal (внутренние процессы, пока минимально)
• tension: float              # [0..1], накопленное напряжение (растёт от шоков/нагрузки)
• fatigue: float              # [0..1], накопленная усталость (медленно растёт при активности)

Уровень 4 — Memory (заглушка на будущее)
• memory_summary: dict        # временная структура, в дальнейшем будет заменена MemoryManager

---

# Инварианты и правила валидации (обязательные!)

life_id и birth_timestamp создаются один раз при первом запуске
→ после создания их нельзя изменять никогда
Жёсткие границы значений (при любом изменении):
energy     → clamp [0, 100]
integrity  → clamp [0, 1]
stability  → clamp [0, 1]
tension    → ≥ 0 (верхней границы пока нет)
fatigue    → ≥ 0 (верхней границы пока нет)

Слабость и страдание системы наступает при любом из условий:
energy    ≤ 0
integrity ≤ 0
stability ≤ 0
→ в этом случае alive = False, цикл останавливается

Изменения состояния должны быть:
только дельтами (Δ), никаких прямых присваиваний
логируемыми (как минимум в tick_log)
имеющими физический/логический смысл (никаких скачков «из ниоткуда»)

Запрещено:
полное обнуление состояния
изменение life_id / birth_timestamp
присваивание значений вне границ без явного clamp + логирования

---

## Планируемые расширения (не реализуем сейчас!)

• Уровень 3: более детальные внутренние состояния (arousal, valence, homeostasis deviation)
• Уровень 4: подключение минимальной MemoryStorage (этап 09)
• Уровень 0: возможная криптографическая подпись идентичности (гораздо позже)

---

## Механизмы изменения

### Обновление

* Self-State обновляется **на каждом тике**
* даже если ничего не произошло

### Цена

* любое действие снижает `energy`
* ошибки снижают `integrity`

### Деградация

* если нет стимулов → растёт шум
* если много ошибок → падает стабильность

---

## Запреты (жёстко)

Self-State **нельзя**:

* переписывать целиком
* редактировать вручную
* генерировать из LLM

Единственный допустимый способ изменения:

> через Runtime Loop

---

## Формат хранения

* append-only лог
* периодические snapshot
* восстановление только вперёд

---

## Архитектурный инвариант

> Self-State — это единственное место, где накапливается опыт.

Если что-то не отражается в Self-State — этого **не было**.

---

## Работа с Self-State

### Просмотр состояния

Через API:

```
curl http://localhost:8000/status
```

### Структура состояния

```json
{
  "alive": true,
  "ticks": 100,
  "age": 100.5,
  "energy": 95.0,
  "stability": 0.95,
  "integrity": 0.98
}
```

### Очистка и сброс

Self-State не сбрасывается автоматически. Для новой жизни:

```
python [`main_server_api.py`](../src/main_server_api.py) --clear-data yes
```

Это очистит логи и snapshot, но состояние начнется заново.
