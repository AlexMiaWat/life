# 03_SELF_STATE.md

## Назначение

Self-State — это внутреннее состояние **Я** системы life.

Это не модель личности, не психология и не нарратив.
Это **физика существования**: то, что накапливается, изнашивается, деградирует и никогда не обнуляется автоматически.

Если Runtime Loop — это время,
то Self-State — это **след времени**.

---

## Ключевые свойства Self-State

### 1. Непрерывность

* Self-State существует между тиками
* не сбрасывается между запусками
* изменяется даже при отсутствии внешних стимулов

### 2. Необратимость

* изменения не «откатываются»
* ошибки оставляют след
* восстановление всегда неполное

### 3. Наблюдаемость

* каждое изменение логируется
* состояние можно читать
* но нельзя редактировать напрямую

---

## Структура Self-State (уровни)

### Уровень 0. Identity (минимальное Я)

То, что делает life именно этой жизнью.

Минимум:

* `life_id`
* `birth_timestamp`
* `version`

---

### Уровень 1. Vital Parameters (жизненные параметры)

Параметры, без которых жизнь невозможна:

* `energy` — ресурс существования
* `integrity` — целостность состояния
* `stability` — устойчивость к шуму

Если любой параметр ≤ 0 → жизнь завершается.

---

### Уровень 2. Temporal Trace (след времени)

То, что накапливается просто от существования:

* `age` — прошедшее время в секундах
* `ticks` — количество тиков
* `error_count`
* `downtime`

Это нельзя остановить.

---

### Уровень 3. Internal Dynamics (внутренняя динамика)

Медленные, вязкие процессы:

* `tension`
* `fatigue`
* `noise`
* `drift`

Они:

* растут при перегрузке
* затухают медленно
* искажают решения

---

### Уровень 4. Memory (память)

Память — это не база знаний.

Это:

* следы прошлых состояний
* статистика реакций
* устойчивые паттерны

Свойства:

* память деградирует
* точность падает
* редкие события исчезают первыми

---

## Механизмы изменения

### Обновление

* Self-State обновляется **на каждом тике**
* даже если ничего не произошло

### Цена

* любое действие снижает `energy`
* ошибки снижают `integrity`

### Деградация

* если нет стимулов → растёт шум
* если много ошибок → падает стабильность

---

## Запреты (жёстко)

Self-State **нельзя**:

* переписывать целиком
* редактировать вручную
* генерировать из LLM

Единственный допустимый способ изменения:

> через Runtime Loop

---

## Формат хранения

* append-only лог
* периодические snapshot
* восстановление только вперёд

---

## Архитектурный инвариант

> Self-State — это единственное место, где накапливается опыт.

Если что-то не отражается в Self-State — этого **не было**.

---

## Работа с Self-State

### Просмотр состояния

Через API:

```
curl http://localhost:8000/status
```

### Структура состояния

```json
{
  "alive": true,
  "ticks": 100,
  "age": 100.5,
  "energy": 95.0,
  "stability": 0.95,
  "integrity": 0.98
}
```

### Очистка и сброс

Self-State не сбрасывается автоматически. Для новой жизни:

```
python [`main_server_api.py`](../src/main_server_api.py) --clear-data yes
```

Это очистит логи и snapshot, но состояние начнется заново.
